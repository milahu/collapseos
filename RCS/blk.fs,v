head	1.94;
access;
symbols;
locks;
comment	@# @;


1.94
date	2021.04.02.16.04.16;	author vdupras;	state Exp;
branches;
next	1.93;

1.93
date	2021.04.01.23.31.32;	author vdupras;	state Exp;
branches;
next	1.92;

1.92
date	2021.03.29.16.10.04;	author vdupras;	state Exp;
branches;
next	1.91;

1.91
date	2021.03.29.13.21.09;	author vdupras;	state Exp;
branches;
next	1.90;

1.90
date	2021.03.28.21.21.21;	author vdupras;	state Exp;
branches;
next	1.89;

1.89
date	2021.03.28.19.33.16;	author vdupras;	state Exp;
branches;
next	1.88;

1.88
date	2021.03.28.19.29.02;	author vdupras;	state Exp;
branches;
next	1.87;

1.87
date	2021.03.28.18.44.32;	author vdupras;	state Exp;
branches;
next	1.86;

1.86
date	2021.03.28.18.17.13;	author vdupras;	state Exp;
branches;
next	1.85;

1.85
date	2021.03.28.17.53.46;	author vdupras;	state Exp;
branches;
next	1.84;

1.84
date	2021.03.28.17.40.10;	author vdupras;	state Exp;
branches;
next	1.83;

1.83
date	2021.03.28.17.34.09;	author vdupras;	state Exp;
branches;
next	1.82;

1.82
date	2021.03.20.15.05.15;	author vdupras;	state Exp;
branches;
next	1.81;

1.81
date	2021.03.20.14.16.17;	author vdupras;	state Exp;
branches;
next	1.80;

1.80
date	2021.03.20.13.38.49;	author vdupras;	state Exp;
branches;
next	1.79;

1.79
date	2021.03.20.13.30.41;	author vdupras;	state Exp;
branches;
next	1.78;

1.78
date	2021.03.19.11.49.03;	author vdupras;	state Exp;
branches;
next	1.77;

1.77
date	2021.03.19.11.40.38;	author vdupras;	state Exp;
branches;
next	1.76;

1.76
date	2021.03.06.03.32.48;	author root;	state Exp;
branches;
next	1.75;

1.75
date	2021.03.05.21.51.24;	author root;	state Exp;
branches;
next	1.74;

1.74
date	2021.03.05.20.01.24;	author root;	state Exp;
branches;
next	1.73;

1.73
date	2021.03.05.19.47.50;	author root;	state Exp;
branches;
next	1.72;

1.72
date	2021.03.05.19.36.50;	author root;	state Exp;
branches;
next	1.71;

1.71
date	2021.03.05.17.15.03;	author root;	state Exp;
branches;
next	1.70;

1.70
date	2021.03.03.21.44.28;	author root;	state Exp;
branches;
next	1.69;

1.69
date	2021.03.03.19.00.41;	author root;	state Exp;
branches;
next	1.68;

1.68
date	2021.03.02.14.05.32;	author root;	state Exp;
branches;
next	1.67;

1.67
date	2021.03.02.00.30.45;	author root;	state Exp;
branches;
next	1.66;

1.66
date	2021.03.02.00.17.11;	author root;	state Exp;
branches;
next	1.65;

1.65
date	2021.02.27.23.46.15;	author root;	state Exp;
branches;
next	1.64;

1.64
date	2021.02.27.22.21.16;	author root;	state Exp;
branches;
next	1.63;

1.63
date	2021.02.27.21.29.58;	author root;	state Exp;
branches;
next	1.62;

1.62
date	2021.02.27.14.42.30;	author root;	state Exp;
branches;
next	1.61;

1.61
date	2021.02.26.13.37.26;	author root;	state Exp;
branches;
next	1.60;

1.60
date	2021.02.26.13.20.31;	author root;	state Exp;
branches;
next	1.59;

1.59
date	2021.02.26.13.06.35;	author root;	state Exp;
branches;
next	1.58;

1.58
date	2021.02.26.00.16.59;	author root;	state Exp;
branches;
next	1.57;

1.57
date	2021.02.25.16.21.23;	author root;	state Exp;
branches;
next	1.56;

1.56
date	2021.02.24.21.03.25;	author root;	state Exp;
branches;
next	1.55;

1.55
date	2021.02.22.01.27.01;	author root;	state Exp;
branches;
next	1.54;

1.54
date	2021.02.19.15.00.56;	author vdupras;	state Exp;
branches;
next	1.53;

1.53
date	2021.02.19.14.12.16;	author vdupras;	state Exp;
branches;
next	1.52;

1.52
date	2021.02.18.17.50.30;	author vdupras;	state Exp;
branches;
next	1.51;

1.51
date	2021.02.17.21.34.06;	author vdupras;	state Exp;
branches;
next	1.50;

1.50
date	2021.02.17.20.42.58;	author vdupras;	state Exp;
branches;
next	1.49;

1.49
date	2021.02.17.20.20.58;	author vdupras;	state Exp;
branches;
next	1.48;

1.48
date	2021.02.17.20.15.03;	author vdupras;	state Exp;
branches;
next	1.47;

1.47
date	2021.02.17.16.24.02;	author vdupras;	state Exp;
branches;
next	1.46;

1.46
date	2021.02.17.16.08.56;	author vdupras;	state Exp;
branches;
next	1.45;

1.45
date	2021.02.17.15.32.11;	author vdupras;	state Exp;
branches;
next	1.44;

1.44
date	2021.02.17.15.24.48;	author vdupras;	state Exp;
branches;
next	1.43;

1.43
date	2021.02.17.03.07.05;	author vdupras;	state Exp;
branches;
next	1.42;

1.42
date	2021.02.17.02.38.46;	author vdupras;	state Exp;
branches;
next	1.41;

1.41
date	2021.02.16.15.12.56;	author vdupras;	state Exp;
branches;
next	1.40;

1.40
date	2021.02.16.13.31.18;	author vdupras;	state Exp;
branches;
next	1.39;

1.39
date	2021.02.16.13.22.21;	author vdupras;	state Exp;
branches;
next	1.38;

1.38
date	2021.02.16.13.06.46;	author vdupras;	state Exp;
branches;
next	1.37;

1.37
date	2021.02.16.12.54.51;	author vdupras;	state Exp;
branches;
next	1.36;

1.36
date	2021.02.16.12.31.40;	author vdupras;	state Exp;
branches;
next	1.35;

1.35
date	2021.02.15.22.25.25;	author vdupras;	state Exp;
branches;
next	1.34;

1.34
date	2021.02.15.19.41.01;	author vdupras;	state Exp;
branches;
next	1.33;

1.33
date	2021.02.15.19.35.24;	author vdupras;	state Exp;
branches;
next	1.32;

1.32
date	2021.02.15.17.22.03;	author vdupras;	state Exp;
branches;
next	1.31;

1.31
date	2021.02.13.22.09.58;	author vdupras;	state Exp;
branches;
next	1.30;

1.30
date	2021.02.13.17.54.35;	author vdupras;	state Exp;
branches;
next	1.29;

1.29
date	2021.02.13.16.08.56;	author vdupras;	state Exp;
branches;
next	1.28;

1.28
date	2021.02.13.14.40.30;	author vdupras;	state Exp;
branches;
next	1.27;

1.27
date	2021.02.11.20.30.54;	author vdupras;	state Exp;
branches;
next	1.26;

1.26
date	2021.02.11.14.38.25;	author vdupras;	state Exp;
branches;
next	1.25;

1.25
date	2021.02.11.13.29.36;	author vdupras;	state Exp;
branches;
next	1.24;

1.24
date	2021.02.11.12.55.07;	author vdupras;	state Exp;
branches;
next	1.23;

1.23
date	2021.02.10.18.42.02;	author vdupras;	state Exp;
branches;
next	1.22;

1.22
date	2021.02.10.18.20.39;	author vdupras;	state Exp;
branches;
next	1.21;

1.21
date	2021.02.10.16.55.02;	author vdupras;	state Exp;
branches;
next	1.20;

1.20
date	2021.02.10.16.26.10;	author vdupras;	state Exp;
branches;
next	1.19;

1.19
date	2021.02.10.15.39.56;	author vdupras;	state Exp;
branches;
next	1.18;

1.18
date	2021.01.27.15.57.37;	author vdupras;	state Exp;
branches;
next	1.17;

1.17
date	2021.01.25.18.12.23;	author vdupras;	state Exp;
branches;
next	1.16;

1.16
date	2021.01.24.18.59.41;	author vdupras;	state Exp;
branches;
next	1.15;

1.15
date	2021.01.24.18.52.56;	author vdupras;	state Exp;
branches;
next	1.14;

1.14
date	2021.01.20.19.46.49;	author vdupras;	state Exp;
branches;
next	1.13;

1.13
date	2021.01.20.17.06.03;	author vdupras;	state Exp;
branches;
next	1.12;

1.12
date	2021.01.20.03.02.04;	author vdupras;	state Exp;
branches;
next	1.11;

1.11
date	2021.01.12.22.05.03;	author vdupras;	state Exp;
branches;
next	1.10;

1.10
date	2021.01.12.21.43.52;	author vdupras;	state Exp;
branches;
next	1.9;

1.9
date	2021.01.11.16.30.59;	author vdupras;	state Exp;
branches;
next	1.8;

1.8
date	2021.01.11.02.16.58;	author vdupras;	state Exp;
branches;
next	1.7;

1.7
date	2021.01.11.01.33.38;	author vdupras;	state Exp;
branches;
next	1.6;

1.6
date	2021.01.08.02.08.48;	author vdupras;	state Exp;
branches;
next	1.5;

1.5
date	2021.01.08.02.00.46;	author vdupras;	state Exp;
branches;
next	1.4;

1.4
date	2021.01.08.01.18.03;	author vdupras;	state Exp;
branches;
next	1.3;

1.3
date	2021.01.08.00.37.58;	author vdupras;	state Exp;
branches;
next	1.2;

1.2
date	2021.01.06.17.40.39;	author vdupras;	state Exp;
branches;
next	1.1;

1.1
date	2021.01.05.19.14.10;	author vdupras;	state Exp;
branches;
next	;


desc
@Main source file of Collapse OS.
@


1.94
log
@6809: check for overflow less often
@
text
@( ----- 000 )
MASTER INDEX

002 Common assembler words    005 Z80 assembler
020 8086 assembler            030 AVR assembler
050 6809 assembler            60-99 unused
100 Block editor              110 Visual Editor
120-149 unused                150 Remote Shell
160 AVR SPI programmer        165 Sega ROM signer
170-199 unused                200 Cross compilation
210 Core words                240 Grid subsystem
245 PS/2 keyboard subsystem   250 SD Card subsystem
260 Fonts
280 Z80 boot code             310 Z80 drivers
400 8086 boot code            420 8086 drivers
450 6809 boot code            460 6809 drivers
( ----- 002 )
( Common assembler words )
CREATE ORG 0 ,
CREATE BIN( 0 ,
: PC HERE ORG @@ - BIN( @@ + ;
: <<3 3 LSHIFT ;    : <<4 4 LSHIFT ;
VARIABLE L1 VARIABLE L2 VARIABLE L3 VARIABLE L4
CREATE BIGEND? 0 C,
: |T BIGEND? C@@ IF |M ELSE |L THEN ;
: T! ( n a -- ) SWAP |T ROT C!+ C! ;
: T, ( n -- ) |T C, C, ;
: T@@ C@@+ SWAP C@@ BIGEND? C@@ IF SWAP THEN 8 LSHIFT OR ;
CREATE lblnext 0 ,
: lblnext@@ lblnext @@ ?DUP NOT IF ABORT" no lblnext!" THEN ;
: LIVETGT 0 BIN+ DUP BIN( ! ORG ! 0xf BIN+ @@ lblnext ! ;
: CODE (entry) 0 ( native ) C, ;
( ----- 005 )
( Z80 Assembler )
-3 LOAD+ ( common words )
: A 7 ; : B 0 ; : C 1 ; : D 2 ;
: E 3 ; : H 4 ; : L 5 ; : (HL) 6 ;
: BC 0 ; : DE 1 ; : HL 2 ; : AF 3 ; : SP AF ;
: CNZ 0 ; : CZ 1 ; : CNC 2 ; : CC 3 ;
: CPO 4 ; : CPE 5 ; : CP 6 ; : CM 7 ;
1 13 LOADR+
( ----- 006 )
( As a general rule, IX and IY are equivalent to spitting an
  extra 0xdd / 0xfd and then spit the equivalent of HL )
: IX 0xdd C, HL ; : IY 0xfd C, HL ;
: IX+ 0xff AND 0xdd C, (HL) ; : IX- 0 -^ IX+ ;
: IY+ 0xff AND 0xfd C, (HL) ; : IY- 0 -^ IY+ ;
: OPXY CREATE , DOES> @@ ( xyoff opref ) EXECUTE C, ;
( ----- 007 )
: OP1 CREATE C, DOES> C@@ C, ;
0xf3 OP1 DI,                   0xfb OP1 EI,
0xeb OP1 EXDEHL,               0xd9 OP1 EXX,
0x08 OP1 EXAFAF',              0xe3 OP1 EX(SP)HL,
0x76 OP1 HALT,                 0xe9 OP1 JP(HL),
0x12 OP1 LD(DE)A,              0x1a OP1 LDA(DE),
0x02 OP1 LD(BC)A,              0x0a OP1 LDA(BC),
0x00 OP1 NOP,                  0xc9 OP1 RET,
0x17 OP1 RLA,                  0x07 OP1 RLCA,
0x1f OP1 RRA,                  0x0f OP1 RRCA,
0x37 OP1 SCF,
( ----- 008 )
( Relative jumps are a bit special. They're supposed to take
  an argument, but they don't take it so they can work with
  the label system. Therefore, relative jumps are an OP1 but
  when you use them, you're expected to write the offset
  afterwards yourself. )

0x18 OP1 JR,                   0x10 OP1 DJNZ,
0x38 OP1 JRC,                  0x30 OP1 JRNC,
0x28 OP1 JRZ,                  0x20 OP1 JRNZ,
( ----- 009 )
: OP1r CREATE C, DOES> C@@ ( r op ) SWAP <<3 OR C, ;
0x04 OP1r INCr,                0x05 OP1r DECr,
' INCr, OPXY INC(IXY+),        ' DECr, OPXY DEC(IXY+),
( also works for c )
0xc0 OP1r RETc,
( ----- 010 )
: OP1r0 CREATE C, DOES> C@@ ( r op ) OR C, ;
0x80 OP1r0 ADDr,               0x88 OP1r0 ADCr,
0xa0 OP1r0 ANDr,               0xb8 OP1r0 CPr,
0xb0 OP1r0 ORr,                0x90 OP1r0 SUBr,
0x98 OP1r0 SBCr,               0xa8 OP1r0 XORr,
' CPr, OPXY CP(IXY+),
( ----- 011 )
: OP1d CREATE C, DOES> C@@ ( d op ) SWAP <<4 OR C, ;
0xc5 OP1d PUSH,                0xc1 OP1d POP,
0x03 OP1d INCd,                0x0b OP1d DECd,
0x09 OP1d ADDHLd,
: ADDIXd, IX DROP ADDHLd, ;  : ADDIXIX, HL ADDIXd, ;
: ADDIYd, IY DROP ADDHLd, ;  : ADDIYIY, HL ADDIYd, ;

: LDrr, ( rd rr ) SWAP <<3 OR 0x40 OR C, ;
' LDrr, OPXY LDIXYr,
: LDrIXY, ( rd ixy+- HL ) ROT SWAP LDIXYr, ;
: LDri, ( r i ) SWAP <<3 0x06 OR C, C, ;
: LDdi, ( d n ) SWAP <<4 0x01 OR C, T, ;
: LDd(i), ( d i ) 0xed C, SWAP <<4 0x4b OR C, T, ;
: LD(i)d, ( i d ) 0xed C, <<4 0x43 OR C, T, ;
( ----- 012 )
: OPED CREATE C, DOES> 0xed C, C@@ C, ;
0xa1 OPED CPI,       0xb1 OPED CPIR,     0xa9 OPED CPD,
0xb9 OPED CPDR,      0x46 OPED IM0,      0x56 OPED IM1,
0x5e OPED IM2,       0xa0 OPED LDI,      0xb0 OPED LDIR,
0xa8 OPED LDD,       0xb8 OPED LDDR,     0x44 OPED NEG,
0x4d OPED RETI,      0x45 OPED RETN,

: OP2i CREATE C, DOES> C@@ ( i op ) C, C, ;
0xd3 OP2i OUTiA,     0xdb OP2i INAi,     0xc6 OP2i ADDi,
0xe6 OP2i ANDi,      0xf6 OP2i ORi,      0xd6 OP2i SUBi,
0xee OP2i XORi,      0xfe OP2i CPi,

: OP2br CREATE C, DOES>
    0xcb C, C@@ ( b r op ) ROT <<3 OR OR C, ;
0xc0 OP2br SET,      0x80 OP2br RES,     0x40 OP2br BIT,
( ----- 013 )
( bitwise rotation ops have a similar sig )
: OProt CREATE C, DOES> 0xcb C, C@@ ( r op ) OR C, ;
0x10 OProt RL,       0x00 OProt RLC,     0x18 OProt RR,
0x08 OProt RRC,      0x20 OProt SLA,     0x38 OProt SRL,

( cell contains both bytes. MSB is spit as-is, LSB is ORed
  with r )
: OP2r CREATE , DOES> @@ |M ( r lsb msb ) C, SWAP <<3 OR C, ;
0xed41 OP2r OUT(C)r, 0xed40 OP2r INr(C),

: OP2d CREATE C, DOES> 0xed C, C@@ ( d op ) SWAP <<4 OR C, ;
0x4a OP2d ADCHLd,    0x42 OP2d SBCHLd,
( ----- 014 )
: OP3i CREATE C, DOES> C@@ ( i op ) C, T, ;
0xcd OP3i CALL,                0xc3 OP3i JP,
0x22 OP3i LD(i)HL,             0x2a OP3i LDHL(i),
0x32 OP3i LD(i)A,              0x3a OP3i LDA(i),

: RST, 0xc7 OR C, ;
: JP(IX), IX DROP JP(HL), ;
: JP(IY), IY DROP JP(HL), ;
( ----- 015 )
: JPc, SWAP <<3 0xc2 OR C, T, ;
: BCALL, BIN( @@ + CALL, ;
: BJP, BIN( @@ + JP, ;
: BJPc, BIN( @@ + JPc, ;
: ;CODE lblnext@@ JP, ;
( ----- 016 )
( Place BEGIN, where you want to jump back and AGAIN after
  a relative jump operator. Just like BSET and BWR. )
: BEGIN, PC ;
: BSET BEGIN, SWAP ! ;
( same as BSET, but we need to write a placeholder )
: FJR, BEGIN, 0 C, ;
: IFZ, JRNZ, FJR, ;
: IFNZ, JRZ, FJR, ;
: IFC, JRNC, FJR, ;
: IFNC, JRC, FJR, ;
: THEN,
    DUP PC ( l l pc ) -^ 1- ( l off )
    ( warning: l is a PC offset, not a mem addr! )
    SWAP ORG @@ + BIN( @@ - ( off addr ) C! ;
: ELSE, JR, FJR, SWAP THEN, ;
( ----- 017 )
: FWR BSET 0 C, ;
: FSET @@ THEN, ;
: AGAIN, PC - 1- _bchk C, ;
: BWR @@ AGAIN, ;
( ----- 018 )
( Macros )
( clear carry + SBC )
: SUBHLd, A ORr, SBCHLd, ;
: PUSH0, DE 0 LDdi, DE PUSH, ;
: PUSH1, DE 1 LDdi, DE PUSH, ;
: PUSHZ, DE 0 LDdi, IFZ, DE INCd, THEN, DE PUSH, ;
: PUSHA, D 0 LDri, E A LDrr, DE PUSH, ;
: HLZ, A H LDrr, L ORr, ;
: DEZ, A D LDrr, E ORr, ;
: LDDE(HL), E (HL) LDrr, HL INCd, D (HL) LDrr, ;
: OUTHL, DUP A H LDrr, OUTiA, A L LDrr, OUTiA, ;
: OUTDE, DUP A D LDrr, OUTiA, A E LDrr, OUTiA, ;
( ----- 020 )
( 8086 assembler. See doc/asm.txt )
-18 LOAD+ ( common words )
: AL 0 ; : CL 1 ; : DL 2 ; : BL 3 ;
: AH 4 ; : CH 5 ; : DH 6 ; : BH 7 ;
: AX 0 ; : CX 1 ; : DX 2 ; : BX 3 ;
: SP 4 ; : BP 5 ; : SI 6 ; : DI 7 ;
: ES 0 ; : CS 1 ; : SS 2 ; : DS 3 ;
: [BX+SI] 0 ; : [BX+DI] 1 ; : [BP+SI] 2 ; : [BP+DI] 3 ;
: [SI] 4 ; : [DI] 5 ; : [BP] 6 ; : [BX] 7 ;
1 9 LOADR+
( ----- 021 )
: OP1 CREATE C, DOES> C@@ C, ;
0xc3 OP1 RET,        0xfa OP1 CLI,       0xfb OP1 STI,
0xf4 OP1 HLT,        0xfc OP1 CLD,       0xfd OP1 STD,
0x90 OP1 NOP,        0x98 OP1 CBW,
0xf3 OP1 REPZ,       0xf2 OP1 REPNZ,     0xac OP1 LODSB,
0xad OP1 LODSW,      0xa6 OP1 CMPSB,     0xa7 OP1 CMPSW,
0xa4 OP1 MOVSB,      0xa5 OP1 MOVSW,     0xae OP1 SCASB,
0xaf OP1 SCASW,      0xaa OP1 STOSB,     0xab OP1 STOSW,
( no argument, jumps with relative addrs are special )
0xeb OP1 JMPs,       0xe9 OP1 JMPn,      0x74 OP1 JZ,
0x75 OP1 JNZ,        0x72 OP1 JC,        0x73 OP1 JNC,
0xe8 OP1 CALL,

: OP1r CREATE C, DOES> C@@ + C, ;
0x40 OP1r INCx,      0x48 OP1r DECx,
0x58 OP1r POPx,      0x50 OP1r PUSHx,
( ----- 022 )
: OPr0 ( reg op ) CREATE C, C, DOES>
    C@@+ C, C@@ <<3 OR 0xc0 OR C, ;
0 0xd0 OPr0 ROLr1,   0 0xd1 OPr0 ROLx1,  4 0xf6 OPr0 MULr,
1 0xd0 OPr0 RORr1,   1 0xd1 OPr0 RORx1,  4 0xf7 OPr0 MULx,
4 0xd0 OPr0 SHLr1,   4 0xd1 OPr0 SHLx1,  6 0xf6 OPr0 DIVr,
5 0xd0 OPr0 SHRr1,   5 0xd1 OPr0 SHRx1,  6 0xf7 OPr0 DIVx,
0 0xd2 OPr0 ROLrCL,  0 0xd3 OPr0 ROLxCL, 1 0xfe OPr0 DECr,
1 0xd2 OPr0 RORrCL,  1 0xd3 OPr0 RORxCL, 0 0xfe OPr0 INCr,
4 0xd2 OPr0 SHLrCL,  4 0xd3 OPr0 SHLxCL,
5 0xd2 OPr0 SHRrCL,  5 0xd3 OPr0 SHRxCL,
( ----- 023 )
: OPrr CREATE C, DOES> C@@ C, <<3 OR 0xc0 OR C, ;
0x31 OPrr XORxx,     0x30 OPrr XORrr,
0x88 OPrr MOVrr,     0x89 OPrr MOVxx,    0x28 OPrr SUBrr,
0x29 OPrr SUBxx,     0x08 OPrr ORrr,     0x09 OPrr ORxx,
0x38 OPrr CMPrr,     0x39 OPrr CMPxx,    0x00 OPrr ADDrr,
0x01 OPrr ADDxx,     0x20 OPrr ANDrr,    0x21 OPrr ANDxx,
( ----- 024 )
: OPmodrm ( opbase modrmbase ) CREATE C, C, DOES>
    @@ |M ( disp? modrm opoff modrmbase opbase ) ROT + C,
    ( disp? modrm modrmbase ) + DUP C, ( disp? modrm )
    0xc0 AND DUP IF ( has disp ) 0x80 AND IF
        ( disp low+high ) T, ELSE ( low only ) C, THEN
    ELSE ( no disp ) DROP THEN ;
( -- disp? modrm opoff )
: [b] ( r/m ) 0 ; : [w] ( r/m ) 1 ;
: [b]+ ( r/m disp8 ) SWAP 0x40 OR 0 ; : [w]+ [b]+ 1+ ;
: r[] ( r r/m ) SWAP <<3 OR 2 ; : x[] r[] 1+ ;
: []r ( r/m r ) <<3 OR 0 ; : []x []r 1+ ;
: r[]+ ( r r/m disp8 )
    ROT <<3 ROT OR 0x40 OR 2 ; : x[]+ r[]+ 1+ ;
: []+r ( r/m disp8 r ) <<3 ROT OR 0x40 OR 0 ; : []+x []+r 1+ ;
( ----- 025 )
0xfe 0 OPmodrm INC[],          0xfe 0x8 OPmodrm DEC[],
0xfe 0x30 OPmodrm PUSH[],      0x8e 0 OPmodrm POP[],
0x88 0 OPmodrm MOV[],          0x38 0 OPmodrm CMP[],

: OPi CREATE C, DOES> C@@ C, C, ;
0x04 OPi ADDALi,     0x24 OPi ANDALi,    0x2c OPi SUBALi,
0xcd OPi INT,
: OPI CREATE C, DOES> C@@ C, T, ;
0x05 OPI ADDAXI,     0x25 OPI ANDAXI,    0x2d OPI SUBAXI,
( ----- 026 )
: CMPri, 0x80 C, SWAP 0xf8 OR C, C, ;
: CMPxI, 0x81 C, SWAP 0xf8 OR C, T, ;
: CMPxi, 0x83 C, SWAP 0xf8 OR C, C, ;
: MOVri, SWAP 0xb0 OR C, C, ; : MOVxI, SWAP 0xb8 OR C, T, ;
: MOVsx, 0x8e C, SWAP <<3 OR 0xc0 OR C, ;
: MOVrm, 0x8a C, SWAP <<3 0x6 OR C, T, ;
: MOVxm, 0x8b C, SWAP <<3 0x6 OR C, T, ;
: MOVmr, 0x88 C, <<3 0x6 OR C, T, ;
: MOVmx, 0x89 C, <<3 0x6 OR C, T, ;
: PUSHs, <<3 0x06 OR C, ; : POPs, <<3 0x07 OR C, ;
: SUBxi, 0x83 C, SWAP 0xe8 OR C, C, ;
: ADDxi, 0x83 C, SWAP 0xc0 OR C, C, ;
: JMPr, 0xff C, 7 AND 0xe0 OR C, ;
: JMPf, ( seg off ) 0xea C, T, T, ;
( ----- 027 )
( Place BEGIN, where you want to jump back and AGAIN after
  a relative jump operator. Just like BSET and BWR. )
: BEGIN, PC ;
: BSET PC SWAP ! ;
( same as BSET, but we need to write a placeholder )
: FJR, PC 0 C, ;
: IFZ, JNZ, FJR, ;
: IFNZ, JZ, FJR, ;
: IFC, JNC, FJR, ;
: IFNC, JC, FJR, ;
: THEN,
    DUP PC          ( l l pc )
    -^ 1-           ( l off )
    ( warning: l is a PC offset, not a mem addr! )
    SWAP ORG @@ + BIN( @@ - ( off addr )
    C! ;
( ----- 028 )
: FWRs BSET 0 C, ;
: FSET @@ THEN, ;
: RPCs, PC - 1- DUP 128 + 0xff > IF ABORT" PC ovfl" THEN C, ;
: RPCn, PC - 2 - T, ;
: AGAIN, RPCs, ;
( Use RPCx with appropriate JMP/CALL op. Example:
  JMPs, 0x42 RPCs, or CALL, 0x1234 RPCn, )
( ----- 029 )
: PUSHZ, CX 0 MOVxI, IFZ, CX INCx, THEN, CX PUSHx, ;
: ;CODE JMPn, lblnext@@ RPCn, ;
( ----- 030 )
-28 LOAD+ ( common words )
( We divide by 2 because each PC represents a word. )
: PC HERE ORG @@ - 1 RSHIFT ;
1 11 LOADR+
( ----- 031 )
: _oor ." arg out of range: " .X SPC> ." PC " PC .X NL> ABORT ;
: _r8c DUP 7 > IF _oor THEN ;
: _r32c DUP 31 > IF _oor THEN ;
: _r16+c _r32c DUP 16 < IF _oor THEN ;
: _r64c DUP 63 > IF _oor THEN ;
: _r256c DUP 255 > IF _oor THEN ;
: _Rdp ( op rd -- op', place Rd ) 4 LSHIFT OR ;
( ----- 032 )
( 0000 000d dddd 0000 )
: OPRd CREATE , DOES> @@ SWAP _r32c _Rdp T, ;
0b1001010000000101 OPRd ASR,   0b1001010000000000 OPRd COM,
0b1001010000001010 OPRd DEC,   0b1001010000000011 OPRd INC,
0b1001001000000110 OPRd LAC,   0b1001001000000101 OPRd LAS,
0b1001001000000111 OPRd LAT,
0b1001010000000110 OPRd LSR,   0b1001010000000001 OPRd NEG,
0b1001000000001111 OPRd POP,   0b1001001000001111 OPRd PUSH,
0b1001010000000111 OPRd ROR,   0b1001010000000010 OPRd SWAP,
0b1001001000000100 OPRd XCH,
( ----- 033 )
( 0000 00rd dddd rrrr )
: OPRdRr CREATE C, DOES> C@@ ( rd rr op )
    OVER _r32c 0x10 AND 3 RSHIFT OR ( rd rr op' )
    8 LSHIFT OR 0xff0f AND ( rd op' )
    SWAP _r32c _Rdp T, ;
0x1c OPRdRr ADC,   0x0c OPRdRr ADD,    0x20 OPRdRr AND,
0x14 OPRdRr CP,    0x04 OPRdRr CPC,    0x10 OPRdRr CPSE,
0x24 OPRdRr EOR,   0x2c OPRdRr MOV,    0x9c OPRdRr MUL,
0x28 OPRdRr OR,    0x08 OPRdRr SBC,    0x18 OPRdRr SUB,

( 0000 0AAd dddd AAAA )
: OPRdA CREATE C, DOES> C@@ ( rd A op )
    OVER _r64c 0x30 AND 3 RSHIFT OR ( rd A op' )
    8 LSHIFT OR 0xff0f AND ( rd op' ) SWAP _r32c _Rdp T, ;
0xb0 OPRdA IN,     0xb8 OPRdA _ : OUT, SWAP _ ;
( ----- 034 )
( 0000 KKKK dddd KKKK )
: OPRdK CREATE C, DOES> C@@ ( rd K op )
    OVER _r256c 0xf0 AND 4 RSHIFT OR ( rd K op' )
    ROT _r16+c 4 LSHIFT ROT 0x0f AND OR ( op' rdK ) C, C, ;
0x70 OPRdK ANDI,   0x30 OPRdK CPI,     0xe0 OPRdK LDI,
0x60 OPRdK ORI,    0x40 OPRdK SBCI,    0x60 OPRdK SBR,
0x50 OPRdK SUBI,

( 0000 0000 AAAA Abbb )
: OPAb CREATE C, DOES> C@@ ( A b op )
    ROT _r32c 3 LSHIFT ROT _r8c OR C, C, ;
0x98 OPAb CBI,     0x9a OPAb SBI,      0x99 OPAb SBIC,
0x9b OPAb SBIS,
( ----- 035 )
: OPNA CREATE , DOES> @@ T, ;
0x9598 OPNA BREAK, 0x9488 OPNA CLC,    0x94d8 OPNA CLH,
0x94f8 OPNA CLI,   0x94a8 OPNA CLN,    0x94c8 OPNA CLS,
0x94e8 OPNA CLT,   0x94b8 OPNA CLV,    0x9498 OPNA CLZ,
0x9419 OPNA EIJMP, 0x9509 OPNA ICALL,  0x9519 OPNA EICALL,
0x9409 OPNA IJMP,  0x0000 OPNA NOP,    0x9508 OPNA RET,
0x9518 OPNA RETI,  0x9408 OPNA SEC,    0x9458 OPNA SEH,
0x9478 OPNA SEI,   0x9428 OPNA SEN,    0x9448 OPNA SES,
0x9468 OPNA SET,   0x9438 OPNA SEV,    0x9418 OPNA SEZ,
0x9588 OPNA SLEEP, 0x95a8 OPNA WDR,
( ----- 036 )
( 0000 0000 0sss 0000 )
: OPb CREATE , DOES> @@ ( b op )
    SWAP _r8c _Rdp T, ;
0b1001010010001000 OPb BCLR,   0b1001010000001000 OPb BSET,

( 0000 000d dddd 0bbb )
: OPRdb CREATE , DOES> @@ ( rd b op )
    ROT _r32c _Rdp SWAP _r8c OR T, ;
0b1111100000000000 OPRdb BLD,  0b1111101000000000 OPRdb BST,
0b1111110000000000 OPRdb SBRC, 0b1111111000000000 OPRdb SBRS,

( special cases )
: CLR, DUP EOR, ;  : TST, DUP AND, ; : LSL, DUP ADD, ;
( ----- 037 )
( a -- k12, absolute addr a, relative to PC in a k12 addr )
: _r7ffc DUP 0x7ff > IF _oor THEN ;
: _raddr12
    PC - DUP 0< IF 0x800 + _r7ffc 0x800 OR ELSE _r7ffc THEN ;
: RJMP _raddr12 0xc000 OR ;
: RCALL _raddr12 0xd000 OR ;
: RJMP, RJMP T, ; : RCALL, RCALL T, ;
( ----- 038 )
( a -- k7, absolute addr a, relative to PC in a k7 addr )
: _r3fc DUP 0x3f > IF _oor THEN ;
: _raddr7
    PC - DUP 0< IF 0x40 + _r3fc 0x40 OR ELSE _r3fc THEN ;
: _brbx ( a b op -- a ) OR SWAP _raddr7 3 LSHIFT OR ;
: BRBC 0xf400 _brbx ; : BRBS 0xf000 _brbx ; : BRCC 0 BRBC ;
: BRCS 0 BRBS ; : BREQ 1 BRBS ; : BRNE 1 BRBC ; : BRGE 4 BRBC ;
: BRHC 5 BRBC ; : BRHS 5 BRBS ; : BRID 7 BRBC ; : BRIE 7 BRBS ;
: BRLO BRCS ; : BRLT 4 BRBS ; : BRMI 2 BRBS ; : BRPL 2 BRBC ;
: BRSH BRCC ; : BRTC 6 BRBC ; : BRTS 6 BRBS ; : BRVC 3 BRBC ;
: BRVS 3 BRBS ;
( ----- 039 )
0b11100 CONSTANT X 0b01000 CONSTANT Y 0b00000 CONSTANT Z
0b11101 CONSTANT X+ 0b11001 CONSTANT Y+ 0b10001 CONSTANT Z+
0b11110 CONSTANT -X 0b11010 CONSTANT -Y 0b10010 CONSTANT -Z
: _ldst ( Rd XYZ op ) SWAP DUP 0x10 AND 8 LSHIFT SWAP 0xf AND
    OR OR ( Rd op' ) SWAP _Rdp T, ;
: LD, 0x8000 _ldst ; : ST, SWAP 0x8200 _ldst ;
( ----- 040 )
( L1 LBL! .. L1 ' RJMP LBL, )
: LBL! ( l -- ) PC SWAP ! ;
: LBL, ( l op -- ) SWAP @@ 1- SWAP EXECUTE T, ;
: SKIP, PC 0 T, ;
: TO, ( opw pc ) ( TODO: use !* instead of ! )
    ( warning: pc is a PC offset, not a mem addr! )
    2 * ORG @@ + PC 1- HERE ( opw addr tgt hbkp )
    ROT H ! ( opw tgt hbkp ) SWAP ROT EXECUTE HERE ! ( hbkp )
    H ! ;
( L1 FLBL, .. L1 ' RJMP FLBL! )
: FLBL, ( l -- ) LBL! 0 T, ;
: FLBL! ( l opw -- ) SWAP @@ TO, ;
: BEGIN, PC ; : AGAIN?, ( op ) SWAP 1- SWAP EXECUTE T, ;
: AGAIN, ['] RJMP AGAIN?, ;
: IF, ['] BREQ SKIP, ; : THEN, TO, ;
( ----- 041 )
( Constant common to all AVR models )
: R0 0 ; : R1 1 ; : R2 2 ; : R3 3 ; : R4 4 ; : R5 5 ; : R6 6 ;
: R7 7 ; : R8 8 ; : R9 9 ; : R10 10 ; : R11 11 ; : R12 12 ;
: R13 13 ; : R14 14 ; : R15 15 ; : R16 16 ; : R17 17 ;
: R18 18 ; : R19 19 ; : R20 20 ; : R21 21 ; : R22 22 ;
: R24 24 ; : R25 25 ; : R26 26 ; : R27 27 ; : R28 28 ;
: R29 29 ; : R30 30 ; : R31 31 ; : XL R26 ; : XH R27 ;
: YL R28 ; : YH R29 ; : ZL R30 ; : ZH R31 ;
( ----- 045 )
( ATmega328P definitions ) : > CONSTANT ;
0xc6 > UDR0 0xc4 > UBRR0L 0xc5 > UBRR0H 0xc2 > UCSR0C
0xc1 > UCSR0B 0xc0 > UCSR0A 0xbd > TWAMR 0xbc > TWCR
0xbb > TWDR 0xba > TWAR 0xb9 > TWSR 0xb8 > TWBR 0xb6 > ASSR
0xb4 > OCR2B 0xb3 > OCR2A 0xb2 > TCNT2 0xb1 > TCCR2B
0xb0 > TCCR2A 0x8a > OCR1BL 0x8b > OCR1BH 0x88 > OCR1AL
0x89 > OCR1AH 0x86 > ICR1L 0x87 > ICR1H 0x84 > TCNT1L
0x85 > TCNT1H 0x82 > TCCR1C 0x81 > TCCR1B 0x80 > TCCR1A
0x7f > DIDR1 0x7e > DIDR0 0x7c > ADMUX 0x7b > ADCSRB
0x7a > ADCSRA 0x79 > ADCH 0x78 > ADCL 0x70 > TIMSK2
0x6f > TIMSK1 0x6e > TIMSK0 0x6c > PCMSK1 0x6d > PCMSK2
0x6b > PCMSK0 0x69 > EICRA 0x68 > PCICR 0x66 > OSCCAL
0x64 > PRR 0x61 > CLKPR 0x60 > WDTCSR 0x3f > SREG 0x3d > SPL
0x3e > SPH 0x37 > SPMCSR 0x35 > MCUCR 0x34 > MCUSR 0x33 > SMCR
0x30 > ACSR 0x2e > SPDR 0x2d > SPSR 0x2c > SPCR 0x2b > GPIOR2
0x2a > GPIOR1 0x28 > OCR0B 0x27 > OCR0A 0x26 > TCNT0  ( cont. )
( ----- 046 )
( cont. ) 0x25 > TCCR0B 0x24 > TCCR0A 0x23 > GTCCR
0x22 > EEARH 0x21 > EEARL 0x20 > EEDR 0x1f > EECR
0x1e > GPIOR0 0x1d > EIMSK 0x1c > EIFR 0x1b > PCIFR
0x17 > TIFR2 0x16 > TIFR1 0x15 > TIFR0 0x0b > PORTD 0x0a > DDRD
0x09 > PIND 0x08 > PORTC 0x07 > DDRC 0x06 > PINC 0x05 > PORTB
0x04 > DDRB 0x03 > PINB
( ----- 050 )
( 6809 assembler )
-48 LOAD+ ( common words ) 1 BIGEND? C!
( for TRF/EXG ) : D 0 ; : X 1 ; : Y 2 ; : U 3 ; : S 4 ;
: PCR 5 ; : A 8 ; : B 9 ; : CCR 10 ; : DPR 11 ;
( Addressing modes. output: n3? n2? n1 nc opoff )
: # ( n ) 1 0 ; ( Immediate )
: <> ( n ) 1 0x10 ; ( Direct )
: () ( n ) |T 2 0x30 ; ( Extended )
: [] ( n ) |T 0b10011111 3 0x20 ; ( Extended Indirect)
( Offset Indexed. We auto-detect 0, 5-bit, 8-bit, 16-bit )
: _0? ?DUP IF 1 ELSE 0x84 1 0 THEN ;
: _5? DUP 0x10 + 0x1f > IF 1 ELSE 0x1f AND 1 0 THEN ;
: _8? DUP 0x80 + 0xff > IF 1 ELSE 0xff AND 0x88 2 0 THEN ;
: _16 |T 0x89 3 ;
1 9 LOADR+
( ----- 051 )
: R+N CREATE C, DOES> C@@ ( roff ) >R
    _0? IF _5? IF _8? IF _16 THEN THEN THEN
    SWAP R> ( roff ) OR SWAP 0x20 ;
: R+K CREATE C, DOES> C@@ 1 0x20 ;
: PCR+N ( n ) _8? IF _16 THEN SWAP 0x8c OR SWAP 0x20 ;
: [R+N] CREATE C, DOES> C@@ 0x10 OR ( roff ) >R
    _0? IF _8? IF _16 THEN THEN SWAP R> OR SWAP 0x20 ;
: [PCR+N] ( n ) _8? IF _16 THEN SWAP 0x9c OR SWAP 0x20 ;
0 R+N X+N   0x20 R+N Y+N  0x40 R+N U+N   0x60 R+N S+N
: X+0 0 X+N ; : Y+0 0 Y+N ; : S+0 0 S+N ; : U+0 0 S+N ;
0 [R+N] [X+N] 0x20 [R+N] [Y+N]
0x40 [R+N] [U+N] 0x60 [R+N] [S+N]
: [X+0] 0 [X+N] ; : [Y+0] 0 [Y+N] ;
: [S+0] 0 [S+N] ; : [U+0] 0 [U+N] ;
( ----- 052 )
0x86 R+K X+A   0x85 R+K X+B   0x8b R+K X+D
0xa6 R+K Y+A   0xa5 R+K Y+B   0xab R+K Y+D
0xc6 R+K U+A   0xc5 R+K U+B   0xcb R+K U+D
0xe6 R+K S+A   0xe5 R+K S+B   0xeb R+K S+D
0x96 R+K [X+A] 0x95 R+K [X+B] 0x9b R+K [X+D]
0xb6 R+K [Y+A] 0xb5 R+K [Y+B] 0xbb R+K [Y+D]
0xd6 R+K [U+A] 0xd5 R+K [U+B] 0xdb R+K [U+D]
0xf6 R+K [S+A] 0xf5 R+K [S+B] 0xfb R+K [S+D]
0x80 R+K X+  0x81 R+K X++  0x82 R+K -X  0x83 R+K --X
0xa0 R+K Y+  0xa1 R+K Y++  0xa2 R+K -Y  0xa3 R+K --Y
0xc0 R+K U+  0xc1 R+K U++  0xc2 R+K -U  0xc3 R+K --U
0xe0 R+K S+  0xe1 R+K S++  0xe2 R+K -S  0xe3 R+K --S
0x91 R+K [X++] 0x93 R+K [--X] 0xb1 R+K [Y++] 0xb3 R+K [--Y]
0xd1 R+K [U++] 0xd3 R+K [--U] 0xf1 R+K [S++] 0xf3 R+K [--S]
( ----- 053 )
: ,? DUP 0xff > IF T, ELSE C, THEN ;
: ,N ( cnt ) 0 DO C, LOOP ;
: OPINH ( inherent ) CREATE , DOES> @@ ,? ;
( Targets A or B )
: OP1 CREATE , DOES> @@ ( n2? n1 nc opoff op ) + ,? ,N ;
( Targets D/X/Y/S/U. Same as OP1, but spit 2b immediate )
: OP2 CREATE , DOES> @@ OVER + ,? IF ,N ELSE DROP T, THEN ;
( Targets memory only. opoff scheme is different than OP1/2 )
: OPMT CREATE , DOES> @@
    SWAP 0x10 - ?DUP IF 0x50 + + THEN ,? ,N ;
( Targets 2 regs )
: OPRR ( src tgt -- ) CREATE C, DOES> C@@ C, SWAP <<4 OR C, ;
' OPINH :* OPBR
CREATE wbr 0 C, ( wide BR? ) : wbr? wbr C@@ 0 wbr C! ;
: OPLBR CREATE , DOES> @@ ,? 1 wbr C! ;
( ----- 054 )
0x89 OP1 ADCA,        0xc9 OP1 ADCB,
0x8b OP1 ADDA,        0xcb OP1 ADDB,      0xc3 OP2 ADDD,
0x84 OP1 ANDA,        0xc4 OP1 ANDB,      0x1c OP1 ANDCC,
0x48 OPINH ASLA,      0x58 OPINH ASLB,    0x08 OPMT ASL,
0x47 OPINH ASRA,      0x57 OPINH ASRB,    0x07 OPMT ASR,
0x4f OPINH CLRA,      0x5f OPINH CLRB,    0x0f OPMT CLR,
0x81 OP1 CMPA,        0xc1 OP1 CMPB,      0x1083 OP2 CMPD,
0x118c OP2 CMPS,      0x1183 OP2 CMPU,    0x8c OP2 CMPX,
0x108c OP2 CMPY,
0x43 OPINH COMA,      0x53 OPINH COMB,    0x03 OPMT COM,
0x3c OP1 CWAI         0x19 OPINH DAA,
0x4a OPINH DECA,      0x5a OPINH DECB,    0x0a OPMT DEC,
0x88 OP1 EORA,        0xc8 OP1 EORB,      0x1e OPRR EXG,
0x4c OPINH INCA,      0x5c OPINH INCB,    0x0c OPMT INC,
0x0e OPMT JMP,        0x8d OP1 JSR,
( ----- 055 )
0x86 OP1 LDA,         0xc6 OP1 LDB,       0xcc OP2 LDD,
0x10ce OP2 LDS,       0xce OP2 LDU,       0x8e OP2 LDX,
0x108e OP2 LDY,
0x12 OP1 LEAS,        0x13 OP1 LEAU,      0x10 OP1 LEAX,
0x11 OP1 LEAY,
0x48 OPINH LSLA,      0x58 OPINH LSLB,    0x08 OPMT LSL,
0x44 OPINH LSRA,      0x54 OPINH LSRB,    0x04 OPMT LSR,
0x3d OPINH MUL,
0x40 OPINH NEGA,      0x50 OPINH NEGB,    0x00 OPMT NEG,
0x12 OPINH NOP,
0x8a OP1 ORA,         0xca OP1 ORB,       0x1a OP1 ORCC,
0x49 OPINH ROLA,      0x59 OPINH ROLB,    0x09 OPMT ROL,
0x46 OPINH RORA,      0x56 OPINH RORB,    0x06 OPMT ROR,
0x3b OPINH RTI,       0x39 OPINH RTS,
0x82 OP1 SBCA,        0xc2 OP1 SBCB,
0x1d OPINH SEX,
( ----- 056 )
0x87 OP1 STA,         0xc7 OP1 STB,       0xcd OP2 STD,
0x10cf OP2 STS,       0xcf OP2 STU,       0x8f OP2 STX,
0x108f OP2 STY,
0x80 OP1 SUBA,        0xc0 OP1 SUBB,      0x83 OP2 SUBD,
0x3f OPINH SWI,       0x103f OPINH SWI2,  0x113f OPINH SWI3,
0x13 OPINH SYNC,      0x1f OPRR TFR,
0x4d OPINH TSTA,      0x5d OPINH TSTB,    0x0d OPMT TST,

0x24 OPBR BCC,        0x1024 OPLBR LBCC,  0x25 OPBR BCS,
0x1025 OPLBR LBCS,    0x27 OPBR BEQ,      0x1027 OPLBR LBEQ,
0x2c OPBR BGE,        0x102c OPLBR LBGE,  0x2e OPBR BGT,
0x102e OPLBR LBGT,    0x22 OPBR BHI,      0x1022 OPLBR LBHI,
0x24 OPBR BHS,        0x1024 OPLBR LBHS,  0x2f OPBR BLE,
0x102f OPLBR LBLE,    0x25 OPBR BLO,      0x1025 OPLBR LBLO,
0x23 OPBR BLS,        0x1023 OPLBR LBLS,  0x2d OPBR BLT,
0x102d OPLBR LBLT,    0x2b OPBR BMI,      0x102b OPLBR LBMI,
( ----- 057 )
0x26 OPBR BNE,        0x1026 OPLBR LBNE,  0x2a OPBR BPL,
0x102a OPLBR LBPL,    0x20 OPBR BRA,      0x16 OPLBR LBRA,
0x21 OPBR BRN,        0x1021 OPLBR BRN,   0x8d OPBR BSR,
0x17 OPLBR LBSR,      0x28 OPBR BVC,      0x1028 OPLBR LBVC,
0x29 OPBR BVS,        0x1029 OPLBR LBVS,

: _ ( r c cref mask -- r c ) ROT> OVER = ( r mask c f )
    IF ROT> OR SWAP ELSE NIP THEN ;
: OPP CREATE C, DOES> C@@ C, 0 TOWORD BEGIN ( r c )
    '$' 0x80 _ 'S' 0x40 _ 'U' 0x40 _ 'Y' 0x20 _ 'X' 0x10 _
    '%' 0x08 _ 'B' 0x04 _ 'A' 0x02 _ 'C' 0x01 _ 'D' 0x06 _
    '@@' 0xff _ DROP C< DUP WS? UNTIL DROP C, ;
0x34 OPP PSHS, 0x36 OPP PSHU, 0x35 OPP PULS, 0x37 OPP PULU,
( ----- 058 )
: BEGIN, ( -- a ) HERE ;
: BSET ( lbl -- ) BEGIN, SWAP ! ;
: LPC ( lbl -- ) @@ ORG @@ - BIN( @@ + ;
: AGAIN, ( a -- ) HERE - 1- wbr? IF 1- T, ELSE _bchk C, THEN ;
: BBR, ( lbl -- ) @@ AGAIN, ;
( same as BSET, but we need to write a placeholder. we need to
  remember wbr? value so we put it in the placeholder. )
: FBR, ( -- a ) BEGIN, wbr? DUP C, IF 0 C, THEN ;
: IFWORD ( -- a ) CREATE , DOES> @@ EXECUTE FBR, ;
: THEN, ( a -- ) DUP HERE -^ 1- ( l off ) OVER C@@ ( l off wbr )
    IF 1- SWAP T! ELSE _bchk SWAP C! THEN ;
: ELSE, BRA, FBR, SWAP THEN, ;
: FSET @@ THEN, ;
: ;CODE LBRA, lblnext BBR, ;
( ----- 059 )

' BNE, IFWORD IFZ,   ' BEQ, IFWORD IFNZ,
' BCC, IFWORD IFCS,  ' BCS, IFWORD IFCC,
' IFZ, :* IF=,       ' IFNZ, :* IF!=,
' BHS, IFWORD IF<,   ' BHI, IFWORD IF<=,
' BLS, IFWORD IF>,   ' BLO, IFWORD IF>=,
( ----- 100 )
( Block editor. Load with "100 LOAD", see doc/ed.txt )
CREATE ACC 0 ,
: _LIST ." Block " DUP . NL> LIST ;
: L BLK> @@ _LIST ;
: B BLK> @@ 1- BLK@@ L ;
: N BLK> @@ 1+ BLK@@ L ;
1 6 LOADR+
( ----- 101 )
( Cursor position in buffer. EDPOS/64 is line number )
CREATE EDPOS 0 ,
CREATE IBUF 64 ALLOT0
CREATE FBUF 64 ALLOT0
: edpos@@ EDPOS @@ ;
: 'pos ( pos -- a, addr of pos in memory ) BLK( + ;
: 'edpos@@ edpos@@ 'pos ;
: _lpos ( ln -- a ) 64 * 'pos ;
: _pln ( ln -- )
    DUP _lpos DUP 64 + SWAP DO ( lno )
        I 'edpos@@ = IF '^' EMIT THEN
        I C@@ DUP SPC < IF DROP SPC THEN
        EMIT
    LOOP ( lno ) 1+ . ;
: _zbuf 64 0 FILL ; ( buf -- )
( ----- 102 )
: _type ( buf -- )
    C< DUP CR = IF 2DROP EXIT THEN SWAP DUP _zbuf ( c a )
    BEGIN ( c a ) C!+ C< TUCK 0x0d = UNTIL ( c a ) C! ;
( user-facing lines are 1-based )
: T 1- DUP 64 * EDPOS ! _pln ;
: P IBUF _type IBUF 'edpos@@ 64 MOVE BLK!! ;
: _mvln+ ( ln -- move ln 1 line down )
    DUP 14 > IF DROP EXIT THEN
    _lpos DUP 64 + 64 MOVE ;
: _mvln- ( ln -- move ln 1 line up )
    DUP 14 > IF DROP 15 _lpos _zbuf
    ELSE 1+ _lpos DUP 64 - 64 MOVE THEN ;
( ----- 103 )
: _U ( U without P, used in VE )
    15 edpos@@ 64 / - ?DUP IF
    0 DO
        14 I - _mvln+
    LOOP THEN ;
: U _U P ;
( ----- 104 )
: _F ( F without _type and _pln. used in VE )
    FBUF 'edpos@@ 1+ ( a1 a2 )
    BEGIN
        C@@+ ROT ( a2+1 c2 a1 ) C@@+ ROT ( a2+1 a1+1 c1 c2 )
        = NOT IF DROP FBUF THEN ( a2 a1 )
        TUCK C@@ CR = ( a1 a2 f1 )
        OVER BLK) = OR ( a1 a2 f1|f2 )
    UNTIL ( a1 a2 )
    DUP BLK) < IF BLK( - FBUF + -^ EDPOS ! ELSE DROP THEN ;
: F FBUF _type _F edpos@@ 64 / _pln ;
( ----- 105 )
: _blen ( buf -- length of str in buf )
    DUP BEGIN C@@+ SPC < UNTIL -^ 1- ;
: _rbufsz ( size of linebuf to the right of curpos )
    edpos@@ 64 MOD 63 -^ ;
: _lnfix ( --, ensure no ctl chars in line before EDPOS )
    edpos@@ DUP 0xffc0 AND 2DUP = IF 2DROP EXIT THEN DO
    I 'pos DUP C@@ SPC < IF SPC SWAP C! ELSE DROP THEN LOOP ;
: _i ( i without _pln and _type. used in VE )
    _rbufsz IBUF _blen 2DUP > IF
        _lnfix TUCK - ( ilen chars-to-move )
        >R 'edpos@@ 2DUP + ( ilen a a+ilen R:ctm )
        R> MOVE- ( ilen )
    ELSE DROP 1+ ( ilen becomes rbuffsize+1 ) THEN
    DUP IBUF 'edpos@@ ROT MOVE ( ilen ) EDPOS +! BLK!! ;
: i IBUF _type _i edpos@@ 64 / _pln ;
( ----- 106 )
: icpy ( n -- copy n chars from cursor to IBUF )
    IBUF _zbuf 'edpos@@ IBUF ( n a buf ) ROT MOVE ;
: _X ( n -- )
    DUP icpy 'edpos@@ 2DUP + ( n a1 a1+n )
    SWAP _rbufsz MOVE ( n )
    ( get to next line - n )
    DUP edpos@@ 0xffc0 AND 0x40 + -^ 'pos ( n a )
    SWAP 0 FILL BLK!! ;
: X _X edpos@@ 64 / _pln ;
: _E FBUF _blen _X ;
: E FBUF _blen X ;
: Y FBUF _blen icpy ;
( ----- 110 )
( Visual editor. Load with "110 LOAD", see doc/ed.txt )
-10 LOAD+ ( B100, block editor )
1 7 LOADR+
( ----- 111 )
CREATE CMD 2 C, '$' C, 0 C,
CREATE PREVPOS 0 , CREATE PREVBLK 0 , CREATE xoff 0 ,
: MIN ( n n - n ) 2DUP > IF SWAP THEN DROP ;
: MAX ( n n - n ) 2DUP < IF SWAP THEN DROP ;
: large? COLS 67 > ; : col- 67 COLS MIN -^ ;
: width large? IF 64 ELSE COLS THEN ;
: acc@@ ACC @@ 1 MAX ; : pos@@ ( x y -- ) edpos@@ 64 /MOD ;
: num ACC @@ SWAP _pdacc IF ACC ! ELSE DROP THEN ;
: nspcs ( n -- , spit n space ) 0 DO SPC> LOOP ;
: aty 0 SWAP AT-XY ;
: clrscr COLS LINES * 0 DO SPC I CELL! LOOP ;
: gutter ( ln n ) OVER + SWAP DO 67 I AT-XY '|' EMIT LOOP ;
: status 0 aty ." BLK" SPC> BLK> ? SPC> ACC ?
    SPC> pos@@ . ',' EMIT . xoff @@ IF '>' EMIT THEN SPC>
    BLKDTY @@ IF '*' EMIT THEN 4 nspcs ;
( ----- 112 )
: nums 17 1 DO 2 I + aty I . SPC> SPC> LOOP ;
: mode! ( c -- ) 4 col- CELL! ;
: @@emit C@@ SPC MAX 0x7f MIN EMIT ;
: rfshln ( ln -- )
        large? IF 3 ELSE 0 THEN OVER 3 + AT-XY ( ln )
        _lpos ( lineaddr ) xoff @@ + DUP width + SWAP
        DO I @@emit LOOP ;
: rfshln@@ pos@@ NIP rfshln ;
: contents 16 0 DO I rfshln LOOP large? IF 3 16 gutter THEN ;
: selblk BLK> @@ PREVBLK ! BLK@@ contents ;
: pos! ( newpos -- ) edpos@@ PREVPOS !
    DUP 0< IF DROP 0 THEN 1023 MIN EDPOS ! ;
: xoff? pos@@ DROP ( x )
    xoff @@ ?DUP IF < IF 0 xoff ! contents THEN ELSE
        width >= IF 64 COLS - xoff ! contents THEN THEN ;
( ----- 113 )
: setpos ( -- ) pos@@ 3 + ( header ) SWAP ( y x ) xoff @@ -
    large? IF 3 + ( gutter ) THEN SWAP AT-XY ;
: cmv ( n -- , char movement ) acc@@ * edpos@@ + pos! ;
: buftype ( buf ln -- )
    3 OVER AT-XY KEY DUP SPC < IF 2DROP DROP
    ELSE ( buf ln c ) KEY> 64 nspcs 3 SWAP AT-XY
    IN( _zbuf RDLN IN( SWAP 64 MOVE THEN ;
: bufp ( buf -- )
    DUP 3 col- + SWAP DO I @@emit LOOP ;
: bufs
    1 aty ." I: " IBUF bufp
    2 aty ." F: " FBUF bufp
    large? IF 0 3 gutter THEN ;
( ----- 114 )
: $G ACC @@ selblk ;
: $[ BLK> @@ acc@@ - selblk ;
: $] BLK> @@ acc@@ + selblk ;
: $t PREVBLK @@ selblk ;
: $I 'I' mode! IBUF 1 buftype _i bufs rfshln@@ SPC mode! ;
: $F 'F' mode! FBUF 2 buftype _F bufs setpos SPC mode! ;
: $Y Y bufs ; : $E _E bufs rfshln@@ ;
: $X acc@@ _X bufs rfshln@@ ;
: $h -1 cmv ; : $l 1 cmv ; : $k -64 cmv ; : $j 64 cmv ;
: $H edpos@@ 0x3c0 AND pos! ;
: $L edpos@@ DUP 0x3f OR 2DUP = IF 2DROP EXIT THEN SWAP BEGIN
    ( res p ) 1+ DUP 'pos C@@ WS? NOT IF NIP DUP 1+ SWAP THEN
    DUP 0x3f AND 0x3f = UNTIL DROP pos! ;
: $g ACC @@ 1 MAX 1- 64 * pos! ;
: $@@ BLK> @@ BLK@@* 0 BLKDTY ! contents ;
: $! BLK> @@ FLUSH BLK> ! ;
( ----- 115 )
: C@@- ( a -- a-1 c ) DUP C@@ SWAP 1- SWAP ;
0 :* C@@+-
: go>> ['] C@@+ ['] C@@+- *! ;
: go<< ['] C@@- ['] C@@+- *! ;
: word>> BEGIN C@@+- WS? UNTIL ;
: ws>> BEGIN C@@+- WS? NOT UNTIL ;
: bpos! BLK( - pos! ;
: $w go>> 'edpos@@ acc@@ 0 DO word>> ws>> LOOP 1- bpos! ;
: $W go>> 'edpos@@ acc@@ 0 DO 1+ ws>> word>> LOOP 2 - bpos! ;
: $b go<< 'edpos@@ acc@@ 0 DO 1- ws>> word>> LOOP 2 + bpos! ;
: $B go<< 'edpos@@ acc@@ 0 DO word>> ws>> LOOP 1+ bpos! ;
( ----- 116 )
: $f edpos@@ PREVPOS @@ 2DUP = IF 2DROP EXIT THEN
    2DUP > IF DUP pos! SWAP THEN
    ( p1 p2, p1 < p2 ) OVER - 64 MIN ( pos len ) FBUF _zbuf
    SWAP 'pos FBUF ( len src dst ) ROT MOVE bufs ;
: $R ( replace mode )
    'R' mode!
    BEGIN setpos KEY DUP BS? IF -1 EDPOS +! DROP 0 THEN
        DUP SPC >= IF
        DUP EMIT 'edpos@@ C! 1 EDPOS +! BLK!! 0
    THEN UNTIL SPC mode! ;
: $O _U edpos@@ 0x3c0 AND DUP pos! 'pos _zbuf BLK!! contents ;
: $o edpos@@ 0x3c0 < IF edpos@@ 64 + EDPOS ! $O THEN ;
: $D $H 64 icpy
    acc@@ 0 DO 16 edpos@@ 64 / DO I _mvln- LOOP LOOP
    BLK!! bufs contents ;
( ----- 117 )
: handle ( c -- f )
    DUP '0' '9' =><= IF num 0 EXIT THEN
    DUP CMD 2 + C! CMD FIND IF EXECUTE ELSE DROP THEN
    0 ACC ! 'q' = ;
: VE
    BLK> @@ 0< IF 0 BLK@@ THEN
    1 XYMODE C! clrscr 0 ACC ! 0 PREVPOS ! nums bufs contents
    BEGIN xoff? status setpos KEY handle UNTIL
    0 XYMODE C! 19 aty IN$ ;
( ----- 150 )
( Remote Shell. load range B150-B151 )
: _<< ( print everything available from RX<? )
    BEGIN RX<? IF EMIT ELSE EXIT THEN AGAIN ;
: _<<r ( _<< with retries )
    BEGIN _<< 100 TICKS RX<? IF EMIT ELSE EXIT THEN AGAIN ;
: RX< BEGIN RX<? UNTIL ;
: _<<1r RX< EMIT _<<r ;
: rsh BEGIN
    KEY? IF DUP EOT? IF DROP EXIT ELSE TX> THEN THEN
    _<< AGAIN ;
: rstype ( s --, like STYPE, but remote )
    C@@+ ( s len ) 0 DO C@@+ TX> _<<r LOOP DROP _<<r CR TX>
    RX< DROP _<<r ;
: rstypep ( like rstype, but read ok prompt )
    rstype BEGIN RX< WS? NOT UNTIL _<<1r ;
( ----- 151 )
: unpack DUP 0xf0 OR SWAP 0x0f OR ;
: out unpack TX> TX> ; : out2 |M out out ;
: rupload ( loca rema u -- )
    LIT" : in KEY 0xf0 AND KEY 0x0f AND OR ;" rstypep
    LIT" : in2 in 8 LSHIFT in OR ;" rstypep
    ( sig: chk --, a and then u are KEYed in )
    LIT" : _ in2 in2 OVER + SWAP DO " rstypep
    LIT" in DUP ROT + SWAP I C! LOOP ;" rstypep
    DUP ROT ( loca u u rema ) LIT" 0 _" rstype out2 out2
    OVER + SWAP 0 ROT> ( 0 loca+u loca )
    DO '.' EMIT I C@@ DUP ROT + SWAP out LOOP
    _<<1r LIT" .X FORGET in" rstypep .X ;
( ----- 152 )
( XMODEM routines )
: _<<s BEGIN RX<? IF DROP ELSE EXIT THEN AGAIN ;
: _rx>mem1 ( addr -- f, Receive single packet, f=eot )
  RX< 1 = NOT IF ( EOT ) 0x6 ( ACK ) TX> 1 EXIT THEN
  RX< DROP RX< DROP ( packet num )
  0 ( crc ) SWAP DUP 128 + SWAP DO ( crc ) '.' EMIT
    RX< DUP ( crc n n ) I C! ( crc n ) CRC16 LOOP
  RX< 8 LSHIFT RX< OR ( sender's CRC )
  = IF 0x6 ( ACK ) ELSE 0x15 ( NACK ) THEN TX> 0 ;
: RX>MEM ( addr --, Receive packets into addr until EOT )
  _<<s 'C' TX> BEGIN ( a )
  DUP _rx>mem1 SWAP 128 + SWAP UNTIL DROP ;
: RX>BLK ( -- )
  _<<s 'C' TX> BLK( BEGIN ( a )
  DUP BLK) = IF DROP BLK( BLK! 1 BLK> +! THEN
  DUP _rx>mem1 SWAP 128 + SWAP UNTIL 2DROP ;
( ----- 153 )
: _snd128 ( a -- a )
    0 ( a crc ) 128 0 DO ( a crc )
      OVER I + C@@ DUP TX> ( a crc n ) CRC16 ( a crc ) LOOP
    |M TX> TX> ( a ) ;
: _ack? 0 BEGIN DROP RX< DUP 'C' = NOT UNTIL
	DUP 0x06 ( ACK ) = IF DROP 1
    ELSE 0x15 = NOT IF ABORT" out of sync" THEN 0 THEN ;
: _waitC
  ." Waiting for C..." BEGIN RX<? IF 'C' = ELSE 0 THEN UNTIL ;
: _mem>tx ( addr pktstart pktend -- ) SWAP DO ( a )
    'P' EMIT I . SPC> 0x01 ( SOH ) TX>
    I 1+ ( pkt start at 1 ) DUP TX> 0xff -^ TX>
    _snd128 _ack? IF 128 + ( a+128 ) ELSE R> 1- >R THEN
  LOOP DROP ;
( ----- 154 )
: MEM>TX ( a u -- Send u bytes to TX )
  _waitC 128 /MOD SWAP IF 1+ THEN ( pktcnt ) 0 SWAP _mem>tx
  0x4 ( EOT ) TX> RX< DROP ;
: BLK>TX ( b1 b2 -- )
  _waitC OVER - ( cnt ) 0 DO ( b1 )
    'B' EMIT DUP I + DUP . SPC> BLK@@ BLK(
    I 8 * DUP 8 + ( a pktstart pktend ) _mem>tx
  LOOP DROP
  0x4 ( EOT ) TX> RX< DROP ;
( ----- 160 )
( AVR Programmer, load range 160-163. doc/avr.txt )
( page size in words, 64 is default on atmega328P )
CREATE aspfpgsz 64 ,
VARIABLE aspprevx
: _x ( a -- b ) DUP aspprevx ! (spix) ;
: _xc ( a -- b ) DUP (spix) ( a b )
    DUP aspprevx @@ = NOT IF ABORT" AVR err" THEN ( a b )
    SWAP aspprevx ! ( b ) ;
: _cmd ( b4 b3 b2 b1 -- r4 ) _xc DROP _xc DROP _xc DROP _x ;
: asprdy ( -- ) BEGIN 0 0 0 0xf0 _cmd 1 AND NOT UNTIL ;
: asp$ ( spidevid -- )
    ( RESET pulse ) DUP (spie) 0 (spie) (spie)
    ( wait >20ms ) 220 TICKS
    ( enable prog ) 0xac (spix) DROP
    0x53 _x DROP 0 _xc DROP 0 _x DROP ;
: asperase 0 0 0x80 0xac _cmd asprdy ;
( ----- 161 )
( fuse access. read/write one byte at a time )
: aspfl@@ ( -- lfuse ) 0 0 0 0x50 _cmd ;
: aspfh@@ ( -- hfuse ) 0 0 0x08 0x58 _cmd ;
: aspfe@@ ( -- efuse ) 0 0 0x00 0x58 _cmd ;
: aspfl! ( lfuse -- ) 0 0xa0 0xac _cmd ;
: aspfh! ( hfuse -- ) 0 0xa8 0xac _cmd ;
: aspfe! ( efuse -- ) 0 0xa4 0xac _cmd ;
( ----- 162 )
: aspfb! ( n a --, write word n to flash buffer addr a )
    SWAP |L ( a hi lo ) ROT ( hi lo a )
    DUP ROT ( hi a a lo ) SWAP ( hi a lo a )
    0 0x40 ( hi a lo a 0 0x40 ) _cmd DROP ( hi a )
    0 0x48 _cmd DROP ;
: aspfp! ( page --, write buffer to page )
    0 SWAP aspfpgsz @@ * |M ( 0 lsb msb )
    0x4c _cmd DROP asprdy ;
: aspf@@ ( page a -- n, read word from flash )
    SWAP aspfpgsz @@ * OR ( addr ) |M ( lsb msb )
    2DUP 0 ROT> ( lsb msb 0 lsb msb )
    0x20 _cmd ( lsb msb low )
    ROT> 0 ROT> ( low 0 lsb msb ) 0x28 _cmd 8 LSHIFT OR ;
( ----- 163 )
: aspe@@ ( addr -- byte, read from EEPROM )
    0 SWAP |L ( 0 msb lsb )
    0xa0 ( 0 msb lsb 0xa0 ) _cmd ;
: aspe! ( byte addr --, write to EEPROM )
    |L ( b msb lsb )
    0xc0 ( b msb lsb 0xc0 ) _cmd DROP asprdy ;
( ----- 165 )
( Sega ROM signer. See doc/sega.txt )
: C!+^ ( a c -- a+1 ) OVER C! 1+ ;
: segasig ( addr size -- )
    0x2000 OVER LSHIFT ( a sz bytesz )
    ROT TUCK + 0x10 - ( sz a end )
    TUCK SWAP 0 ROT> ( sz end sum end a ) DO ( sz end sum )
        I C@@ + LOOP ( sz end sum ) SWAP ( sz sum end )
    'T' C!+^ 'M' C!+^ 'R' C!+^ SPC C!+^ 'S' C!+^
    'E' C!+^ 'G' C!+^ 'A' C!+^ 0 C!+^ 0 C!+^
    ( sum's LSB ) OVER C!+^ ( MSB ) SWAP 8 RSHIFT OVER C! 1+
    ( sz end ) 0 C!+^ 0 C!+^ 0 C!+^ SWAP 0x4a + SWAP C! ;
( ----- 200 )
( Cross compilation program. See doc/cross.txt.
  Load range: B200-B205 )
CREATE XCURRENT 0 ,
CREATE (n)* 0 , CREATE (b)* 0 , CREATE 2>R* 0 ,
CREATE (loop)* 0 , CREATE (br)* 0 , CREATE (?br)* 0 ,
CREATE (s)* 0 , CREATE !* 0 , CREATE EXIT* 0 ,
: (xentry) WORD C@@+ TUCK MOVE, HERE XCURRENT @@ - T,
    C, HERE XCURRENT ! ;
: XIMM XCURRENT @@ 1- DUP C@@ 0x80 OR SWAP C! ;
: XCREATE (xentry) 2 C, ;
: XCONSTANT (xentry) 6 C, T, ;
: _xapply ( a -- a-off )
    DUP ORG @@ > IF ORG @@ - BIN( @@ + THEN ;
: X:* (xentry) 4 C, _xapply T, ; : X:** (xentry) 5 C, T, ;
( ----- 201 )
: W= ( s w -- f ) OVER C@@ OVER 1- C@@ 0x7f AND = IF ( same len )
    ( s w ) SWAP C@@+ ( w s+1 len ) ROT OVER - 3 -
    ( s+1 len w-3-len ) ROT> []=
    ELSE 2DROP 0 THEN ;
: _xfind ( s -- w f ) XCURRENT @@ BEGIN ( s w )
    2DUP W= IF NIP ( w ) 1 EXIT THEN
    3 - ( prev field ) DUP T@@ ?DUP NOT IF DROP 0 EXIT THEN
    ( a - prev ) - AGAIN ( s w ) ;
: XFIND ( s -- w ) _xfind NOT IF (wnf) THEN _xapply ;
: X'? WORD _xfind _xapply ; : X' X'? NOT IF (wnf) THEN ;
( ----- 202 )
: _codecheck ( lbl str -- )
    XCURRENT @@ W=
    IF XCURRENT @@ _xapply SWAP ! ELSE DROP THEN ;
: CODE (xentry) 0 ( native ) C,
    EXIT* LIT" EXIT" _codecheck
    (b)* LIT" (b)" _codecheck
    (n)* LIT" (n)" _codecheck
    (s)* LIT" (s)" _codecheck
    !* LIT" !" _codecheck
    2>R* LIT" 2>R" _codecheck
    (loop)* LIT" (loop)" _codecheck
    (br)* LIT" (br)" _codecheck
    (?br)* LIT" (?br)" _codecheck ;
: XWRAP" W" _" (xentry) PC ORG @@ 8 ( LATEST ) + T! ," EOT, ;
( ----- 203 )
: XLITN DUP 0xff > IF (n)* @@ T, T, ELSE (b)* @@ T, C, THEN ;
: X['] WORD XFIND XLITN ;
: XCOMPILE X['] LIT" ," XFIND T, ;
: X[COMPILE] WORD XFIND T, ; : XDO 2>R* @@ T, HERE ;
: XLOOP (loop)* @@ T, HERE - C, ;
: XIF (?br)* @@ T, HERE 1 ALLOT ;
: XELSE (br)* @@ T, 1 ALLOT [COMPILE] THEN HERE 1- ;
: XAGAIN (br)* @@ T, HERE - C, ;
: XUNTIL (?br)* @@ T, HERE - C, ;
: XLIT" (s)* @@ T, HERE 0 C, ," DUP HERE -^ 1- SWAP C! ;
: XW" XLIT" SYSVARS 0x32 + XLITN !* @@ T, ;
( ----- 204 )
: X:
  (xentry) 1 ( compiled ) C, BEGIN
    WORD DUP LIT" ;" S= IF DROP EXIT* @@ T, EXIT THEN
    _xfind IF ( a )
      DUP 1- C@@ 0x80 AND IF ABORT" immed!" THEN _xapply T,
    ELSE ( w ) FIND ( a f ) IF
      DUP 1- C@@ 0x80 AND IF EXECUTE ELSE ABORT THEN
      ELSE (parse) XLITN THEN
  THEN AGAIN ;
( ----- 205 )
: '? X'? ;
: ['] X['] ; IMMEDIATE
: COMPILE XCOMPILE ; IMMEDIATE
: [COMPILE] X[COMPILE] ; IMMEDIATE
: DO XDO ; IMMEDIATE : LOOP XLOOP ; IMMEDIATE
: IF XIF ; IMMEDIATE : ELSE XELSE ; IMMEDIATE
: AGAIN XAGAIN ; IMMEDIATE : UNTIL XUNTIL ; IMMEDIATE
: LIT" XLIT" ; IMMEDIATE : W" XW" ; IMMEDIATE
: LITN XLITN ;
: IMMEDIATE XIMM ;
: (entry) (xentry) ; : CREATE XCREATE ;
: CONSTANT XCONSTANT ;
: :* X:* ; : :** X:** ;
: : [ ' X: , ] ;
CURRENT @@ XCURRENT !
( ----- 210 )
( Core Forth words. See doc/cross.txt.
  Load range low: B210-B231 high: B236-B239 )
: RAM+ [ SYSVARS LITN ] + ; : BIN+ [ BIN( @@ LITN ] + ;
SYSVARS 0x02 + CONSTANT CURRENT
SYSVARS 0x04 + CONSTANT H
SYSVARS 0x0c + CONSTANT C<*
SYSVARS 0x41 + CONSTANT IOERR
: HERE H @@ ;
( ----- 211 )
: 0< 32767 > ; : >= < NOT ; : <= > NOT ;
: =><= ( n l h -- f ) OVER - ROT> ( h n l ) - >= ;
: NIP SWAP DROP ; : TUCK SWAP OVER ;
: -^ SWAP - ;
: C@@+ ( a -- a+1 c ) DUP C@@ SWAP 1+ SWAP ;
: C!+ ( c a -- a+1 ) TUCK C! 1+ ;
: LEAVE R> R> DROP I 1- >R >R ; : UNLOOP R> 2R> 2DROP >R ;
( ----- 212 )
: +! TUCK @@ + SWAP ! ;
: *! ( addr alias -- ) 1+ ! ;
: **! ( addr ialias -- ) 1+ @@ ! ;
: / /MOD NIP ;
: MOD /MOD DROP ;
: ALLOT H +! ;
: FILL ( a n b -- )
    ROT> OVER ( b a n a ) + SWAP ( b a+n a ) DO ( b )
        DUP I C! LOOP DROP ;
: ALLOT0 ( n -- ) HERE OVER 0 FILL ALLOT ;
( ----- 213 )
SYSVARS 0x53 + :** EMIT
: STYPE C@@+ ( a len ) 0 DO C@@+ EMIT LOOP DROP ;
: EOT 0x4 ; : BS 0x8 ; : LF 0xa ; : CR 0xd ; : SPC 0x20 ;
: SPC> SPC EMIT ;
: NL> 0x50 RAM+ C@@ ?DUP IF EMIT ELSE CR EMIT LF EMIT THEN ;
: EOT? EOT = ;
: ERR STYPE ABORT ;
: (uflw) LIT" stack underflow" ERR ;
XCURRENT @@ _xapply ORG @@ 0x06 ( stable ABI uflw ) + T!
: (oflw) LIT" stack overflow" ERR ;
XCURRENT @@ _xapply ORG @@ 0x13 ( stable ABI oflw ) + T!
: (wnf) STYPE LIT"  word not found" ERR ;
( ----- 214 )
: . ( n -- )
    ?DUP NOT IF '0' EMIT EXIT THEN ( 0 is a special case )
    DUP 0< IF '-' EMIT -1 * THEN
    0xff SWAP ( stop indicator ) BEGIN
        10 /MOD ( r q ) SWAP '0' + SWAP ( d q ) ?DUP NOT UNTIL
    BEGIN EMIT DUP '9' > UNTIL DROP ;
: ? @@ . ;
: _ DUP 9 > IF 10 - 'a' + ELSE '0' + THEN ;
( For hex display, there are no negatives )
: .x 0xff AND 16 /MOD ( l h ) _ EMIT _ EMIT ;
: .X |M .x .x ;
( ----- 215 )
( Parse digit c and accumulate into result r.
  Flag f is true when c was a valid digit )
: _pdacc ( r c -- r f )
    '0' - DUP 10 < IF ( good, add to running result )
        SWAP 10 * + 1 ( r*10+n f )
        ELSE ( bad ) DROP 0 THEN ;
: _pd ( s -- n f, parse decimal )
    C@@+ OVER C@@ 0 ( a len firstchar startat )
( if we have '-', we only advance. more processing later. )
    SWAP '-' = IF 1+ THEN ( a len startat )
    0 ROT> ( len ) ( startat ) DO ( a r )
        OVER I + C@@ ( a r c ) _pdacc ( a r f )
        NOT IF DROP 1- 0 UNLOOP EXIT THEN LOOP ( a r )
( if we had '-', we need to invert result. )
    SWAP C@@ '-' = IF 0 -^ THEN 1 ( r 1 ) ;
( ----- 216 )
: _pref ( s p -- s len-or-0 )
  1+ OVER 1+ 2 []= NOT IF 0 EXIT THEN ( s )
  DUP C@@ DUP 3 < IF DROP 0 EXIT THEN ;
: _ph ( s -- n f, parse hex )
  LIT" 0x" _pref DUP IF ( s len )
    0 SWAP 1+ ( len+1 ) 3 DO ( s r )
      4 LSHIFT ( s r*16 ) OVER I + C@@ ( s r c )
      '0' - DUP 9 > IF 0x31 ( 'a'-'0' ) - DUP 6 < IF
      10 + ELSE 2DROP 0 UNLOOP EXIT THEN THEN ( s r n )
      + ( s r+n ) LOOP NIP 1 THEN ;
( ----- 217 )
: _pb ( s -- n f, parse binary )
  LIT" 0b" _pref DUP IF ( s len )
    0 SWAP 1+ ( len+1 ) 3 DO ( s r )
      1 LSHIFT ( s r*2 ) OVER I + C@@ ( s r c )
      '0' - DUP 1 > IF 2DROP 0 UNLOOP EXIT THEN ( s r n )
      + ( s r+n ) LOOP NIP 1 THEN ;
: _pc ( a -- n f, parse character )
	DUP C@@+ 3 = IF ( a a+1 ) C@@+ ''' = IF ( a a+2 )
        DUP 1+ C@@ ''' = IF C@@ NIP 1 EXIT THEN THEN THEN
	DROP 0 ;
: (parse) ( a -- n )
    _pc IF EXIT THEN _ph IF EXIT THEN
    _pb IF EXIT THEN _pd IF EXIT THEN (wnf) ;
( ----- 218 )
SYSVARS 0x55 + :** KEY?
: KEY> [ SYSVARS 0x51 + LITN ] C! ;
: KEY [ SYSVARS 0x51 + LITN ] C@@ ?DUP IF 0 KEY>
    ELSE BEGIN KEY? UNTIL THEN ;
: BS? DUP 0x7f ( DEL ) = SWAP BS = OR ;
SYSVARS 0x30 + CONSTANT IN> ( current position in INBUF )
SYSVARS 0x60 + CONSTANT IN( ( points to INBUF )
: IN$ 0 IN( DUP IN> ! ! ; ( flush input buffer )
( ----- 219 )
: RDLN ( Read 1 line in input buff and make IN> point to it )
  IN$ BEGIN
  ( buffer overflow? same as if we typed a newline )
  IN> @@ IN( - 0x3e = IF CR ELSE KEY THEN ( c )
  DUP BS? IF
    IN> @@ IN( > IF -1 IN> +! BS EMIT THEN SPC> BS EMIT
  ELSE DUP LF = IF DROP CR THEN ( same as CR )
    DUP SPC >= IF DUP EMIT ( echo back ) THEN
    DUP IN> @@ C!+ IN> ! THEN ( c )
  DUP CR = SWAP EOT? OR UNTIL 0 IN> @@ C! IN( IN> ! ;
: RDLN<
  IN> @@ C@@ ( c )
  DUP IF ( not EOL? good, inc and return ) 1 IN> +!
  ELSE ( EOL ? readline. we still return null though )
    SPC> LIT" ok" STYPE NL> RDLN NL>
  THEN ( c ) ;
( ----- 220 )
: C< C<* @@ ?DUP NOT IF RDLN< ELSE EXECUTE THEN ;
: , HERE ! 2 ALLOT ;
: C, HERE C! 1 ALLOT ;
: ,"
    BEGIN
        C< DUP 34 ( ASCII " ) = IF DROP EXIT THEN C,
    AGAIN ;
: EOT, EOT C, ;
: WS? SPC <= ;

: TOWORD ( -- c, c being the first letter of the word )
    0 ( dummy ) BEGIN
        DROP C< DUP WS? NOT OVER EOT? OR UNTIL ;
( ----- 221 )
( Read word from C<, copy to WORDBUF, null-terminate, and
  return WORDBUF. )
SYSVARS 0x0e + CONSTANT _wb
: _eot EOT 1 _wb C!+ C! _wb ;
: WORD ( -- a )
    [ SYSVARS 0x32 + ( WORD LIT ) LITN ] @@ ?DUP IF
        0 [ SYSVARS 0x32 + LITN ] ! EXIT THEN
    _wb 1+ TOWORD ( a c )
    DUP EOT? IF 2DROP _eot EXIT THEN
    BEGIN
        OVER C! 1+ C< ( a c )
        OVER 0x2e RAM+ = OVER WS? OR UNTIL ( a c )
    SWAP _wb - 1- ( ws len ) _wb C!
    EOT? IF _eot ELSE _wb THEN ;
: IMMEDIATE CURRENT @@ 1- DUP C@@ 128 OR SWAP C! ;
( ----- 222 )
: MOVE ( a1 a2 u -- )
    ?DUP IF ( u ) 0 DO ( a1 a2 )
        OVER I + C@@ ( src dst x )
        OVER I + ( src dst x dst )
        C! ( src dst )
    LOOP THEN 2DROP ;
: MOVE- ( a1 a2 u -- )
    ?DUP IF ( u ) 0 DO ( a1 a2 )
        OVER I' + I - 1- C@@ ( src dst x )
        OVER I' + I - 1- ( src dst x dst )
        C! ( src dst )
    LOOP THEN 2DROP ;
: MOVE, ( a u -- ) HERE OVER ALLOT SWAP MOVE ;
( ----- 223 )
: (entry) WORD
    C@@+ ( w+1 len ) TUCK MOVE, ( len )
    ( write prev value )
    HERE CURRENT @@ - ,
    C, ( write size )
    HERE CURRENT ! ;
: CREATE (entry) 2 ( cellWord ) C, ;
: VARIABLE CREATE 2 ALLOT ;
: :* ( addr -- ) (entry) 4 ( alias ) C, , ;
: :** ( addr -- ) (entry) 5 ( ialias ) C, , ;
( ----- 224 )
: '? WORD FIND ;
: ' '? NOT IF (wnf) THEN ;
: FORGET
    ' DUP ( w w )
    ( HERE must be at the end of prev's word, that is, at the
      beginning of w. )
    DUP 1- C@@ ( name len field )
    0x7f AND  ( remove IMMEDIATE flag )
    3 +       ( fixed header len )
    - H !     ( w )
    ( get prev addr ) 3 - DUP @@ - CURRENT ! ;
: EMPTY LIT" _sys" FIND IF DUP H ! CURRENT ! THEN ;
( ----- 225 )
: DOES> CURRENT @@ ( cur )
    3 ( does ) OVER C! ( make CURRENT into a DOES )
    1+ DUP ( pfa pfa )
    ( move PFA by 2 ) HERE OVER - ( pfa pfa u )
    OVER 2 + SWAP MOVE- 2 ALLOT
    ( Write DOES> pointer ) R> SWAP ( does-addr pfa ) !
    ( Because we've popped RS, we'll exit parent definition ) ;
: CONSTANT (entry) 6 ( constant ) C, , ;
: S= ( s1 s2 -- f ) C@@+ ( s1 s2 l2 ) ROT C@@+ ( s2 l2 s1 l1 )
    ROT OVER = IF ( same len, s2 s1 l ) []=
    ELSE DROP 2DROP 0 THEN ;
: [IF] IF EXIT THEN LIT" [THEN]" BEGIN DUP WORD S= UNTIL DROP ;
: [THEN] ;
( ----- 226 )
( n -- Fetches block n and write it to BLK( )
SYSVARS 0x34 + :** BLK@@*
( n -- Write back BLK( to storage at block n )
SYSVARS 0x36 + :** BLK!*
( Current blk pointer -1 means "invalid" )
SYSVARS 0x38 + CONSTANT BLK>
( Whether buffer is dirty )
SYSVARS 0x3a + CONSTANT BLKDTY
: BLK( 0x3c RAM+ @@ ;
: BLK) BLK( 1024 + ;
: BLK$
    HERE 0x3c ( BLK(* ) RAM+ !
    1024 ALLOT
    ( LOAD detects end of block with ASCII EOT. This is why
      we write it there. )
    EOT, 0 BLKDTY ! -1 BLK> ! ;
( ----- 227 )
: BLK! ( -- ) BLK> @@ BLK!* 0 BLKDTY ! ;
: FLUSH BLKDTY @@ IF BLK! THEN -1 BLK> ! ;
: BLK@@ ( n -- )
    DUP BLK> @@ = IF DROP EXIT THEN
    FLUSH DUP BLK> ! BLK@@* ;
: BLK!! 1 BLKDTY ! ;
: WIPE BLK( 1024 0 FILL BLK!! ;
: COPY ( src dst -- )
    FLUSH SWAP BLK@@ BLK> ! BLK! ;
( ----- 228 )
: _ ( a -- a+8 )
    DUP ( a a )
    ':' EMIT DUP .x SPC>
    4 0 DO DUP @@ |L .x .x SPC> 2 + LOOP
    DROP ( a )
    8 0 DO
        C@@+ DUP SPC 0x7e =><= NOT IF DROP '.' THEN EMIT
    LOOP NL> ;
: DUMP ( n a -- )
    SWAP 8 /MOD SWAP IF 1+ THEN
    0 DO _ LOOP DROP ;
( ----- 229 )
: LIST
    BLK@@
    16 0 DO
        I 1+ DUP 10 < IF SPC> THEN . SPC>
        64 I * BLK( + DUP 64 + SWAP DO
            I C@@ DUP 0x1f > IF EMIT ELSE DROP LEAVE THEN
        LOOP
        NL>
    LOOP ;
( ----- 230 )
: INTERPRET BEGIN
    WORD DUP 1+ C@@ EOT? IF DROP EXIT THEN
    FIND NOT IF (parse) ELSE EXECUTE THEN AGAIN ;
SYSVARS 0x2e + CONSTANT MEM<*
( Read char from MEM<* and inc it. )
: MEM<
    MEM<* @@ C@@+ ( a+1 c )
    SWAP MEM<* ! ( c ) ;
( ----- 231 )
: LOAD
( save restorable variables to RSP. to allow for nested LOADs,
  we save/restore BLKs, but only when C<* is 0, that is, then
  RDLN< is active. )
    C<* @@ IF BLK> @@ >R THEN
    C<* @@ >R MEM<* @@ >R
    BLK@@ BLK( MEM<* ! ( Point to beginning of BLK )
    ['] MEM< C<* !
    INTERPRET
    R> MEM<* ! R> C<* !
    C<* @@ IF R> BLK@@ THEN ;
: LOAD+ BLK> @@ + LOAD ;
( b1 b2 -- )
: LOADR 1+ SWAP DO I DUP . SPC> LOAD LOOP ;
: LOADR+ BLK> @@ + SWAP BLK> @@ + SWAP LOADR ;
( ----- 236 )
( Forth core high )
: (main) 0 C<* ! IN$ INTERPRET BYE ;
XCURRENT @@ _xapply ORG @@ 0x0a ( stable ABI (main) ) + T!
: BOOT
    CURRENT @@ MEM<* !
    0 IOERR C!
    0 [ SYSVARS 0x50 + LITN ] ! ( NL> + KEY> )
    0 [ SYSVARS 0x32 + LITN ] ! ( WORD LIT )
    ['] (emit) ['] EMIT **! ['] (key?) ['] KEY? **!
    ['] MEM< C<* !
    INTERPRET
    W" _sys" (entry)
    LIT" Collapse OS" STYPE (main) ;
XCURRENT @@ _xapply ORG @@ 0x04 ( stable ABI BOOT ) + T!
( ----- 237 )
( Now we have "as late as possible" stuff. See bootstrap doc. )
: _bchk DUP 0x7f + 0xff > IF LIT" br ovfl" STYPE ABORT THEN ;
: DO COMPILE 2>R HERE ; IMMEDIATE
: LOOP COMPILE (loop) HERE - _bchk C, ; IMMEDIATE
( LEAVE is implemented in low xcomp )
: LITN DUP 0xff > IF COMPILE (n) , ELSE COMPILE (b) C, THEN ;
: :
  (entry) 1 ( compiled ) C, BEGIN
      WORD DUP LIT" ;" S= IF DROP COMPILE EXIT EXIT THEN
      FIND IF ( is word )
      DUP 1- C@@ 0x80 AND ( imm? ) IF EXECUTE ELSE , THEN
      ELSE ( maybe number ) (parse) LITN THEN
  AGAIN ;
( ----- 238 )
: IF ( -- a | a: br cell addr )
    COMPILE (?br) HERE 1 ALLOT ( br cell allot ) ; IMMEDIATE
: THEN ( a -- | a: br cell addr )
    DUP HERE -^ _bchk SWAP ( a-H a ) C! ; IMMEDIATE
: ELSE ( a1 -- a2 | a1: IF cell a2: ELSE cell )
    COMPILE (br) 1 ALLOT [COMPILE] THEN
    HERE 1- ( push a. 1- for allot offset ) ; IMMEDIATE
: ( BEGIN LIT" )" WORD S= UNTIL ;
    ( no more comment from here ) IMMEDIATE
: LIT"
    COMPILE (s) HERE 0 C, ,"
    DUP HERE -^ 1- SWAP C! ; IMMEDIATE
: W"
    [COMPILE] LIT" [ SYSVARS 0x32 + LITN ] LITN
    COMPILE ! ; IMMEDIATE
( ----- 239 )
: ." [COMPILE] LIT" COMPILE STYPE ; IMMEDIATE
: ABORT" [COMPILE] ." COMPILE ABORT ; IMMEDIATE
: BEGIN HERE ; IMMEDIATE
: AGAIN COMPILE (br) HERE - _bchk C, ; IMMEDIATE
: UNTIL COMPILE (?br) HERE - _bchk C, ; IMMEDIATE
: [ INTERPRET ; IMMEDIATE
: ] R> DROP ;
: COMPILE ' LITN ['] , , ; IMMEDIATE
: [COMPILE] ' , ; IMMEDIATE
: ['] ' LITN ; IMMEDIATE
( ----- 240 )
( Grid subsystem. See doc/grid.txt. Load range: B240-B241 )
: XYPOS [ GRID_MEM LITN ] ; : XYMODE [ GRID_MEM LITN ] 2 + ;
'? CURSOR! NIP NOT [IF] : CURSOR! 2DROP ; [THEN]
: XYPOS! COLS LINES * MOD DUP XYPOS @@ CURSOR! XYPOS ! ;
: AT-XY ( x y -- ) COLS * + XYPOS! ;
'? NEWLN NIP NOT [IF]
: NEWLN ( ln -- ) COLS * DUP COLS + SWAP DO SPC I CELL! LOOP ;
[THEN]
: _lf XYMODE C@@ IF EXIT THEN
    XYPOS @@ COLS / 1+ LINES MOD DUP NEWLN
    COLS * XYPOS! ;
: _bs SPC XYPOS @@ TUCK CELL! ( pos ) 1- XYPOS! ;
( ----- 241 )
: (emit)
    DUP BS? IF DROP _bs EXIT THEN
    DUP CR = IF DROP _lf EXIT THEN
    DUP SPC < IF DROP EXIT THEN
    XYPOS @@ CELL!
    XYPOS @@ 1+ DUP COLS MOD IF XYPOS! ELSE DROP _lf THEN ;
: GRID$ 0 XYPOS ! 0 XYMODE C! ;
( ----- 245 )
PS/2 keyboard subsystem

Provides (key?) from a driver providing the PS/2 protocol. That
is, for a driver taking care of providing all key codes emanat-
ing from a PS/2 keyboard, this subsystem takes care of mapping
those keystrokes to ASCII characters. This code is designed to
be cross-compiled and loaded with drivers.

Requires PS2_MEM to be defined.

Load range: 246-249
( ----- 246 )
: PS2_SHIFT [ PS2_MEM LITN ] ;
: PS2$ 0 PS2_SHIFT C! ;

( A list of the values associated with the 0x80 possible scan
codes of the set 2 of the PS/2 keyboard specs. 0 means no
value. That value is a character that can be read in (key?)
No make code in the PS/2 set 2 reaches 0x80. )
CREATE PS2_CODES
( 00 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( 08 ) 0 C, 0 C, 0 C, 0 C, 0 C, 9 C, '`' C, 0 C,
( 10 ) 0 C, 0 C, 0 C, 0 C, 0 C, 'q' C, '1' C, 0 C,
( I don't know why, but the key 2 is sent as 0x1f by 2 of my
  keyboards. Is it a timing problem on the ATtiny? TODO )
( 18 ) 0 C, 0 C, 'z' C, 's' C, 'a' C, 'w' C, '2' C, '2' C,
( 20 ) 0 C, 'c' C, 'x' C, 'd' C, 'e' C, '4' C, '3' C, 0 C,
( 28 ) 0 C, 32 C, 'v' C, 'f' C, 't' C, 'r' C, '5' C, 0 C,
( ----- 247 )
( 30 ) 0 C, 'n' C, 'b' C, 'h' C, 'g' C, 'y' C, '6' C, 0 C,
( 38 ) 0 C, 0 C, 'm' C, 'j' C, 'u' C, '7' C, '8' C, 0 C,
( 40 ) 0 C, ',' C, 'k' C, 'i' C, 'o' C, '0' C, '9' C, 0 C,
( 48 ) 0 C, '.' C, '/' C, 'l' C, ';' C, 'p' C, '-' C, 0 C,
( 50 ) 0 C, 0 C, ''' C, 0 C, '[' C, '=' C, 0 C, 0 C,
( 58 ) 0 C, 0 C, 13 C, ']' C, 0 C, '\' C, 0 C, 0 C,
( 60 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 8 C, 0 C,
( 68 ) 0 C, '1' C, 0 C, '4' C, '7' C, 0 C, 0 C, 0 C,
( 70 ) '0' C, '.' C, '2' C, '5' C, '6' C, '8' C, 27 C, 0 C,
( 78 ) 0 C, 0 C, '3' C, 0 C, 0 C, '9' C, 0 C, 0 C,
( Same values, but shifted )
( 00 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( 08 ) 0 C, 0 C, 0 C, 0 C, 0 C, 9 C, '~' C, 0 C,
( 10 ) 0 C, 0 C, 0 C, 0 C, 0 C, 'Q' C, '!' C, 0 C,
( 18 ) 0 C, 0 C, 'Z' C, 'S' C, 'A' C, 'W' C, '@@' C, '@@' C,
( 20 ) 0 C, 'C' C, 'X' C, 'D' C, 'E' C, '$' C, '#' C, 0 C,
( ----- 248 )
( 28 ) 0 C, 32 C, 'V' C, 'F' C, 'T' C, 'R' C, '%' C, 0 C,
( 30 ) 0 C, 'N' C, 'B' C, 'H' C, 'G' C, 'Y' C, '^' C, 0 C,
( 38 ) 0 C, 0 C, 'M' C, 'J' C, 'U' C, '&' C, '*' C, 0 C,
( 40 ) 0 C, '<' C, 'K' C, 'I' C, 'O' C, ')' C, '(' C, 0 C,
( 48 ) 0 C, '>' C, '?' C, 'L' C, ':' C, 'P' C, '_' C, 0 C,
( 50 ) 0 C, 0 C, '"' C, 0 C, '{' C, '+' C, 0 C, 0 C,
( 58 ) 0 C, 0 C, 13 C, '}' C, 0 C, '|' C, 0 C, 0 C,
( 60 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 8 C, 0 C,
( 68 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( 70 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 27 C, 0 C,
( 78 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( ----- 249 )
: _shift? ( kc -- f ) DUP 0x12 = SWAP 0x59 = OR ;
: (key?) ( -- c? f )
    (ps2kc) DUP NOT IF EXIT THEN ( kc )
    DUP 0xe0 ( extended ) = IF ( ignore ) DROP 0 EXIT THEN
    DUP 0xf0 ( break ) = IF DROP ( )
        ( get next kc and see if it's a shift )
        BEGIN (ps2kc) ?DUP UNTIL ( kc )
        _shift? IF ( drop shift ) 0 PS2_SHIFT C! THEN
        ( whether we had a shift or not, we return the next )
        0 EXIT THEN
    DUP 0x7f > IF DROP 0 EXIT THEN
    DUP _shift? IF DROP 1 PS2_SHIFT C! 0 EXIT THEN
    ( ah, finally, we have a gentle run-of-the-mill KC )
    PS2_CODES PS2_SHIFT C@@ IF 0x80 + THEN + C@@ ( c, maybe 0 )
    ?DUP ( c? f ) ;
( ----- 250 )
( SD Card subsystem Load range: B250-B258 )
: _idle ( -- n ) 0xff (spix) ;

( spix 0xff until the response is something else than 0xff
  for a maximum of 20 times. Returns 0xff if no response. )
: _wait ( -- n )
    0 ( dummy ) 20 0 DO
        DROP _idle DUP 0xff = NOT IF LEAVE THEN LOOP ;
( ----- 251 )
( The opposite of sdcWaitResp: we wait until response is 0xff.
  After a successful read or write operation, the card will be
  busy for a while. We need to give it time before interacting
  with it again. Technically, we could continue processing on
  our side while the card it busy, and maybe we will one day,
  but at the moment, I'm having random write errors if I don't
  do this right after a write, so I prefer to stay cautious
  for now. )
: _ready ( -- ) BEGIN _idle 0xff = UNTIL ;
( ----- 252 )
( Computes n into crc c with polynomial 0x09
  Note that the result is "left aligned", that is, that 8th
  bit to the "right" is insignificant (will be stop bit). )
: _crc7 ( c n -- c )
    XOR           ( c )
    8 0 DO
        2 *       ( <<1 )
        DUP 255 > IF
            ( MSB was set, apply polynomial )
            0xff AND
            0x12 XOR  ( 0x09 << 1, we apply CRC on high bits )
        THEN
    LOOP ;
( send-and-crc7 )
: _s+crc ( n c -- c ) SWAP DUP (spix) DROP _crc7 ;
( ----- 253 )
( cmd arg1 arg2 -- resp )
( Sends a command to the SD card, along with arguments and
  specified CRC fields. (CRC is only needed in initial commands
  though). This does *not* handle CS. You have to
  select/deselect the card outside this routine. )
: _cmd
    _wait DROP ROT    ( a1 a2 cmd )
    0 _s+crc          ( a1 a2 crc )
    ROT |M ROT        ( a2 h l crc )
    _s+crc _s+crc     ( a2 crc )
    SWAP |M ROT       ( h l crc )
    _s+crc _s+crc     ( crc )
    1 OR              ( ensure stop bit )
    (spix) DROP       ( send CRC )
    _wait  ( wait for a valid response... ) ;
( ----- 254 )
( cmd arg1 arg2 -- r )
( Send a command that expects a R1 response, handling CS. )
: SDCMDR1 [ SDC_DEVID LITN ] (spie) _cmd 0 (spie) ;

( cmd arg1 arg2 -- r arg1 arg2 )
( Send a command that expects a R7 response, handling CS. A R7
  is a R1 followed by 4 bytes. arg1 contains bytes 0:1, arg2
  has 2:3 )
: SDCMDR7
    [ SDC_DEVID LITN ] (spie)
    _cmd                 ( r )
    _idle 8 LSHIFT _idle +  ( r arg1 )
    _idle 8 LSHIFT _idle +  ( r arg1 arg2 )
    0 (spie)
;
( ----- 255 )
: _err 0 (spie) LIT" SDerr" ERR ;

( Tight definition ahead, pre-comment.

  Initialize a SD card. This should be called at least 1ms
  after the powering up of the card. We begin by waking up the
  SD card. After power up, a SD card has to receive at least
  74 dummy clocks with CS and DI high. We send 80.
  Then send cmd0 for a maximum of 10 times, success is when
  we get 0x01. Then comes the CMD8. We send it with a 0x01aa
  argument and expect a 0x01aa argument back, along with a
  0x01 R1 response. After that, we need to repeatedly run
  CMD55+CMD41 (0x40000000) until the card goes out of idle
  mode, that is, when it stops sending us 0x01 response and
  send us 0x00 instead. Any other response means that
  initialization failed. )
( ----- 256 )
: SDC$
    10 0 DO _idle DROP LOOP
    0 ( dummy ) 10 0 DO  ( r )
        DROP 0x40 0 0 SDCMDR1  ( CMD0 )
        1 = DUP IF LEAVE THEN
    LOOP NOT IF _err THEN
    0x48 0 0x1aa ( CMD8 ) SDCMDR7 ( r arg1 arg2 )
    ( expected 1 0 0x1aa )
    0x1aa = ROT ( arg1 f r ) 1 = AND SWAP ( f&f arg1 )
    NOT ( 0 expected ) AND ( f&f&f ) NOT IF _err THEN
    BEGIN
        0x77 0 0 SDCMDR1  ( CMD55 )
        1 = NOT IF _err THEN
        0x69 0x4000 0 SDCMDR1  ( CMD41 )
        DUP 1 > IF _err THEN
    NOT UNTIL ; ( out of idle mode, success! )
( ----- 257 )
: _ ( dstaddr blkno -- )
    [ SDC_DEVID LITN ] (spie)
    0x51 ( CMD17 ) 0 ROT ( a cmd 0 blkno ) _cmd
    IF _err THEN
    _wait 0xfe = NOT IF _err THEN
    0 SWAP ( crc a ) 512 0 DO ( crc a )
        _idle ( crc a n ) DUP ROT C!+ ( crc n a+1 )
        ROT> CRC16 ( a+1 crc ) SWAP LOOP ( crc a+1 )
    DROP ( crc1 )
    _idle 8 LSHIFT _idle + ( crc2 )
    _wait DROP 0 (spie) = NOT IF _err THEN ;
: SDC@@ ( blkno -- )
    2 * DUP BLK( SWAP ( b a b ) _
    1+ BLK( 512 + SWAP _ ;
( ----- 258 )
: _ ( srcaddr blkno -- )
    [ SDC_DEVID LITN ] (spie)
    0x58 ( CMD24 ) 0 ROT ( a cmd 0 blkno ) _cmd
    IF _err THEN
    _idle DROP 0xfe (spix) DROP 0 SWAP ( crc a )
    512 0 DO ( crc a )
        C@@+ ( crc a+1 n ) ROT OVER ( a n crc n )
        CRC16 ( a n crc ) SWAP ( a crc n )
        (spix) DROP ( a crc ) SWAP LOOP ( crc a )
    DROP ( crc ) |M ( lsb msb )
    (spix) DROP (spix) DROP
    _wait DROP 0 (spie) ;
: SDC! ( blkno -- )
    2 * DUP BLK( SWAP ( b a b ) _
    1+ BLK( 512 + SWAP _ ;
( ----- 260 )
Fonts

Fonts are kept in "source" form in the following blocks and
then compiled to binary bitmasks by the following code. In
source form, fonts are a simple sequence of '.' and 'X'. '.'
means empty, 'X' means filled. Glyphs are entered one after the
other, starting at 0x21 and ending at 0x7e. To be space
efficient in blocks, we align glyphs horizontally in the blocks
to fit as many character as we can. For example, a 5x7 font
would mean that we would have 12x2 glyphs per block.

261 Font compiler              265 3x5 font
267 5x7 font                   271 7x7 font
( ----- 261 )
( Converts "dot-X" fonts to binary "glyph rows". One byte for
  each row. In a 5x7 font, each glyph thus use 7 bytes.
  Resulting bytes are aligned to the left of the byte.
  Therefore, for a 5-bit wide char, "X.X.X" translates to
  0b10101000. Left-aligned bytes are easier to work with when
  compositing glyphs. )
( ----- 262 )
VARIABLE _w VARIABLE _h
: _g ( given a top-left of dot-X in BLK(, spit H bin lines )
    _h @@ 0 DO
    0 _w @@ 0 DO ( a r )
        1 LSHIFT
        OVER J 64 * I + + C@@ 'X' = IF 1+ THEN
    LOOP 8 _w @@ - LSHIFT C, LOOP DROP ;
: _l ( a u -- a, spit a line of u glyphs )
    ( u ) 0 DO ( a )
        DUP I _w @@ * + _g
    LOOP ;
( ----- 263 )
: CPFNT3x5 3 _w ! 5 _h !
    _h @@ ALLOT0 ( space char )
    265 BLK@@ BLK( 21 _l 320 + 21 _l 320 + 21 _l DROP ( 63 )
    266 BLK@@ BLK( 21 _l 320 + 10 _l DROP ( 94! ) ;
: CPFNT5x7 5 _w ! 7 _h !
    _h @@ ALLOT0 ( space char )
    270 267 DO I BLK@@ BLK( 12 _l 448 + 12 _l DROP LOOP ( 72 )
    270 BLK@@ BLK( 12 _l 448 + 10 _l DROP ( 94! ) ;
: CPFNT7x7 7 _w ! 7 _h !
    _h @@ ALLOT0 ( space char )
    276 271 DO I BLK@@ BLK( 9 _l 448 + 9 _l DROP LOOP ( 90 )
    276 BLK@@ BLK( 4 _l DROP ( 94! ) ;
( ----- 265 )
.X.X.XX.X.XXX...X..X...XX...X...............X.X..X.XX.XX.X.XXXX
.X.X.XXXXXX...XX.X.X..X..X.XXX.X............XX.XXX...X..XX.XX..
.X........XX.X..X.....X..X..X.XXX...XXX....X.X.X.X..X.XX.XXXXX.
......XXXXX.X..X.X....X..X.X.X.X..X.......X..X.X.X.X....X..X..X
.X....X.X.X...X.XX.....XX........X......X.X...X.XXXXXXXX...XXX.
.XXXXXXXXXXX........X...X..XX..X..X.XX..XXXX.XXXXXX.XXX.XXXXXXX
X....XX.XX.X.X..X..X.XXX.X...XXXXX.XX.XX..X.XX..X..X..X.X.X...X
XXX.X.XXXXXX......X.......X.X.XXXXXXXX.X..X.XXX.XX.X.XXXX.X...X
X.XX..X.X..X.X..X..X.XXX.X....X..X.XX.XX..X.XX..X..X.XX.X.X...X
XXXX..XXXXX....X....X...X...X..XXX.XXX..XXXX.XXXX...XXX.XXXXXX.
X.XX..X.XXX.XXXXX.XXXXX..XXXXXX.XX.XX.XX.XX.XXXXXXXX..XXX.X....
XX.X..XXXX.XX.XX.XX.XX.XX...X.X.XX.XX.XX.XX.X..XX..X....XX.X...
X..X..XXXX.XX.XXX.X.XXX..X..X.X.XX.XXXX.X..X..X.X...X...X......
XX.X..X.XX.XX.XX..XXXX.X..X.X.X.XX.XXXXX.X.X.X..X....X..X......
X.XXXXX.XX.XXXXX...XXX.XXX..X.XXX.X.X.XX.X.X.XXXXXX..XXXX...XXX
!"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
( ----- 266 )
X.....X.......X....XX...X...X...XX..XX.......................X.
.X.XX.X...XX..X.X.X...X.X........X.X.X.X.XXX..X.XX..XX.XX.XXXXX
.....XXX.X...XXX.XXX.X.XXX..X...XXX..X.XXXX.XX.XX.XX.XX..XX..X.
...XXXX.XX..X.XXX.X...XXX.X.X...XX.X.X.X.XX.XX.XXX..XXX....X.X.
...XXXXX..XX.XX.XXX..XX.X.X.X.XX.X.X.XXX.XX.X.X.X....XX..XX..XX
...................XX.X.XX.....................................
X.XX.XX.XX.XX.XXXX.X..X..X..XX
X.XX.XX.X.X..X..XXX...X...XXX.
X.XX.XXXX.X..X.XX..X..X..X....
XXX.X.X.XX.X.X.XXX.XX.X.XX....
`abcdefghijklmnopqrstuvwxyz{|}~
( ----- 267 )
..X...X.X........X..............X....X....X.................
..X...X.X..X.X..XXXXX...X.XX....X...X......X.X.X.X..X.......
..X.......XXXXXX.......X.X..X......X........X.XXX...X.......
..X........X.X..XXX...X...XX.......X........XXXXXXXXXXX.....
..........XXXXX....X.X....XX.X.....X........X.XXX...X.......
..X........X.X.XXXX.X...XX..X.......X......X.X.X.X..X.....X.
..X..............X.......XXX.X.......X....X..............X..
................XXX...XX..XXX..XXX...XX.XXXXX.XXX.XXXXX.XXX.
..............XX...X.X.X.X...XX...X.X.X.X....X........XX...X
.............X.X..XX...X.....X....XX..X.XXXX.X........XX...X
XXXXX.......X..X.X.X...X....X...XX.XXXXX....XXXXX....X..XXX.
...........X...XX..X...X...X......X...X.....XX...X..X..X...X
......XX..X....X...X...X..X...X...X...X.X...XX...X.X...X...X
......XX........XXX..XXXXXXXXX.XXX....X..XXX..XXX.X.....XXX.
!"#$%&'()*+,-./012345678
( ----- 268 )
.XXX...............X.....X.....XXX..XXX..XXX.XXXX..XXX.XXXX.
X...X..X....X....XX.......XX..X...XX...XX...XX...XX...XX...X
X...X..X....X...XX..XXXXX..XX.....XX..XXX...XX...XX....X...X
.XXX...........X.............X...X.X..XXXXXXXXXXX.X....X...X
....X..X....X...XX..XXXXX..XX...X..X....X...XX...XX....X...X
....X..X...X.....XX.......XX.......X...XX...XX...XX...XX...X
.XXX...............X.....X......X...XXX.X...XXXXX..XXX.XXXX.
XXXXXXXXXX.XXX.X...X.XXX....XXX..X.X....X...XX...X.XXX.XXXX.
X....X....X...XX...X..X......XX.X..X....XX.XXXX..XX...XX...X
X....X....X....X...X..X......XXX...X....X.X.XXX..XX...XX...X
XXXX.XXXX.X..XXXXXXX..X......XX....X....X...XX.X.XX...XXXXX.
X....X....X...XX...X..X......XXX...X....X...XX..XXX...XX....
X....X....X...XX...X..X..X...XX.X..X....X...XX..XXX...XX....
XXXXXX.....XXX.X...X.XXX..XXX.X..X.XXXXXX...XX...X.XXX.X....
9:;<=>?@@ABCDEFGHIJKLMNOP
( ----- 269 )
.XXX.XXXX..XXX.XXXXXX...XX...XX...XX...XX...XXXXXXXXX.......
X...XX...XX...X..X..X...XX...XX...XX...XX...XX...XX....X....
X...XX...XX......X..X...XX...XX...X.X.X..X.X....X.X.....X...
X...XXXXX..XXX...X..X...XX...XX...X..X....X....X..X......X..
X.X.XX.X......X..X..X...XX...XX.X.X.X.X...X...X...X.......X.
X..XXX..X.X...X..X..X...X.X.X.X.X.XX...X..X..X...XX........X
.XXXXX...X.XXX...X...XXX...X...X.X.X...X..X..XXXXXXXX.......
..XXX..X.........X..........................................
....X.X.X.........X.........................................
....XX...X...........XXX.X.....XXX.....X.XXX..XX....XXXX....
....X...................XX....X...X....XX...XX..X..X..XX....
....X................XXXXXXX..X......XXXXXXXXX......XXXXXX..
....X...............X...XX..X.X...X.X..XX....XXX......XX..X.
..XXX.....XXXXX......XXXXXXX...XXX...XXX.XXXXX......XX.X..X.
QRSTUVWXYZ[\]^_`abcdefgh
( ----- 270 )
............................................................
............................................................
..X......XX..X..XX...X.X.XXX...XXX.XXX....XXXX.XX..XXX..X...
..........X.X....X..X.X.XX..X.X...XX..X..X..XXX...X....XXX..
..X......XXX.....X..X...XX...XX...XXXX....XXXX.....XXX..X...
..X...X..XX.X....X..X...XX...XX...XX........XX........X.X...
..X....XX.X..X...XX.X...XX...X.XXX.X........XX.....XXX...XX.
................................XX...X...XX.......
...............................X.....X.....X......
X...XX...XX...XX...XX...XXXXXX.X.....X.....X..X.X.
X...XX...XX...X.X.X..X.X....X.X......X......XX.X..
X...XX...XX...X..X....X....X...X.....X.....X......
X...X.X.X.X.X.X.X.X..X....X....X.....X.....X......
.XXX...X...X.X.X...XX....XXXXX..XX...X...XX.......
ijklmnopqrstuvwxyz{|}~
( ----- 271 )
..XX....XX.XX..XX.XX....XX..XX......XXX......XX.....XX...XX....
..XX....XX.XX..XX.XX..XXXXXXXX..XX.XX.XX....XX.....XX.....XX...
..XX....XX.XX.XXXXXXXXX.X......XX..XX.XX...XX.....XX.......XX..
..XX...........XX.XX..XXXXX...XX....XXX...........XX.......XX..
..XX..........XXXXXXX...X.XX.XX....XX.XX.X........XX.......XX..
...............XX.XX.XXXXXX.XX..XX.XX..XX..........XX.....XX...
..XX...........XX.XX...XX.......XX..XXX.XX..........XX...XX....
...........................................XXXX....XX....XXXX..
..XX.....XX............................XX.XX..XX..XXX...XX..XX.
XXXXXX...XX...........................XX..XX.XXX...XX.......XX.
.XXXX..XXXXXX........XXXXXX..........XX...XXXXXX...XX......XX..
XXXXXX...XX.........................XX....XXX.XX...XX.....XX...
..XX.....XX.....XX............XX...XX.....XX..XX...XX....XX....
...............XX.............XX...........XXXX..XXXXXX.XXXXXX.
!"#$%&'()*+,-./012
( ----- 272 )
.XXXX.....XX..XXXXXX...XXX..XXXXXX..XXXX...XXXX................
XX..XX...XXX..XX......XX........XX.XX..XX.XX..XX...............
....XX..XXXX..XXXXX..XX........XX..XX..XX.XX..XX...XX.....XX...
..XXX..XX.XX......XX.XXXXX....XX....XXXX...XXXXX...XX.....XX...
....XX.XXXXXX.....XX.XX..XX..XX....XX..XX.....XX...............
XX..XX....XX..XX..XX.XX..XX..XX....XX..XX....XX....XX.....XX...
.XXXX.....XX...XXXX...XXXX...XX.....XXXX...XXX.....XX....XX....
...XX.........XX......XXXX...XXXX...XXXX..XXXXX...XXXX..XXXX...
..XX...........XX....XX..XX.XX..XX.XX..XX.XX..XX.XX..XX.XX.XX..
.XX....XXXXXX...XX......XX..XX.XXX.XX..XX.XX..XX.XX.....XX..XX.
XX...............XX....XX...XX.X.X.XXXXXX.XXXXX..XX.....XX..XX.
.XX....XXXXXX...XX.....XX...XX.XXX.XX..XX.XX..XX.XX.....XX..XX.
..XX...........XX...........XX.....XX..XX.XX..XX.XX..XX.XX.XX..
...XX.........XX.......XX....XXXX..XX..XX.XXXXX...XXXX..XXXX...
3456789:;<=>?@@ABCD
( ----- 273 )
XXXXXX.XXXXXX..XXXX..XX..XX.XXXXXX..XXXXX.XX..XX.XX.....XX...XX
XX.....XX.....XX..XX.XX..XX...XX......XX..XX.XX..XX.....XXX.XXX
XX.....XX.....XX.....XX..XX...XX......XX..XXXX...XX.....XXXXXXX
XXXXX..XXXXX..XX.XXX.XXXXXX...XX......XX..XXX....XX.....XX.X.XX
XX.....XX.....XX..XX.XX..XX...XX......XX..XXXX...XX.....XX.X.XX
XX.....XX.....XX..XX.XX..XX...XX...XX.XX..XX.XX..XX.....XX...XX
XXXXXX.XX......XXXX..XX..XX.XXXXXX..XXX...XX..XX.XXXXXX.XX...XX
XX..XX..XXXX..XXXXX...XXXX..XXXXX...XXXX..XXXXXX.XX..XX.XX..XX.
XX..XX.XX..XX.XX..XX.XX..XX.XX..XX.XX..XX...XX...XX..XX.XX..XX.
XXX.XX.XX..XX.XX..XX.XX..XX.XX..XX.XX.......XX...XX..XX.XX..XX.
XXXXXX.XX..XX.XXXXX..XX..XX.XXXXX...XXXX....XX...XX..XX.XX..XX.
XX.XXX.XX..XX.XX.....XX.X.X.XX.XX......XX...XX...XX..XX.XX..XX.
XX..XX.XX..XX.XX.....XX.XX..XX..XX.XX..XX...XX...XX..XX..XXXX..
XX..XX..XXXX..XX......XX.XX.XX..XX..XXXX....XX....XXXX....XX...
EFGHIJKLMNOPQRSTUVWXYZ[\]^_
( ----- 274 )
XX...XXXX..XX.XX..XX.XXXXXX.XXXXX.........XXXXX....XX..........
XX...XXXX..XX.XX..XX.....XX.XX.....XX........XX...XXXX.........
XX.X.XX.XXXX..XX..XX....XX..XX......XX.......XX..XX..XX........
XX.X.XX..XX....XXXX....XX...XX.......XX......XX..X....X........
XXXXXXX.XXXX....XX....XX....XX........XX.....XX................
XXX.XXXXX..XX...XX...XX.....XX.........XX....XX................
XX...XXXX..XX...XX...XXXXXX.XXXXX.........XXXXX.........XXXXXXX
.XX...........XX................XX..........XXX.........XX.....
..XX..........XX................XX.........XX.....XXXX..XX.....
...XX...XXXX..XXXXX...XXXX...XXXXX..XXXX...XX....XX..XX.XXXXX..
...........XX.XX..XX.XX..XX.XX..XX.XX..XX.XXXXX..XX..XX.XX..XX.
........XXXXX.XX..XX.XX.....XX..XX.XXXXXX..XX.....XXXXX.XX..XX.
.......XX..XX.XX..XX.XX..XX.XX..XX.XX......XX........XX.XX..XX.
........XXXXX.XXXXX...XXXX...XXXXX..XXXX...XX.....XXX...XX..XX.
WXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
( ----- 275 )
..XX.....XX...XX......XXX......................................
..............XX.......XX......................................
.XXX....XXX...XX..XX...XX....XX.XX.XXXXX...XXXX..XXXXX...XXXXX.
..XX.....XX...XX.XX....XX...XXXXXXXXX..XX.XX..XX.XX..XX.XX..XX.
..XX.....XX...XXXX.....XX...XX.X.XXXX..XX.XX..XX.XX..XX.XX..XX.
..XX.....XX...XX.XX....XX...XX.X.XXXX..XX.XX..XX.XXXXX...XXXXX.
.XXXX..XX.....XX..XX..XXXX..XX...XXXX..XX..XXXX..XX.........XX.
...............XX..............................................
...............XX..............................................
XX.XX...XXXXX.XXXXX..XX..XX.XX..XX.XX...XXXX..XX.XX..XX.XXXXXX.
XXX.XX.XX......XX....XX..XX.XX..XX.XX.X.XX.XXXX..XX..XX....XX..
XX......XXXX...XX....XX..XX.XX..XX.XX.X.XX..XX...XX..XX...XX...
XX.........XX..XX....XX..XX..XXXX..XXXXXXX.XXXX...XXXXX..XX....
XX.....XXXXX....XXX...XXXXX...XX....XX.XX.XX..XX.....XX.XXXXXX.
ijklmnopqrstuvwxyz{|}~
( ----- 276 )
...XX....XX...XX......XX...X
..XX.....XX....XX....XX.X.XX
..XX.....XX....XX....X...XX.
XXX......XX.....XXX.........
..XX.....XX....XX...........
..XX.....XX....XX...........
...XX....XX...XX............
{|}~
( ----- 280 )
( Z80 boot code. See doc/code/z80.txt Load range: B281-B306 )
VARIABLE lblexec VARIABLE lbluflw VARIABLE lbloflw
( see comment at TICKS' definition )
( 7.373MHz target: 737t. outer: 37t inner: 16t )
( tickfactor = (737 - 37) / 16 )
CREATE tickfactor 44 ,
: chkPS, ( sz -- ) 2 * PS_ADDR -^ HL SWAP LDdi, SP SUBHLd,
  CC lbluflw @@ JPc, ;
( replace ;CODE with ;CODEOFLW? for words that need it. )
: ;CODEOFLW?
  IX PUSH, EX(SP)HL, ( do EX to count the IX push in SP )
  SP SUBHLd, HL POP,
  CC ( no overflow ) lblnext@@ JPc,
  ( overflow ) lbloflw @@ JP, ;
( ----- 281 )
HERE ORG ! ( STABLE ABI )
JR, L1 FWR ( B282 ) NOP, NOP, ( unused ) NOP, NOP, ( 04, BOOT )
NOP, NOP, ( 06, uflw ) NOP, NOP, ( 08, LATEST )
NOP, NOP, ( 0a (main) ) 0 JP, ( 0c QUIT ) NOP,
0 JP, ( RST 10 )  NOP, NOP, ( 13, oflw ) NOP, NOP, NOP,
0 JP, ( RST 18 ) 5 ALLOT0
0 JP, ( RST 20 ) 5 ALLOT0
0 JP, ( RST 28 ) 5 ALLOT0
0 JP, ( RST 30 ) 5 ALLOT0
0 JP, ( RST 38 )
( ----- 282 )
L1 FSET ( B281 )
  SP PS_ADDR LDdi, IX RS_ADDR LDdi,
( LATEST is a label to the latest entry of the dict. It is
  written at offset 0x08 by the process or person building
  Forth. )
  BIN( @@ 0x08 + LDHL(i),
  SYSVARS 0x02 ( CURRENT ) + LD(i)HL,
HERESTART [IF] HL HERESTART LDdi, [THEN]
  SYSVARS 0x04 + LD(i)HL, ( +04 == HERE )
  BIN( @@ 0x04 ( BOOT ) + LDHL(i),
  JR, L1 FWR ( execute, B283 )
lblnext BSET PC ORG @@ 0xf + ! ( Stable ABI )
  LDA(BC), L A LDrr, BC INCd,
  LDA(BC), H A LDrr, BC INCd,
  ( continue to execute )
( ----- 283 )
lblexec BSET L1 FSET ( B282 )
  ( HL -> wordref )
  A (HL) LDrr, HL INCd, ( HL points to PFA )
  A ORr, IFZ, ( native ) JP(HL), THEN,
  A DECr, IFNZ, ( not compiled )
  A DECr, IFZ, ( cell )
    HL PUSH, ( PFA ) JR, lblnext BWR THEN,
  A DECr, IFNZ, ( not does: alias, ialias or const )
  LDDE(HL), EXDEHL, ( read PFA )
  A DECr, JRZ, ( alias ) lblexec BWR
  A DECr, IFZ, ( ialias )
    LDDE(HL), EXDEHL, JR, lblexec BWR THEN,
  ( const ) HL PUSH, JR, lblnext BWR
  THEN, ( does )
  LDDE(HL), ( does addr ) HL INCd, HL PUSH, ( PFA ) EXDEHL,
  THEN, ( continue to compiledWord )
( ----- 284 )
( compiled word. HL points to its first wordref, which we'll
  execute now: Push current IP to RS, set new IP to PFA+2,
  Execute wordref )
  IX INCd, IX INCd,
  ( Before we continue: are we overflowing? )
    IX PUSH, EX(SP)HL, SP SUBHLd, HL POP,
    JRNC, L1 FWR ( lbloflw )
  0 IX+ C LDIXYr, 1 IX+ B LDIXYr,
  LDDE(HL), HL INCd, ( DE -> wordref HL -> PFA+2 )
  B H LDrr, C L LDrr, ( --> IP )
  EXDEHL, ( HL -> wordref ) JR, lblexec BWR
lbluflw BSET BIN( @@ 0x06 ( uflw ) + LDHL(i), JR, lblexec BWR
lbloflw BSET L1 FSET
  SP PS_ADDR LDdi, IX RS_ADDR LDdi,
  BIN( @@ 0x13 ( oflw ) + LDHL(i), JR, lblexec BWR
( ----- 285 )
( Native words )
HERE 4 + XCURRENT ! ( make next CODE have 0 prev field )
CODE FIND ( w -- a f ) 1 chkPS,
  SYSVARS 0x02 ( CURRENT ) + LDHL(i), EXDEHL,
  HL POP, ( w ) HL PUSH, ( --> lvl 1 )
  A (HL) LDrr, ( wlen ) A ORr,
  ( special case. zero len? we never find anything. )
  IFZ, PUSH0, ;CODE THEN,
  BC PUSH, ( --> lvl 2, protect )
  ( We hold HL by the *tail*. )
  C A LDrr, B 0 LDri, ( C holds our length )
  BC ADDHLd, HL INCd, ( HL points to after-last-char )
( ----- 286 )
  BEGIN, HL PUSH, ( --> lvl 3 ) DE PUSH, ( --> lvl 4 )
    DE DECd, LDA(DE), 0x7f ANDi, ( IMMEDIATE ) C CPr, IFZ,
      DE DECd, ( Skip prev field. One less because we pre-dec )
      DE DECd,
      B C LDrr, ( loop C times ) BEGIN,
        ( pre-decrement for easier Z matching )
        DE DECd, HL DECd,
        LDA(DE), (HL) CPr,
        JRNZ, L1 FWR ( break! )
      DJNZ, AGAIN, THEN, L1 FSET
( At this point, Z is set if we have a match. )
    DE POP, ( <-- lvl 4 ) IFZ, ( match, we're done! )
      HL POP, BC POP, HL POP, ( <-- lvl 1-3 ) DE PUSH,
      PUSH1, ;CODEOFLW? THEN,
( ----- 287 )
    ( no match, go to prev and continue )
    DE DECd, DE DECd, DE DECd, ( prev field )
    DE PUSH, ( --> lvl 4 ) EXDEHL, LDDE(HL),
    ( DE contains prev offset )
    HL POP, ( <-- lvl 4, prev field )
    DEZ, IFNZ, ( offset not zero )
      ( carry cleared from "or e" in DEZ, )
      DE SBCHLd, EXDEHL, ( result in DE ) THEN,
    HL POP, ( <-- lvl 3 ) JRNZ, AGAIN, ( loop-B288 )
  BC POP, ( <-- lvl 2 )
  ( Z set? end of dict, not found. "w" already on PSP TOS )
  PUSH0, ;CODEOFLW?
( ----- 288 )
CODE (br) L1 BSET ( used in ?br and loop )
  LDA(BC), H 0 LDri, L A LDrr,
  RLA, IFC, H DECr, THEN,
  BC ADDHLd, B H LDrr, C L LDrr, ;CODE
CODE (?br) 1 chkPS,
  HL POP, HLZ, JRZ, L1 BWR ( br + 1. False, branch )
  ( True, skip next byte and don't branch ) BC INCd, ;CODE
CODE (loop)
  0 IX+ INC(IXY+), IFZ, 1 IX+ INC(IXY+), THEN, ( I++ )
  ( Jump if I <> I' )
  A 0 IX+ LDrIXY, 2 IX- CP(IXY+), JRNZ, L1 BWR ( branch )
  A 1 IX+ LDrIXY, 1 IX- CP(IXY+), JRNZ, L1 BWR ( branch )
  ( don't branch )
  IX DECd, IX DECd, IX DECd, IX DECd, BC INCd, ;CODE
( ----- 289 )
CODE EXECUTE 1 chkPS, HL POP, lblexec @@ JP,
CODE QUIT
L1 BSET ( used in ABORT ) PC ORG @@ 0xd + ! ( Stable ABI )
  IX RS_ADDR LDdi, BIN( @@ 0x0a ( main ) + LDHL(i),
  lblexec @@ JP,
CODE ABORT SP PS_ADDR LDdi, JR, L1 BWR
CODE BYE HALT,
CODE EXIT
    C 0 IX+ LDrIXY, B 1 IX+ LDrIXY, IX DECd, IX DECd, ;CODE
( ----- 290 )
CODE (n)
  LDA(BC), L A LDrr, BC INCd,
  LDA(BC), H A LDrr, BC INCd,
  HL PUSH, ;CODEOFLW?
CODE (b)
  LDA(BC), L A LDrr, BC INCd,
  H 0 LDri, HL PUSH, ;CODEOFLW?
CODE (s)
  BC PUSH, LDA(BC), C ADDr, IFC, B INCr, THEN,
  C A LDrr, BC INCd, ;CODEOFLW?
( ----- 291 )
CODE ROT ( a b c -- b c a ) 3 chkPS,
  DE POP, ( C ) HL POP, ( B ) EX(SP)HL, ( A <> B )
  DE PUSH, ( C ) HL PUSH, ( A ) ;CODE
CODE ROT> ( a b c -- c a b ) 3 chkPS,
  HL POP, ( C ) DE POP, ( B ) EX(SP)HL, ( A <> C )
  HL PUSH, ( A ) DE PUSH, ( B ) ;CODE
CODE DUP ( a -- a a ) 1 chkPS,
  HL POP, HL PUSH, HL PUSH, ;CODEOFLW?
CODE ?DUP 1 chkPS,
  HL POP, HL PUSH, HLZ, IFNZ, HL PUSH, THEN, ;CODEOFLW?
( ----- 292 )
CODE DROP ( a -- ) 1 chkPS, HL POP, ;CODE
CODE SWAP ( a b -- b a ) 2 chkPS,
  HL POP, ( B ) EX(SP)HL, ( A <> B ) HL PUSH, ( A ) ;CODE
CODE OVER ( a b -- a b a ) 2 chkPS,
  HL POP, ( B ) DE POP, ( A )
  DE PUSH, ( A ) HL PUSH, ( B ) DE PUSH, ( A ) ;CODEOFLW?
CODE 2DROP ( a b -- ) 2 chkPS, HL POP, HL POP, ;CODE
CODE 2DUP ( a b -- a b a b ) 2 chkPS,
  HL POP, ( b ) DE POP, ( a )
  DE PUSH, HL PUSH,
  DE PUSH, HL PUSH, ;CODEOFLW?
( ----- 293 )
CODE AND 2 chkPS,
  HL POP, DE POP,
  A E LDrr, L ANDr, L A LDrr,
  A D LDrr, H ANDr, H A LDrr,
  HL PUSH, ;CODE
CODE OR 2 chkPS,
  HL POP, DE POP,
  A E LDrr, L ORr, L A LDrr,
  A D LDrr, H ORr, H A LDrr,
  HL PUSH, ;CODE
CODE XOR 2 chkPS,
  HL POP, DE POP,
  A E LDrr, L XORr, L A LDrr,
  A D LDrr, H XORr, H A LDrr,
  HL PUSH, ;CODE
( ----- 294 )
CODE NOT 1 chkPS, HL POP, HLZ, PUSHZ, ;CODE
CODE + 2 chkPS, HL POP, DE POP, DE ADDHLd, HL PUSH, ;CODE
CODE - 2 chkPS, DE POP, HL POP, DE SUBHLd, HL PUSH, ;CODE
CODE * 2 chkPS, EXX, ( protect BC ) ( DE * BC -> HL )
  DE POP, BC POP,
  HL 0 LDdi, A 0x10 LDri, BEGIN,
    HL ADDHLd, E RL, D RL,
    IFC, BC ADDHLd, THEN,
    A DECr, JRNZ, AGAIN,
  HL PUSH, EXX, ( unprotect BC ) ;CODE
( ----- 295 )
( Divides AC by DE. quotient in AC remainder in HL )
CODE /MOD 2 chkPS, EXX, ( protect BC )
  DE POP, BC POP,
  A B LDrr, B 16 LDri, HL 0 LDdi, BEGIN,
    SCF, C RL, RLA,
    HL ADCHLd, DE SBCHLd,
    IFC, DE ADDHLd, C DECr, THEN,
  DJNZ, AGAIN,
  B A LDrr,
  HL PUSH, BC PUSH, EXX, ( unprotect BC ) ;CODE
( ----- 296 )
( The word below is designed to wait the proper 100us per tick
  at 500kHz when tickfactor is 1. If the CPU runs faster,
  tickfactor has to be adjusted accordingly. "t" in comments
  below means "T-cycle", which at 500kHz is worth 2us. )
CODE TICKS 1 chkPS,
  HL POP,
  ( we pre-dec to compensate for initialization )
  BEGIN,
    HL DECd, ( 6t )
    IFZ, ( 12t ) ;CODE THEN,
    A tickfactor @@ LDri, ( 7t )
    BEGIN, A DECr, ( 4t ) JRNZ, ( 12t ) AGAIN,
  JR, ( 12t ) AGAIN, ( outer: 37t inner: 16t )
( ----- 297 )
CODE ! 2 chkPS,
    HL POP, DE POP,
    (HL) E LDrr, HL INCd,
    (HL) D LDrr, ;CODE
CODE @@ 1 chkPS,
    HL POP, LDDE(HL), DE PUSH, ;CODE
CODE C! 2 chkPS,
    HL POP, DE POP,
    (HL) E LDrr, ;CODE
CODE C@@ 1 chkPS,
    HL POP,
    L (HL) LDrr,
    H 0 LDri, HL PUSH, ;CODE
( ----- 298 )
CODE PC! 2 chkPS, EXX, ( protect BC )
    BC POP, HL POP,
    L OUT(C)r,
EXX, ( unprotect BC ) ;CODE
CODE PC@@ 1 chkPS, EXX, ( protect BC )
    BC POP,
    H 0 LDri, L INr(C), HL PUSH,
EXX, ( unprotect BC ) ;CODE
CODE I L 0 IX+ LDrIXY, H 1 IX+ LDrIXY, HL PUSH, ;CODEOFLW?
CODE I' L 2 IX- LDrIXY, H 1 IX- LDrIXY, HL PUSH, ;CODEOFLW?
CODE J L 4 IX- LDrIXY, H 3 IX- LDrIXY, HL PUSH, ;CODEOFLW?
CODE >R 1 chkPS, HL POP,
    IX INCd, IX INCd, 0 IX+ L LDIXYr, 1 IX+ H LDIXYr, ;CODE
( ----- 299 )
CODE R>
  L 0 IX+ LDrIXY, H 1 IX+ LDrIXY, IX DECd, IX DECd,
  HL PUSH, ;CODE
CODE 2>R 2 chkPS,
  DE POP, HL POP,
  IX INCd, IX INCd, 0 IX+ L LDIXYr, 1 IX+ H LDIXYr,
  IX INCd, IX INCd, 0 IX+ E LDIXYr, 1 IX+ D LDIXYr, ;CODE
CODE 2R>
  L 0 IX+ LDrIXY, H 1 IX+ LDrIXY, IX DECd, IX DECd,
  E 0 IX+ LDrIXY, D 1 IX+ LDrIXY, IX DECd, IX DECd,
  DE PUSH, HL PUSH, ;CODE
( ----- 300 )
CODE []= 3 chkPS, EXX, ( protect BC ) BC POP, DE POP, HL POP,
  L1 BSET ( loop )
    LDA(DE), DE INCd, CPI,
    IFNZ, PUSH0, EXX, ;CODE THEN,
    CPE L1 @@ JPc, ( BC not zero? loop )
  PUSH1, EXX, ;CODE
CODE = 2 chkPS, DE POP, HL POP, DE SUBHLd, PUSHZ, ;CODE
CODE < 2 chkPS, DE POP, HL POP,
  DE SUBHLd, IFC, PUSH1, ELSE, PUSH0, THEN, ;CODE
CODE > 2 chkPS, HL POP, DE POP, ( inverted args )
  DE SUBHLd, IFC, PUSH1, ELSE, PUSH0, THEN, ;CODE
CODE (im1) IM1, EI, ;CODE
( ----- 301 )
CODE 1+ 1 chkPS, HL POP, HL INCd, HL PUSH, ;CODE
CODE 1- 1 chkPS, HL POP, HL DECd, HL PUSH, ;CODE
CODE CRC16  ( c n -- c ) 2 chkPS, EXX, ( protect BC )
  HL POP, ( n ) DE POP, ( c )
  A L LDrr, D XORr, D A LDrr,
  B 8 LDri, BEGIN,
    E SLA, D RL,
    IFC, ( msb is set, apply polynomial )
      A D LDrr, 0x10 XORi, D A LDrr,
      A E LDrr, 0x21 XORi, E A LDrr,
    THEN,
  DJNZ, AGAIN,
  DE PUSH, EXX, ( unprotect BC ) ;CODE
( ----- 302 )
CODE RSHIFT ( n u -- n ) 2 chkPS,
  DE POP, ( u ) HL POP, ( n )
  A E LDrr, A ORr, IFNZ, BEGIN,
    H SRL, L RR, A DECr, JRNZ, AGAIN, THEN,
  HL PUSH, ;CODE
CODE LSHIFT ( n u -- n ) 2 chkPS,
  DE POP, ( u ) HL POP, ( n )
  A E LDrr, A ORr, IFNZ, BEGIN,
    L SLA, H RL, A DECr, JRNZ, AGAIN, THEN,
  HL PUSH, ;CODE
( ----- 303 )
CODE |L ( n -- msb lsb ) 1 chkPS,
  HL POP,
  D 0 LDri, E H LDrr, DE PUSH,
  E L LDrr, DE PUSH, ;CODEOFLW?
CODE |M ( n -- lsb msb ) 1 chkPS,
  HL POP,
  D 0 LDri, E L LDrr, DE PUSH,
  E H LDrr, DE PUSH, ;CODEOFLW?
( ----- 310 )
Z80 drivers

311 AT28 EEPROM                312 SPI relay
315 TMS9918
320 MC6850 driver              325 Zilog SIO driver
330 Sega Master System VDP     335 SMS PAD
340 SMS KBD                    347 SMS SPI relay
348 SMS Ports
350 TI-84+ LCD                 355 TI-84+ Keyboard
360 TRS-80 4P drivers
370-399 unused
( ----- 311 )
CODE AT28C! ( c a -- ) 2 chkPS,
    HL POP, DE POP,
    (HL) E LDrr, A E LDrr, ( orig ) D E LDrr, ( save )
    E (HL) LDrr, ( poll ) BEGIN,
        A (HL) LDrr, ( poll ) E CPr, ( same as old? )
        E A LDrr, ( save old poll, Z preserved )
    JRNZ, AGAIN,
( equal to written? SUB instead of CP to ensure IOERR is NZ )
    D SUBr, IFNZ, SYSVARS 0x41 + ( IOERR ) LD(i)A, THEN,
;CODE
: AT28! ( n a -- ) 2DUP AT28C! 1+ SWAP 8 RSHIFT SWAP AT28C! ;
: AT28$ ['] AT28C! W" C!" :* ['] AT28! W" !" :* ;
( ----- 312 )
( SPI relay driver. See doc/hw/z80/spi.txt )
CODE (spix) ( n -- n ) 1 chkPS,
    HL POP, A L LDrr,
    SPI_DATA OUTiA,
    ( wait until xchg is done )
    BEGIN, SPI_CTL INAi, 1 ANDi, JRNZ, AGAIN,
    SPI_DATA INAi,
    L A LDrr,
    HL PUSH, ;CODE
CODE (spie) ( n -- ) 1 chkPS,
    HL POP, A L LDrr,
    SPI_CTL OUTiA, ;CODE
( ----- 315 )
( Z80 driver for TMS9918. Implements grid protocol. Requires
TMS_CTLPORT, TMS_DATAPORT and ~FNT from the Font compiler at
B520. Patterns are at addr 0x0000, Names are at 0x3800.
Load range B315-317 )
CODE _ctl ( a -- sends LSB then MSB ) 1 chkPS,
    HL POP,
    A L LDrr, TMS_CTLPORT OUTiA,
    A H LDrr, TMS_CTLPORT OUTiA,
;CODE
CODE _data 1 chkPS,
    HL POP, A L LDrr, TMS_DATAPORT OUTiA, ;CODE
( ----- 316 )
: _zero ( x -- send 0 _data x times )
    ( x ) 0 DO 0 _data LOOP ;
( Each row in ~FNT is a row of the glyph and there is 7 of
them.  We insert a blank one at the end of those 7. )
: _sfont ( a -- Send font to TMS )
    7 0 DO C@@+ _data LOOP DROP
    ( blank row ) 0 _data ;
: _sfont^ ( a -- Send inverted font to TMS )
    7 0 DO C@@+ 0xff XOR _data LOOP DROP
    ( blank row ) 0xff _data ;
: CELL! ( c pos )
    0x7800 OR _ctl ( tilenum )
    SPC - ( glyph ) 0x5f MOD _data ;
( ----- 317 )
: CURSOR! ( new old -- )
    DUP 0x3800 OR _ctl [ TMS_DATAPORT LITN ] PC@@
    0x7f AND ( new old glyph ) SWAP 0x7800 OR _ctl _data
    DUP 0x3800 OR _ctl [ TMS_DATAPORT LITN ] PC@@
    0x80 OR ( new glyph ) SWAP 0x7800 OR _ctl _data ;
: COLS 40 ; : LINES 24 ;
: TMS$
    0x8100 _ctl ( blank screen )
    0x7800 _ctl COLS LINES * _zero
    0x4000 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont LOOP
    0x4400 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont^ LOOP
    0x820e _ctl ( name table 0x3800 )
    0x8400 _ctl ( pattern table 0x0000 )
    0x87f0 _ctl ( colors 0 and 1 )
    0x8000 _ctl 0x81d0 _ctl ( text mode, display on ) ;
( ----- 320 )
( MC6850 Driver. Load range B320-B322. Requires:
  6850_CTL for control register
  6850_IO for data register.
  CTL numbers used: 0x16 = no interrupt, 8bit words, 1 stop bit
  64x divide. 0x56 = RTS high )
CODE 6850> 1 chkPS,
    HL POP,
    BEGIN,
        6850_CTL INAi, 0x02 ANDi, ( are we transmitting? )
    JRZ, ( yes, loop ) AGAIN,
    A L LDrr, 6850_IO OUTiA,
;CODE
( ----- 321 )
CODE 6850<?
    A XORr, ( 256x ) A 0x16 ( RTS lo ) LDri, 6850_CTL OUTiA,
    PUSH0, ( pre-push a failure )
    BEGIN, EXAFAF', ( preserve cnt )
        6850_CTL INAi, 0x1 ANDi, ( rcv buff full? )
        IFNZ, ( full )
            HL POP, ( pop failure )
            6850_IO INAi, PUSHA, PUSH1, A XORr, ( end loop )
        ELSE, EXAFAF', ( recall cnt ) A DECr, THEN,
    JRNZ, AGAIN,
    A 0x56 ( RTS hi ) LDri, 6850_CTL OUTiA, ;CODEOFLW?
( ----- 322 )
X' 6850<? :* RX<? X' 6850<? :* (key?)
X' 6850> :* TX> X' 6850> :* (emit)
: 6850$ 0x56 ( RTS high ) [ 6850_CTL LITN ] PC! ;
( ----- 325 )
( Zilog SIO driver. Load range B325-328. Requires:
  SIOA_CTL for ch A control register SIOA_DATA for data
  SIOB_CTL for ch B control register SIOB_DATA for data )
CODE SIOA<?
    A XORr, ( 256x ) PUSH0, ( pre-push a failure )
    A 5 ( PTR5 ) LDri, SIOA_CTL OUTiA,
    A 0b01101000 ( RTS low ) LDri, SIOA_CTL OUTiA,
    BEGIN, EXAFAF', ( preserve cnt )
        SIOA_CTL INAi, 0x1 ANDi, ( rcv buff full? )
        IFNZ, ( full )
            HL POP, ( pop failure )
            SIOA_DATA INAi, PUSHA, PUSH1, A XORr, ( end loop )
        ELSE, EXAFAF', ( recall cnt ) A DECr, THEN,
    JRNZ, AGAIN,
    A 5 ( PTR5 ) LDri, SIOA_CTL OUTiA,
    A 0b01101010 ( RTS low ) LDri, SIOA_CTL OUTiA, ;CODEOFLW?
( ----- 326 )
CODE SIOA> 1 chkPS,
    HL POP,
    BEGIN,
        SIOA_CTL INAi, 0x04 ANDi, ( are we transmitting? )
    JRZ, ( yes, loop ) AGAIN,
    A L LDrr, SIOA_DATA OUTiA,
;CODE
CREATE _ ( init data ) 0x18 C, ( CMD3 )
    0x24 C, ( CMD2/PTR4 ) 0b11000100 C, ( WR4/64x/1stop/nopar )
    0x03 C, ( PTR3 ) 0b11000001 C, ( WR3/RXen/8char )
    0x05 C, ( PTR5 ) 0b01101010 C, ( WR5/TXen/8char/RTS )
    0x21 C, ( CMD2/PTR1 ) 0 C, ( WR1/Rx no INT )
: SIOA$ 9 0 DO _ I + C@@ [ SIOA_CTL LITN ] PC! LOOP ;
( ----- 327 )
CODE SIOB<? ( copy/paste of SIOA<? )
    A XORr, ( 256x ) PUSH0, ( pre-push a failure )
    A 5 ( PTR5 ) LDri, SIOB_CTL OUTiA,
    A 0b01101000 ( RTS low ) LDri, SIOB_CTL OUTiA,
    BEGIN, EXAFAF', ( preserve cnt )
        SIOB_CTL INAi, 0x1 ANDi, ( rcv buff full? )
        IFNZ, ( full )
            HL POP, ( pop failure )
            SIOB_DATA INAi, PUSHA, PUSH1, A XORr, ( end loop )
        ELSE, EXAFAF', ( recall cnt ) A DECr, THEN,
    JRNZ, AGAIN,
    A 5 ( PTR5 ) LDri, SIOB_CTL OUTiA,
    A 0b01101010 ( RTS low ) LDri, SIOB_CTL OUTiA, ;CODEOFLW?
( ----- 328 )
CODE SIOB> 1 chkPS,
    HL POP,
    BEGIN,
        SIOB_CTL INAi, 0x04 ANDi, ( are we transmitting? )
    JRZ, ( yes, loop ) AGAIN,
    A L LDrr, SIOB_DATA OUTiA,
;CODE
: SIOB$ 9 0 DO _ I + C@@ [ SIOB_CTL LITN ] PC! LOOP ;
( ----- 330 )
( VDP Driver. see doc/hw/sms/vdp.txt. Load range B330-B332. )
CREATE _idat
0b00000100 C, 0x80 C, ( Bit 2: Select mode 4 )
0b00000000 C, 0x81 C,
0b00001111 C, 0x82 C, ( Name table: 0x3800, *B0 must be 1* )
0b11111111 C, 0x85 C, ( Sprite table: 0x3f00 )
0b11111111 C, 0x86 C, ( sprite use tiles from 0x2000 )
0b11111111 C, 0x87 C, ( Border uses palette 0xf )
0b00000000 C, 0x88 C, ( BG X scroll )
0b00000000 C, 0x89 C, ( BG Y scroll )
0b11111111 C, 0x8a C, ( Line counter (why have this?) )
( ----- 331 )
: _sfont ( a -- Send font to VDP )
  7 0 DO C@@+ _data 3 _zero LOOP DROP
  ( blank row ) 4 _zero ;
: CELL! ( c pos )
  2 * 0x7800 OR _ctl ( c )
  0x20 - ( glyph ) 0x5f MOD _data ;
( ----- 332 )
: CURSOR! ( new old -- )
  ( unset palette bit in old tile )
  2 * 1+ 0x7800 OR _ctl 0 _data
  ( set palette bit for at specified pos )
  2 * 1+ 0x7800 OR _ctl 0x8 _data ;
: VDP$
  9 0 DO _idat I 2 * + @@ _ctl LOOP
  ( blank screen ) 0x7800 _ctl COLS LINES * 2 * _zero
  ( palettes )
  0xc000 _ctl
  ( BG ) 1 _zero 0x3f _data 14 _zero
  ( sprite, inverted colors ) 0x3f _data 15 _zero
  0x4000 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont LOOP
  ( bit 6, enable display, bit 7, ?? ) 0x81c0 _ctl ;
: COLS 32 ; : LINES 24 ;
( ----- 335 )
( SMS pad driver. See doc/hw/z80/sms/pad.txt.
  Load range: 335-338 )
: _prevstat [ PAD_MEM LITN ] ;
: _sel [ PAD_MEM 1+ LITN ] ;
: _next [ PAD_MEM 2 + LITN ] ;
: _status ( -- n, see doc )
  1 _THA! ( output, high/unselected )
  _D1@@ 0x3f AND ( low 6 bits are good )
( Start and A are returned when TH is selected, in bits 5 and
  4. Well get them, left-shift them and integrate them to B. )
  0 _THA! ( output, low/selected )
  _D1@@ 0x30 AND 2 LSHIFT OR ;
( ----- 336 )
: _chk ( c --, check _sel range )
  _sel C@@ DUP 0x7f > IF 0x20 _sel C! THEN
  0x20 < IF 0x7f _sel C! THEN ;
CREATE _ '0' C, ':' C, 'A' C, '[' C, 'a' C, 0xff C,
: _nxtcls
  _sel @@ >R _ BEGIN ( a R:c ) C@@+ I > UNTIL ( a R:c ) R> DROP
  1- C@@ _sel ! ;
( ----- 337 )
: _updsel ( -- f, has an action button been pressed? )
  _status _prevstat C@@ OVER = IF DROP 0 EXIT THEN
  DUP _prevstat C! ( changed, update ) ( s )
  0x01 ( UP ) OVER AND NOT IF 1 _sel +! THEN
  0x02 ( DOWN ) OVER AND NOT IF -1 _sel +! THEN
  0x04 ( LEFT ) OVER AND NOT IF -5 _sel +! THEN
  0x08 ( RIGHT ) OVER AND NOT IF 5 _sel +! THEN
  0x10 ( BUTB ) OVER AND NOT IF _nxtcls THEN
  ( update sel in VDP )
  _chk _sel C@@ XYPOS @@ CELL!
  ( return whether any of the high 3 bits is low )
  0xe0 AND 0xe0 < ;
( ----- 338 )
: (key?) ( -- c? f )
  _next C@@ IF _next C@@ 0 _next C! 1 EXIT THEN
  _updsel IF
    _prevstat C@@
    0x20 ( BUTC ) OVER AND NOT IF DROP _sel C@@ 1 EXIT THEN
    0x40 ( BUTA ) AND NOT IF 0x8 ( BS ) 1 EXIT THEN
    ( If not BUTC or BUTA, it has to be START )
    0xd _next C! _sel C@@ 1
    ELSE 0 ( f ) THEN ;
: PAD$ 0xff _prevstat C! 'a' _sel C! 0 _next C! ;
( ----- 340 )
( kbd - implement (ps2kc) for SMS PS/2 adapter )
: (ps2kcA) ( for port A )
( Before reading a character, we must first verify that there
is something to read. When the adapter is finished filling its
'164 up, it resets the latch, which output's is connected to
TL. When the '164 is full, TL is low. Port A TL is bit 4 )
  _D1@@ 0x10 AND IF 0 EXIT ( nothing ) THEN
  0 _THA! ( Port A TH output, low )
  _D1@@ ( bit 3:0 go in 3:0 ) 0x0f AND ( n )
  1 _THA! ( Port A TH output, high )
  _D1@@ ( bit 3:0 go in 7:4 ) 0x0f AND 4 LSHIFT OR ( n )
  2 _THA! ( TH input ) ;
( ----- 341 )
: (ps2kcB) ( for port B )
  ( Port B TL is bit 2 )
  _D2@@ 0x04 AND IF 0 EXIT ( nothing ) THEN
  0 _THB! ( Port B TH output, low )
  _D1@@ ( bit 7:6 go in 1:0 ) 6 RSHIFT ( n )
  _D2@@ ( bit 1:0 go in 3:2 ) 0x03 AND 2 LSHIFT OR ( n )
  1 _THB! ( Port B TH output, high )
  _D1@@ ( bit 7:6 go in 5:4 ) 0xc0 AND 2 RSHIFT OR ( n )
  _D2@@ ( bit 1:0 go in 7:6 ) 0x03 AND 6 LSHIFT OR ( n )
  2 _THB! ( TH input ) ;
( ----- 347 )
: (spie) DROP ; ( always enabled )
CODE (spix) ( x -- x, for port B ) 1 chkPS, HL POP,
    ( TR = DATA TH = CLK )
    CPORT_MEM LDA(i), 0xf3 ANDi, ( TR/TH output )
    H 8 LDri, BEGIN,
        0xbf ANDi, ( TR lo ) L RL, ( --> C )
        IFC, 0x40 ORi, ( TR hi ) THEN,
        CPORT_CTL OUTiA, ( clic! ) 0x80 ORi, ( TH hi )
        CPORT_CTL OUTiA, ( clac! )
        EXAFAF', CPORT_D1 INAi, ( Up Btn is B6 ) RLA, RLA,
            E RL, EXAFAF',
        0x7f ANDi, ( TH lo ) CPORT_CTL OUTiA, ( cloc! )
    H DECr, JRNZ, AGAIN, CPORT_MEM LD(i)A,
    L E LDrr, HL PUSH,
;CODE
( ----- 348 )
( Routines for interacting with SMS controller ports.
  Requires CPORT_MEM, CPORT_CTL, CPORT_D1 and CPORT_D2 to be
  defined. CPORT_MEM is a 1 byte buffer for CPORT_CTL. The last
  3 consts will usually be 0x3f, 0xdc, 0xdd. )
( mode -- set TR pin on mode a on:
0= output low 1=output high 2=input )
CODE _TRA! 1 chkPS, HL POP, ( B0 -> B4, B1 -> B0 )
    L RR, RLA, RLA, RLA, RLA, L RR, RLA,
    0x11 ANDi, L A LDrr, CPORT_MEM LDA(i),
    0xee ANDi, L ORr, CPORT_CTL OUTiA, CPORT_MEM LD(i)A,
;CODE
CODE _THA! 1 chkPS, HL POP, ( B0 -> B5, B1 -> B1 )
    L RR, RLA, RLA, RLA, RLA, L RR, RLA, RLA,
    0x22 ANDi, L A LDrr, CPORT_MEM LDA(i),
    0xdd ANDi, L ORr, CPORT_CTL OUTiA, CPORT_MEM LD(i)A,
;CODE
( ----- 349 )
CODE _TRB! 1 chkPS, HL POP, ( B0 -> B6, B1 -> B2 )
    L RR, RLA, RLA, RLA, RLA, L RR, RLA, RLA, RLA,
    0x44 ANDi, L A LDrr, CPORT_MEM LDA(i),
    0xbb ANDi, L ORr, CPORT_CTL OUTiA, CPORT_MEM LD(i)A,
;CODE
CODE _THB! 1 chkPS, HL POP, ( B0 -> B7, B1 -> B3 )
    L RR, RLA, RLA, RLA, RLA, L RR, RLA, RLA, RLA, RLA,
    0x88 ANDi, L A LDrr, CPORT_MEM LDA(i),
    0x77 ANDi, L ORr, CPORT_CTL OUTiA, CPORT_MEM LD(i)A,
;CODE
CODE _D1@@ CPORT_D1 INAi, PUSHA, ;CODE
CODE _D2@@ CPORT_D2 INAi, PUSHA, ;CODE
( ----- 350 )
( TI-84+ LCD driver. See doc/hw/z80/ti84/lcd.txt
  Load range: 350-353 )
: _mem+ [ LCD_MEM LITN ] @@ + ;
: FNTW 3 ; : FNTH 5 ;
: COLS 96 FNTW 1+ / ; : LINES 64 FNTH 1+ / ;
( Wait until the lcd is ready to receive a command. It's a bit
  weird to implement a waiting routine in asm, but the forth
  version is a bit heavy and we don't want to wait longer than
  we have to. )
CODE _wait
  BEGIN,
    0x10 ( CMD ) INAi,
    RLA, ( When 7th bit is clr, we can send a new cmd )
  JRC, AGAIN, ;CODE
( ----- 351 )
: LCD_BUF 0 _mem+ ;
: _cmd 0x10 ( CMD ) PC! _wait ;
: _data! 0x11 ( DATA ) PC! _wait ;
: _data@@ 0x11 ( DATA ) PC@@ _wait ;
: LCDOFF 0x02 ( CMD_DISABLE ) _cmd ;
: LCDON 0x03 ( CMD_ENABLE ) _cmd ;
: _yinc 0x07 _cmd ; : _xinc 0x05 _cmd ;
: _zoff! ( off -- ) 0x40 + _cmd ;
: _col! ( col -- ) 0x20 + _cmd ;
: _row! ( row -- ) 0x80 + _cmd ;
: LCD$
  HERE [ LCD_MEM LITN ] ! FNTH 2 * ALLOT
  LCDON 0x01 ( 8-bit mode ) _cmd FNTH 1+ _zoff!  ;
( ----- 352 )
: _clrrows ( n u -- Clears u rows starting at n )
  SWAP _row! ( u ) 0 DO
    _yinc 0 _col!
    11 0 DO 0 _data! LOOP
    _xinc 0 _data! LOOP ;
: NEWLN ( ln -- )
  DUP 1+ FNTH 1+ * _zoff!
  FNTH 1+ * FNTH 1+ _clrrows ;
: LCDCLR 0 64 _clrrows ;
( ----- 353 )
: _atrow! ( pos -- ) COLS / FNTH 1+ * _row! ;
: _tocol ( pos -- col off ) COLS MOD FNTW 1+ * 8 /MOD ;
: CELL! ( c pos -- )
  DUP _atrow! DUP _tocol _col! ROT ( pos coff c )
  0x20 - FNTH * ~FNT + ( pos coff a )
  _xinc _data@@ DROP
  FNTH 0 DO ( pos coff a )
    OVER 8 -^ SWAP C@@+ ( pos coff 8-coff a+1 c ) ROT LSHIFT
    _data@@ 8 LSHIFT OR
    LCD_BUF I + 2DUP FNTH + C!
    SWAP 8 RSHIFT SWAP C!
  LOOP 2DROP
  DUP _atrow!
  FNTH 0 DO LCD_BUF I + C@@ _data! LOOP
  DUP _atrow! _tocol NIP 1+ _col!
  FNTH 0 DO LCD_BUF FNTH + I + C@@ _data! LOOP ;
( ----- 355 )
( Requires KBD_MEM, KBD_PORT. Load range: 355-359 )
( gm -- pm, get pressed keys mask for group mask gm )
CODE _get 1 chkPS,
    HL POP,
    DI,
        A 0xff LDri,
        KBD_PORT OUTiA,
        A L LDrr,
        KBD_PORT OUTiA,
        KBD_PORT INAi,
    EI,
    L A LDrr, HL PUSH,
;CODE
( ----- 356 )
( wait until all keys are de-pressed. To avoid repeat keys, we
  require 64 subsequent polls to indicate all depressed keys.
  all keys are considered depressed when the 0 group returns
  0xff. )
: _wait 64 BEGIN 0 _get 0xff = NOT IF DROP 64 THEN
    1- DUP NOT UNTIL DROP ;
( digits table. each row represents a group. 0 means
  unsupported. no group 7 because it has no key. )
CREATE _dtbl
    0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
    0xd C, '+' C, '-' C, '*' C, '/' C, '^' C, 0 C, 0 C,
    0 C, '3' C, '6' C, '9' C, ')' C, 0 C, 0 C, 0 C,
    '.' C, '2' C, '5' C, '8' C, '(' C, 0 C, 0 C, 0 C,
    '0' C, '1' C, '4' C, '7' C, ',' C, 0 C, 0 C, 0 C,
    0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0x80 ( alpha ) C,
    0 C, 0 C, 0 C, 0 C, 0 C, 0x81 ( 2nd ) C, 0 C, 0x7f C,
( ----- 357 )
( alpha table. same as _dtbl, for when we're in alpha mode. )
CREATE _atbl
    0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
    0xd C, '"' C, 'W' C, 'R' C, 'M' C, 'H' C, 0 C, 0 C,
    '?' C, 0 C, 'V' C, 'Q' C, 'L' C, 'G' C, 0 C, 0 C,
    ':' C, 'Z' C, 'U' C, 'P' C, 'K' C, 'F' C, 'C' C, 0 C,
    0x20 C, 'Y' C, 'T' C, 'O' C, 'J' C, 'E' C, 'B' C, 0 C,
    0 C, 'X' C, 'S' C, 'N' C, 'I' C, 'D' C, 'A' C, 0x80 C,
    0 C, 0 C, 0 C, 0 C, 0 C, 0x81 ( 2nd ) C, 0 C, 0x7f C,
: _@@ [ KBD_MEM LITN ] C@@ ; : _! [ KBD_MEM LITN ] C! ;
: _2nd@@ _@@ 1 AND ; : _2nd! _@@ 0xfe AND + _! ;
: _alpha@@ _@@ 2 AND ; : _alpha! 2 * _@@ 0xfd AND + _! ;
: _alock@@ _@@ 4 AND ; : _alock^ _@@ 4 XOR _! ;
( ----- 358 )
: _gti ( -- tindex, that it, index in _dtbl or _atbl )
    7 0 DO
        1 I LSHIFT 0xff -^ ( group dmask ) _get
        DUP 0xff = IF DROP ELSE I ( dmask gid ) LEAVE THEN
    LOOP _wait
    SWAP ( gid dmask )
    0xff XOR ( dpos ) 0 ( dindex )
    BEGIN 1+ 2DUP RSHIFT NOT UNTIL 1-
    ( gid dpos dindex ) NIP
    ( gid dindex ) SWAP 8 * + ;
( ----- 359 )
: (key?) ( -- c? f )
    0 _get 0xff = IF ( no key pressed ) 0 EXIT THEN
    _alpha@@ _alock@@ IF NOT THEN IF _atbl ELSE _dtbl THEN
    _gti + C@@ ( c )
    DUP 0x80 = IF _2nd@@ IF _alock^ ELSE 1 _alpha! THEN THEN
    DUP 0x81 = _2nd!
    DUP 1 0x7f =><= IF ( we have something )
    ( lower? ) _2nd@@ IF DUP 'A' 'Z' =><= IF 0x20 OR THEN THEN
        0 _2nd! 0 _alpha! 1 ( c f )
    ELSE ( nothing ) DROP 0 THEN ;
: KBD$ 0 [ KBD_MEM LITN ] C! ;
( ----- 360 )
( TRS-80 4P drivers. Load range: 360-367 )
L1 BSET ( brkchk ) A 0x6a ( @@CKBRKC ) LDri, 0x28 RST, CZ RETc,
  ( brk pressed, QUIT ) HL POP, 0x0c BJP, ( stable ABI QUIT )
CODE (key?)
  L1 @@ CALL, ( brkchk )
  A 0x08 LDri, ( @@KBD ) 0x28 RST,
  IFZ, 0xb1 CPi, IFZ, A '|' LDri, THEN,
  0xad CPi, IFZ, A '~' LDri, THEN,
  PUSHA, PUSH1, ELSE, PUSH0, THEN, ;CODEOFLW?
CODE (emit) 1 chkPS, EXX, ( protect BC )
  BC POP, ( c == @@DSP arg )
  A 0x02 LDri, ( @@DSP ) 0x28 RST,
EXX, ( unprotect BC ) ;CODE
( ----- 361 )
CODE AT-XY 2 chkPS, EXX, ( protect BC )
  DE POP, H E LDrr, ( Y )
  DE POP, L E LDrr, ( X )
  A 0x0f LDri, ( @@VDCTL ) B 3 LDri, ( setcur )
  0x28 RST,
EXX, ( unprotect BC ) ;CODE
24 CONSTANT LINES 80 CONSTANT COLS
DRVMEM CONSTANT XYMODE
: CELL! COLS /MOD AT-XY (emit) ;
CODE BYE HL 0 LDdi, A 0x16 LDri, ( @@EXIT ) 0x28 RST,
( ----- 362 )
CODE @@RDSEC ( drv cylsec addr -- f ) 3 chkPS,
  EXX, ( protect BC ) HL POP, DE POP, BC POP,
  A 0x31 LDri, ( @@RDSEC ) 0x28 RST, PUSHZ,
EXX, ( unprotect BC ) ;CODE
CODE @@WRSEC ( drv cylsec addr -- f ) 3 chkPS,
  EXX, ( protect BC ) HL POP, DE POP, BC POP,
  A 0x35 LDri, ( @@WRSEC ) 0x28 RST, PUSHZ,
EXX, ( unprotect BC ) ;CODE
( ----- 363 )
CODE @@DCSTAT ( drv -- f ) 1 chkPS, EXX, ( protect BC )
  BC POP,
  A 0x28 LDri, ( @@DCSTAT ) 0x28 RST, PUSHZ,
EXX, ( unprotect BC ) ;CODE
: FD0 FLUSH 0 [ DRVMEM 1+ LITN ] C! ;
: FD1 FLUSH 1 [ DRVMEM 1+ LITN ] C! ;
: FDDRV [ DRVMEM 1+ LITN ] C@@ ;
: _err LIT" FDerr" ERR ;
( ----- 364 )
: _cylsec ( sec -- cs, return sector/cylinder for given secid )
  ( 4 256b sectors per block, 10 sec per cyl, 40 cyl max )
  10 /MOD ( sec cyl ) DUP 39 > IF _err THEN
  8 LSHIFT + ( cylsec ) ;
: FD@@! ( wref blk -- )
  1 @@DCSTAT NOT IF _err THEN
  SWAP >R 2 LSHIFT ( sec=blk*4 -- sec R:wr )
  4 0 DO ( sec R:wr )
    DUP I + _cylsec ( sec cs )
    I 8 LSHIFT BLK( + ( sec cs addr )
    FDDRV ROT> ( sec drv cs addr )
    J ( wr ) EXECUTE NOT IF _err THEN
  LOOP R> 2DROP ;
: FD@@ ['] @@RDSEC SWAP FD@@! ;
: FD! ['] @@WRSEC SWAP FD@@! ;
: FD$ ['] FD@@ ['] BLK@@* **! ['] FD! ['] BLK!* **! FD1 ;
( ----- 365 )
: CL$ ( baudcode -- )
0x02 0xe8 PC! ( UART RST ) DUP 4 LSHIFT OR 0xe9 PC! ( bauds )
  0b01101101 0xea PC! ( word8 no parity no-RTS ) ;
CODE TX> 1 chkPS, HL POP,
  BEGIN, L1 ( brkchk ) @@ CALL,
    0xea INAi, 0x40 ANDi, IFNZ, ( TX reg empty )
      0xe8 INAi, 0x80 ANDi, IFZ, ( CTS low )
        A L LDrr, 0xeb OUTiA, ( send byte ) ;CODE
  THEN, THEN, JR, AGAIN,
( ----- 366 )
CODE RX<?
  L1 ( brkchk ) @@ CALL,
  A XORr, ( 256x ) PUSH0, ( pre-push a failure )
  A 0b01101100 ( RTS low ) LDri, 0xea OUTiA,
  BEGIN, EXAFAF', ( preserve cnt )
    0xea INAi, 0x80 ANDi, ( rcv buff full? )
    IFNZ, ( full )
      HL POP, ( pop failure )
      0xeb INAi, PUSHA, PUSH1, A XORr, ( end loop )
    ELSE, EXAFAF', ( recall cnt ) A DECr, THEN,
  JRNZ, AGAIN,
  A 0b01101101 ( RTS high ) LDri, 0xea OUTiA, ;CODEOFLW?
( ----- 367 )
( Native KBD driver. doesnt work well with TRSDOS in mem )
L1 BSET A (HL) LDrr, L SLA, A ORr, RET,
L2 BSET BEGIN, E INCr, RRA, JRNC, AGAIN, A E LDrr, RET,
L3 BSET A 4 LDri, 0x84 OUTiA, ( mmap 1 )
  HL 0x3801 LDdi, L1 @@ CALL, IFNZ, E '@@' 1- LDri, L2 @@ CALL,
  ELSE, ( 02 ) L1 @@ CALL, IFNZ, E 'G' LDri, L2 @@ CALL,
  ELSE, ( 04 ) L1 @@ CALL, IFNZ, E 'O' LDri, L2 @@ CALL,
  ELSE, ( 08 ) L1 @@ CALL, 7 ANDi, IFNZ, E 'W' LDri, L2 @@ CALL,
  ELSE, ( 10 ) L1 @@ CALL, IFNZ, E '/' LDri, L2 @@ CALL,
  ELSE, ( 20 ) L1 @@ CALL, IFNZ, E '7' LDri, L2 @@ CALL,
    '<' CPi, IFNC, 0x10 SUBi, THEN,
  ELSE, ( 40 ) A (HL) LDrr, 0xa5 ANDi, IFNZ,
    RLA, IFC, A SPC LDri, ELSE, RLA, RLA, IFC, A BS LDri,
    ELSE, RLA, RLA, RLA, IFC, A 0x80 LDri,
    ELSE, A CR LDri, THEN, THEN, THEN,
  THEN, THEN, THEN, THEN, THEN, THEN, THEN, ( A = key or 0 )
( ----- 368 )
  A ORr, IFNZ, ( keypress )
  L 0x80 LDri, E (HL) LDrr,
  E RR, IFC, ( L shift )
    0x30 CPi, IFC, 0x10 ORi, ELSE, 0x20 ORi,
    0x60 CPi, IFC, 0xef ANDi, THEN, THEN,
  ELSE, E RR, IFC, ( R shift ) '@@' CPi, IFZ, 0x1f ADDi, ELSE,
     0x2f ADDi, 0x61 CPi, IFNC, 0x14 ADDi, THEN, THEN, THEN,
  THEN, THEN, A ORr, ( ensure correct Z )
  EXAFAF', A 7 LDri, 0x84 OUTiA, ( mmap 4 ) EXAFAF', RET,
( kbd memory is flaky. it sometimes returns garbage. To ensure
  reliable results, we poll twice and compare. )
CODE (key?)
  L3 @@ CALL, IFZ, PUSH0, ELSE, D A LDrr, L3 @@ CALL, D CPr,
    IFZ, PUSHA, PUSH1, BEGIN, L3 @@ CALL, JRNZ, AGAIN,
    ELSE, PUSH0, THEN, THEN, ;CODEOFLW?
( ----- 400 )
( 8086 boot code. PS=SP, RS=BP, IP=DX
  Load range. decl: B400 code: B402-B417 )
VARIABLE lblexec
: chkPS, ( sz -- ) 2 * PS_ADDR -^ 1+ SP SWAP CMPxI, IFNC,
  ( underflow ) DI 0x06 MOVxm, JMPn, lblexec @@ RPCn, THEN, ;
( replace ;CODE with ;CODEOFLW? for words that need it. )
: ;CODEOFLW?
  BP SP CMPxx, IFNC, ( BP >= SP )
    SP PS_ADDR MOVxI, BP RS_ADDR MOVxI,
    DI 0x13 ( oflw ) MOVxm, JMPn, lblexec @@ RPCn, THEN,
  ;CODE ;
( ----- 402 )
HERE ORG !
JMPn, 0 , ( 00, main ) 0 C, ( 03, boot driveno )
8 ALLOT0 JMPn, 0 , ( 0c QUIT ) 6 ALLOT0
( End of Stable ABI )
lblnext BSET PC ORG @@ 0xf + ! ( Stable ABI )
    DI DX MOVxx, ( <-- IP ) DX INCx, DX INCx,
    DI [DI] x[] MOV[], ( wordref )
    ( continue to execute )
( ----- 403 )
lblexec BSET ( DI -> wordref )
AL [DI] r[] MOV[], DI INCx, ( PFA )
AL AL ORrr, IFZ, DI JMPr, THEN, ( native )
AL DECr, IFNZ, ( not compiled )
AL DECr, IFZ, ( cell ) DI PUSHx, JMPs, lblnext @@ RPCs, THEN,
AL DECr, IFNZ, ( NOT does ) DI [DI] x[] MOV[], ( rd PFA )
  AL DECr, IFZ, ( alias ) lblexec @@ RPCs, THEN,
  AL DECr, IFZ, ( ialias )
    DI [DI] x[] MOV[], JMPs, lblexec @@ RPCs, THEN,
  AL DECr, IFZ, ( const ) DI PUSHx, JMPs, lblnext @@ RPCs, THEN,
THEN, ( does )
DI INCx, DI INCx, DI PUSHx, DI [DI] -2 x[]+ MOV[],
THEN, ( continue to compiled )
( ----- 404 )
( compiled ) BP INCx, BP INCx, [BP] 0 DX []+x MOV[], ( pushRS )
( ovfl check ) BP SP CMPxx, IFNC, ( BP >= SP )
  SP PS_ADDR MOVxI, BP RS_ADDR MOVxI,
  DI 0x13 ( oflw ) MOVxm, JMPs, lblexec @@ RPCs, THEN,
DX DI MOVxx, DX INCx, DX INCx, ( --> IP )
DI [DI] x[] MOV[], JMPs, lblexec @@ RPCs,
PC 3 - ORG @@ 1+ ! ( main )
    DX POPx, ( boot drive no ) 0x03 DL MOVmr,
    SP PS_ADDR MOVxI, BP RS_ADDR MOVxI,
    DI 0x08 MOVxm, ( LATEST )
( HERE begins at CURRENT )
    SYSVARS 0x4 ( HERE ) + DI MOVmx,
    SYSVARS 0x2 ( CURRENT ) + DI MOVmx,
    DI 0x04 ( BOOT ) MOVxm,
    JMPn, lblexec @@ RPCn,
( ----- 405 )
( native words )
HERE 4 + XCURRENT ! ( make next CODE have 0 prev field )
CODE (br) L1 BSET ( used in ?br )
    DI DX MOVxx, AL [DI] r[] MOV[], AH AH XORrr, CBW,
    DX AX ADDxx,
;CODE
CODE (?br) 1 chkPS,
    AX POPx, AX AX ORxx, JZ, L1 @@ RPCs, ( False, branch )
    ( True, skip next byte and don't branch )
    DX INCx,
;CODE
( ----- 406 )
CODE (loop)
    [BP] 0 [w]+ INC[], ( I++ )
    ( Jump if I <> I' )
    AX [BP] 0 x[]+ MOV[], AX [BP] -2 x[]+ CMP[],
    JNZ, L1 @@ RPCs, ( branch )
    ( don't branch )
    BP 4 SUBxi, DX INCx,
;CODE
( ----- 407 )
CODE EXECUTE 1 chkPS,
    DI POPx, JMPn, lblexec @@ RPCn,
CODE QUIT
PC 0xf - ORG @@ 0xd + ! ( Stable ABI )
L1 BSET ( used in ABORT )
    BP RS_ADDR MOVxI,
    DI 0x0a ( main ) MOVxm,
    JMPn, lblexec @@ RPCn,
CODE ABORT SP PS_ADDR MOVxI, JMPs, L1 @@ RPCs,
CODE EXIT
    DX [BP] 0 x[]+ MOV[], BP DECx, BP DECx, ( popRS )
;CODE
( ----- 408 )
CODE (n) ( number literal )
    DI DX MOVxx, DI [DI] x[] MOV[], DI PUSHx,
    DX INCx, DX INCx, ;CODEOFLW?
CODE (b) ( byte literal )
    DI DX MOVxx, AH AH XORrr, AL [DI] r[] MOV[], AX PUSHx,
    DX INCx, ;CODEOFLW?
CODE (s) ( string literal, see B287 )
    DI DX MOVxx, ( IP )
    AH AH XORrr, AL [DI] r[] MOV[], ( slen )
    DX PUSHx, DX INCx, DX AX ADDxx, ;CODEOFLW?
( ----- 409 )
CODE >R 1 chkPS,
    BP INCx, BP INCx, [BP] 0 [w]+ POP[],
;CODE NOP, NOP, NOP,
CODE R>
    [BP] 0 [w]+ PUSH[], BP DECx, BP DECx,
;CODE
CODE 2>R
    [BP] 4 [w]+ POP[], [BP] 2 [w]+ POP[], BP 4 ADDxi,
;CODE
CODE 2R> 2 chkPS,
    [BP] -2 [w]+ PUSH[], [BP] 0 [w]+ PUSH[], BP 4 SUBxi,
;CODE
( ----- 410 )
CODE ROT ( a b c -- b c a ) 3 chkPS,
    CX POPx, BX POPx, AX POPx,
    BX PUSHx, CX PUSHx, AX PUSHx, ;CODE
CODE ROT> ( a b c -- c a b ) 3 chkPS,
    CX POPx, BX POPx, AX POPx,
    CX PUSHx, AX PUSHx, BX PUSHx, ;CODE
CODE DUP 1 chkPS, AX POPx, AX PUSHx, AX PUSHx, ;CODEOFLW?
CODE ?DUP 1 chkPS, AX POPx, AX AX ORxx, AX PUSHx,
    IFNZ, AX PUSHx, THEN, ;CODEOFLW?
CODE OVER ( a b -- a b a ) 2 chkPS,
    DI SP MOVxx, AX [DI] 2 x[]+ MOV[], AX PUSHx, ;CODEOFLW?
( ----- 411 )
CODE SWAP AX POPx, BX POPx, AX PUSHx, BX PUSHx, ;CODE
CODE DROP 1 chkPS, AX POPx, ;CODE
CODE 2DROP 2 chkPS, SP 4 ADDxi, ;CODE
CODE 2DUP 2 chkPS,
    AX POPx, BX POPx,
    BX PUSHx, AX PUSHx, BX PUSHx, AX PUSHx,
;CODEOFLW?
CODE AND 2 chkPS,
    AX POPx, BX POPx, AX BX ANDxx, AX PUSHx, ;CODE
( ----- 412 )
CODE OR 2 chkPS,
    AX POPx, BX POPx, AX BX ORxx, AX PUSHx, ;CODE
CODE XOR 2 chkPS,
    AX POPx, BX POPx, AX BX XORxx, AX PUSHx, ;CODE
CODE NOT 1 chkPS,
    AX POPx, AX AX ORxx,
    IFNZ, AX -1 MOVxI, THEN, AX INCx, AX PUSHx, ;CODE
CODE + 2 chkPS,
    AX POPx, BX POPx, AX BX ADDxx, AX PUSHx, ;CODE
CODE - 2 chkPS,
    BX POPx, AX POPx, AX BX SUBxx, AX PUSHx, ;CODE
CODE * 2 chkPS,
    AX POPx, BX POPx,
    DX PUSHx, ( protect from MUL ) BX MULx, DX POPx,
    AX PUSHx, ;CODE
( ----- 413 )
CODE /MOD 2 chkPS,
    BX POPx, AX POPx, DX PUSHx, ( protect )
    DX DX XORxx, BX DIVx,
    BX DX MOVxx, DX POPx, ( unprotect )
    BX PUSHx, ( modulo ) AX PUSHx, ( division )
;CODE
CODE ! 2 chkPS, DI POPx, AX POPx, [DI] AX []x MOV[], ;CODE
CODE @@ 1 chkPS, DI POPx, AX [DI] x[] MOV[], AX PUSHx, ;CODE
CODE C! 2 chkPS, DI POPx, AX POPx, [DI] AX []r MOV[], ;CODE
CODE C@@ 1 chkPS,
    DI POPx, AH AH XORrr, AL [DI] r[] MOV[], AX PUSHx, ;CODE
CODE I [BP] 0 [w]+ PUSH[], ;CODEOFLW?
CODE I' [BP] -2 [w]+ PUSH[], ;CODEOFLW?
CODE J [BP] -4 [w]+ PUSH[], ;CODEOFLW?
( ----- 414 )
CODE BYE HLT, BEGIN, JMPs, AGAIN,
CODE []= ( a1 a2 u -- f ) 3 chkPS,
    CX POPx, SI POPx, DI POPx, CLD, REPZ, CMPSB,
    PUSHZ, ;CODE
CODE = 2 chkPS, BX POPx, AX POPx, AX BX CMPxx, PUSHZ, ;CODE
CODE < 2 chkPS, BX POPx, AX POPx, CX CX XORxx,
    AX BX CMPxx, IFC, CX INCx, THEN, CX PUSHx, ;CODE
CODE > 2 chkPS, BX POPx, AX POPx, CX CX XORxx,
    BX AX CMPxx, IFC, CX INCx, THEN, CX PUSHx, ;CODE
( ----- 415 )
CODE FIND ( w -- a f ) 1 chkPS,
  SI POPx, ( w ) DI SYSVARS 0x2 ( CURRENT ) + MOVxm,
  CH CH XORrr, CL [SI] r[] MOV[], ( CX -> strlen )
  SI INCx, ( first char ) AX AX XORxx, ( initial prev )
  BEGIN, ( loop )
    DI AX SUBxx, ( jump to prev wordref )
    AL [DI] -1 r[]+ MOV[], 0x7f ANDALi, ( strlen )
    CL AL CMPrr, IFZ, ( same len )
      SI PUSHx, DI PUSHx, CX PUSHx, ( --> )
        3 ADDALi, ( header ) AH AH XORrr, DI AX SUBxx,
        CLD, REPZ, CMPSB,
      CX POPx, DI POPx, SI POPx, ( <-- )
      IFZ, DI PUSHx, AX 1 MOVxI, AX PUSHx, ;CODEOFLW? THEN,
    THEN,
  DI 3 SUBxi, AX [DI] x[] MOV[], ( prev ) AX AX ORxx,
  JNZ, AGAIN, ( loop ) ( cont. )
( ----- 416 )
( cont. FIND )
  SI DECx, SI PUSHx, AX AX XORrr, AX PUSHx, ;CODEOFLW?
CODE 1+ 1 chkPS, DI SP MOVxx, [DI] [w] INC[], ;CODE
CODE 1- 1 chkPS, DI SP MOVxx, [DI] [w] DEC[], ;CODE
CODE RSHIFT ( n u -- n ) 2 chkPS,
    CX POPx, AX POPx, AX SHRxCL, AX PUSHx, ;CODE
CODE LSHIFT ( n u -- n ) 2 chkPS,
    CX POPx, AX POPx, AX SHLxCL, AX PUSHx, ;CODE
( ----- 417 )
( See comment in B300. TODO: test on real hardware. in qemu,
  the resulting delay is more than 10x too long. )
CODE TICKS 1 chkPS, ( n=100us )
    SI DX MOVxx, ( protect IP )
    AX POPx, BX 100 MOVxI, BX MULx,
    CX DX MOVxx, ( high ) DX AX MOVxx, ( low )
    AX 0x8600 MOVxI, ( 86h, WAIT ) 0x15 INT,
    DX SI MOVxx, ( restore IP )
;CODE
CODE |M ( n -- lsb msb ) 1 chkPS,
    CX POPx, AH 0 MOVri,
    AL CL MOVrr, AX PUSHx, AL CH MOVrr, AX PUSHx, ;CODEOFLW?
CODE |L ( n -- msb lsb ) 1 chkPS,
    CX POPx, AH 0 MOVri,
    AL CH MOVrr, AX PUSHx, AL CL MOVrr, AX PUSHx, ;CODEOFLW?
( ----- 420 )
( PC/AT drivers. Load range: 420-426 )
CODE (emit) 1 chkPS,
    AX POPx, AH 0x0e MOVri, ( print char ) 0x10 INT,
;CODE
CODE (key?)
    AH AH XORrr, 0x16 INT, AH AH XORrr, AX PUSHx, AX PUSHx,
;CODEOFLW?
( ----- 421 )
CODE 13H08H ( driveno -- cx dx )
    DI POPx, DX PUSHx, ( protect ) DX DI MOVxx, AX 0x800 MOVxI,
    ES PUSHs, DI DI XORxx, ES DI MOVsx,
    0x13 INT, DI DX MOVxx, ES POPs, DX POPx, ( unprotect )
    CX PUSHx, DI PUSHx,
;CODEOFLW?
CODE 13H ( ax bx cx dx -- ax bx cx dx )
    SI POPx, ( DX ) CX POPx, BX POPx, AX POPx,
    DX PUSHx, ( protect ) DX SI MOVxx, DI DI XORxx,
    0x13 INT, SI DX MOVxx, DX POPx, ( unprotect )
    AX PUSHx, BX PUSHx, CX PUSHx, SI PUSHx,
;CODE
( ----- 422 )
: FDSPT 0x70 RAM+ ;
: FDHEADS 0x71 RAM+ ;
: _ ( AX BX sec )
    ( AH=read sectors, AL=1 sector, BX=dest,
      CH=trackno CL=secno DH=head DL=drive )
    FDSPT C@@ /MOD ( AX BX sec trk )
    FDHEADS C@@ /MOD ( AX BX sec head trk )
    8 LSHIFT ROT OR 1+ ( AX BX head CX )
    SWAP 8 LSHIFT 0x03 C@@ ( boot drive ) OR ( AX BX CX DX )
    13H 2DROP 2DROP
;
( ----- 423 )
: FD@@
    2 * 16 + ( blkfs starts at sector 16 )
    DUP 0x0201 BLK( ROT _
    0x0201 BLK( 0x200 + ROT 1+ _ ;
: FD!
    2 * 16 + ( blkfs starts at sector 16 )
    DUP 0x0301 BLK( ROT _
    0x0301 BLK( 0x200 + ROT 1+ _ ;
: FD$
    ( get number of sectors per track with command 08H. )
    0x03 ( boot drive ) C@@ 13H08H
    8 RSHIFT 1+ FDHEADS C!
    0x3f AND FDSPT C!
;
( ----- 424 )
: COLS 80 ; : LINES 25 ;
CODE AT-XY ( x y )
    ( DH=row DL=col BH=page )
    AX POPx, BX POPx, DX PUSHx, ( protect )
    DH AL MOVrr, DL BL MOVrr, BX BX XORxx, AH 2 MOVri,
    0x10 INT, DX POPx, ( unprotect )
;CODE
( ----- 450 )
( 6809 declarations )
VARIABLE lblexec VARIABLE lbluflw VARIABLE lbloflw
: chkPS, ( n ) 2 * PS_ADDR -^ 1+ # CMPS, LBHS, lbluflw BBR, ;
: ;CODEOFLW?
  0 <> STS, 0 <> CMPU, LBLO, lblnext BBR, LBRA, lbloflw BBR, ;
( ----- 451 )
( 6809 Boot code. IP=Y, PS=S, RS=U  ) HERE ORG !
BRA, FBR, L1 ! ( main ) 0x0a ALLOT0 BRA, FBR, L2 ! ( QUIT )
7 ALLOT0 ( end of stable ABI )
lblnext BSET Y++ LDX,
lblexec BSET ( X=wordref )
  X+0 TST, IFZ, 1 X+N JMP, THEN, ( fast path for native )
  X+ LDA, DECA, IFNZ, ( not compiled )
    DECA, IFZ, ( cell ) PSHS, X ( PFA ) BRA, lblnext BBR, THEN,
    DECA, IFNZ, ( not does: alias, ialias or const )
      X+0 LDX, DECA, BEQ, lblexec BBR, ( alias )
      DECA, IFZ, ( ialias ) X+0 LDX, BRA, lblexec BBR, THEN,
      ( const ) PSHS, X BRA, lblnext BBR, THEN, ( does )
    X++ LDD, PSHS, X ( PFA ) D X TFR, ( X=DOES> addr )
  THEN, ( compiled )
  U++ STY, 0 <> STS, 0 <> CMPU, BHS, FBR, L3 ! ( oflw )
  X Y TFR, Y++ TST, X+0 LDX, BRA, lblexec BBR,
( ----- 452 )
lbluflw BSET BIN( @@ 0x06 + () LDX, BRA, lblexec BBR,
lbloflw BSET L3 FSET RS_ADDR # LDU, PS_ADDR # LDS,
  BIN( @@ 0x13 + () LDX, BRA, lblexec BBR,
L1 FSET ( main ) PS_ADDR # LDS, RS_ADDR # LDU,
BIN( @@ 8 + () LDX, SYSVARS 0x02 ( CURRENT ) + () STX,
HERESTART # LDX, SYSVARS 0x04 ( HERE ) + () STX,
BIN( @@ 4 + ( BOOT ) () LDX, BRA, lblexec BBR,
HERE 4 + XCURRENT ! ( make next prev 0 )
CODE QUIT L1 BSET ( for ABORT ) L2 FSET RS_ADDR # LDU,
  BIN( @@ 0x0a + ( main ) () LDX, BRA, lblexec BBR,
CODE EXECUTE 1 chkPS, PULS, X LBRA, lblexec BBR,
CODE ABORT PS_ADDR # LDS, BRA, L1 ( QUIT ) BBR,
CODE BYE BEGIN, BRA, AGAIN,
CODE EXIT --U LDY, ;CODE
( ----- 453 )
CODE (b) Y+ LDB, CLRA, PSHS, D ;CODEOFLW?
CODE (n) Y++ LDD, PSHS, D ;CODEOFLW?
CODE (s) PSHS, Y Y+ LDB, Y+B LEAY, ;CODEOFLW?
CODE (br) Y+0 LDA, Y+A LEAY, ;CODE
CODE (?br) 1 chkPS, S+ LDA, S+ ORA,
  IFZ, Y+0 LDA, Y+A LEAY, ELSE, Y+ TST, THEN, ;CODE
CODE (loop) -2 U+N LDD, INCB, IFZ, INCA, THEN, -4 U+N CMPD,
  IFZ, ( exit loop ) --U TST, --U TST, Y+ TST,
  ELSE, ( loop ) -2 U+N STD, Y+0 LDA, Y+A LEAY, THEN, ;CODE
( ----- 454 )
CODE DROP 1 chkPS, 2 S+N LEAS, ;CODE
CODE 2DROP 2 chkPS, 4 S+N LEAS, ;CODE
CODE DUP ( a -- a a ) 1 chkPS, S+0 LDD, PSHS, D ;CODEOFLW?
CODE ?DUP ( a -- a? a ) 1 chkPS,
  S+0 LDD, IFNZ, PSHS, D THEN, ;CODEOFLW?
CODE 2DUP ( a b -- a b a b ) 2 chkPS,
  2 S+N LDD, PSHS, D 2 S+N LDD, PSHS, D ;CODEOFLW?
CODE SWAP ( a b -- b a ) 2 chkPS,
  S+0 LDD, 2 S+N LDX, S+0 STX, 2 S+N STD, ;CODE
CODE OVER ( a b -- a b a ) 2 chkPS,
  2 S+N LDD, PSHS, D ;CODEOFLW?
CODE ROT ( a b c -- b c a ) 3 chkPS,
  4 S+N LDX, ( a ) 2 S+N LDD, ( b ) 4 S+N STD, S+0 LDD, ( c )
  2 S+N STD, S+0 STX, ;CODE
( ----- 455 )
CODE ROT> ( a b c -- c a b ) 3 chkPS,
  S+0 LDX, ( c ) 2 S+N LDD, ( b ) S+0 STD, 4 S+N LDD, ( a )
  2 S+N STD, 4 S+N STX, ;CODE
CODE R> --U LDD, PSHS, D ;CODE
CODE >R 1 chkPS, PULS, D U++ STD, ;CODE
CODE 2R> --U LDD, --U LDX, PSHS, XD ;CODE
CODE 2>R 2 chkPS, PULS, XD U++ STX, U++ STD, ;CODE
CODE I -2 U+N LDD, PSHS, D ;CODEOFLW?
CODE I' -4 U+N LDD, PSHS, D ;CODEOFLW?
CODE J -6 U+N LDD, PSHS, D ;CODEOFLW?
CODE @@ 1 chkPS, [S+0] LDD, S+0 STD, ;CODE
CODE C@@ 1 chkPS, [S+0] LDB, CLRA, S+0 STD, ;CODE
CODE ! 2 chkPS, PULS, X PULS, D X+0 STD, ;CODE
CODE C! 2 chkPS, PULS, X PULS, D X+0 STB, ;CODE
( ----- 456 )
CODE AND 2 chkPS, PULS, D S+0 ANDA, 1 S+N ANDB, S+0 STD, ;CODE
CODE OR 2 chkPS, PULS, D S+0 ORA, 1 S+N ORB, S+0 STD, ;CODE
CODE XOR 2 chkPS, PULS, D S+0 EORA, 1 S+N EORB, S+0 STD, ;CODE
CODE + 2 chkPS, PULS, D S+0 ADDD, S+0 STD, ;CODE
CODE - 2 chkPS, 2 S+N LDD, S++ SUBD, S+0 STD, ;CODE
CODE 1+ 1 chkPS, 1 S+N INC, LBNE, lblnext BBR, S+0 INC, ;CODE
CODE 1- 1 chkPS,
  1 S+N TST, IFZ, S+0 DEC, THEN, 1 S+N DEC, ;CODE
CODE LSHIFT ( n u -- n ) 2 chkPS,
  PULS, D TSTB, IFNZ, BEGIN,
    1 S+N LSL, S+0 ROL, DECB, BNE, AGAIN, THEN, ;CODE
CODE RSHIFT ( n u -- n ) 2 chkPS,
  PULS, D TSTB, IFNZ, BEGIN,
    S+0 LSR, 1 S+N ROR, DECB, BNE, AGAIN, THEN, ;CODE
( ----- 457 )
CODE /MOD ( a b -- a/b a%b ) 2 chkPS,
  16 # LDA, 0 <> STA, CLRA, CLRB, ( D=running rem ) BEGIN,
    1 # ORCC, 3 S+N ROL, ( a lsb ) 2 S+N ROL, ( a msb )
    ROLB, ROLA, S+0 SUBD,
    IF<, S+0 ADDD, 3 S+N DEC, ( a lsb ) THEN,
  0 <> DEC, BNE, AGAIN,
  2 S+N LDX, 2 S+N STD, ( rem ) S+0 STX, ( quotient ) ;CODE
CODE * ( a b -- a*b ) 2 chkPS,
  S+0 ( bm ) LDA, 3 S+N ( al ) LDB, MUL, S+0 ( bm ) STB,
  2 S+N ( am ) LDA, 1 S+N ( bl ) LDB, MUL,
    S+0 ( bm ) ADDB, S+0 STB,
  1 S+N ( al ) LDA, 3 S+N ( bl ) LDB, MUL,
  S++ ADDA, S+0 STD, ;CODE
( ----- 458 )
L4 BSET ( PUSH Z ) CCR B TFR, LSRB, LSRB,
  1 # ANDB, CLRA, S+0 STD, ;CODE
CODE = 2 chkPS, PULS, D S+0 CMPD, BRA, L4 ( PUSH Z ) BBR,
CODE NOT 1 chkPS, S+0 LDB, 1 S+N ORB, BRA, L4 ( PUSH Z ) BBR,
L4 BSET ( PUSH C ) CCR B TFR, 1 # ANDB, CLRA, S+0 STD, ;CODE
CODE > 2 chkPS, PULS, D S+0 CMPD, BRA, L4 ( PUSH C ) BBR,
CODE < ( inv args ) 2 chkPS,
  2 S+N LDD, S++ CMPD, BRA, L4 ( PUSHC ) BBR,
CODE |L ( n -- msb lsb ) 1 chkPS,
  S+0 LDD, 1 S+N STA, S+0 CLR, CLRA, PSHS, D ;CODEOFLW?
CODE |M ( n -- lsb msb ) 1 chkPS,
  CLRA, S+0 LDB, S+0 CLR, PSHS, D ;CODEOFLW?
( ----- 459 )
L1 BSET ( X=s1 Y=s2 B=cnt ) BEGIN,
  X+ LDA, Y+ CMPA, IFNZ, RTS, THEN, DECB, BNE, AGAIN, RTS,
CODE []= ( a1 a2 u -- f TODO: allow u>0xff ) 3 chkPS,
  0 <> STY, PULS, DXY ( B=u, X=a2, Y=a1 ) L1 LPC () JSR,
  IFZ, 1 # LDD, ELSE, CLRA, CLRB, THEN, PSHS, D 0 <> LDY, ;CODE
CODE FIND ( w -- a f ) 1 chkPS,
  SYSVARS 0x02 + ( CURRENT ) () LDX, 0 <> STY, BEGIN,
    -X LDB, 0x7f # ANDB, --X TST, [S+0] CMPB, IF=,
      2 <> STX, S+0 LDY, Y+ LDA, NEGA, X+A LEAX, L1 LPC () JSR,
      IFZ, ( match ) 0 <> LDY, 2 <> LDD, 3 # ADDD, S+0 STD,
        1 # LDD, PSHS, D ;CODEOFLW? THEN,
      2 <> LDX, THEN, ( nomatch, X=prev )
    X+0 LDD, IFZ, ( stop ) 0 <> LDY, PSHS, D ;CODE THEN,
    X D TFR, X+0 SUBD, D X TFR, BRA, AGAIN,
( ----- 460 )
6809 drivers

461 TRS-80 Color Computer 2
( ----- 461 )
( CoCo2 drivers. Load range: 461-463 )
PC ," @@HPX08" CR C, ," AIQY19" 0 C,
   ," BJRZ2:" 0 C,  ," CKS_3;" 0 C,
   ," DLT_4," 0 C,  ," EMU" BS C, ," 5-" 0 C,
   ," FNV_6." 0 C,  ," GOW 7/" 0 C,
   ," @@hpx0(" CR C, ," aiqy!)" 0 C,
   ," bjrz" '"' C, '*' C, 0 C, ," cks_#+" 0 C,
   ," dlt_$<" 0 C,  ," emu" BS C, ," %=" 0 C,
   ," fnv_&>" 0 C,  ," gow '?" 0 C,
L1 BSET ( PC ) # LDX, 0xfe # LDA, BEGIN, ( 8 times )
  0xff02 () STA, ( set col ) 0xff00 () LDB, ( read row )
  ( ignore 8th row ) 0x80 # ORB, 0x7f # CMPA, IF=,
    ( ignore shift row ) 0x40 # ORB, THEN,
  INCB, IFNZ, ( key pressed ) DECB, RTS, THEN,
  ( inc col ) 7 X+N LEAX, 1 # ORCC, ROLA, BCS, AGAIN,
  ( no key ) CLRB, RTS,
( ----- 462 )
CODE (key?) ( -- c? f ) CLRA, CLRB, PSHS, D L1 LPC () JSR,
  IFNZ, ( key! row mask in B col ptr in X )
    ( is shift pressed? ) 0x7f # LDA, 0xff02 () STA,
    0xff00 () LDA, 0x40 # ANDA, IFZ, ( shift! )
      56 X+N LEAX, THEN,
    BEGIN, X+ LDA, LSRB, BCS, AGAIN,
    ( A = our char ) 1 S+N STA, TSTA, IFNZ, ( valid key )
      1 # LDD, ( f ) PSHS, D ( wait for keyup )
      BEGIN, L1 LPC () JSR, BNE, AGAIN, THEN,
  THEN, ;CODEOFLW?
( ----- 463 )
32 CONSTANT COLS 16 CONSTANT LINES
: CELL! ( c pos -- )
  SWAP 0x20 - DUP 0x5f < IF
    DUP 0x20 < IF 0x60 + ELSE DUP 0x40 < IF 0x20 + ELSE 0x40 -
      THEN THEN ( pos glyph )
    SWAP 0x400 + C! ELSE 2DROP THEN ;
: CURSOR! ( new old -- )
  DROP 0x400 + DUP C@@ 0x40 XOR SWAP C! ;
@


1.93
log
@VE: refactor a little bit
@
text
@d2917 1
a2917 1
VARIABLE lblexec VARIABLE lbluflw
d2919 2
a2920 1
( TODO: add ;CODEOFLW? )
d2925 1
a2925 2
lblnext BSET Y++ LDX, 0 <> STS, 0 <> CMPU, IF>=,
  RS_ADDR # LDU, PS_ADDR # LDS, BIN( @@ 0x13 + () LDX, THEN,
d2936 2
a2937 1
  U++ STY, X Y TFR, Y++ TST, X+0 LDX, BRA, lblexec BBR,
d2940 2
d2949 1
a2949 1
CODE EXECUTE 1 chkPS, PULS, X BRA, lblexec BBR,
d2954 3
a2956 3
CODE (b) Y+ LDB, CLRA, PSHS, D ;CODE
CODE (n) Y++ LDD, PSHS, D ;CODE
CODE (s) PSHS, Y Y+ LDB, Y+B LEAY, ;CODE
d2958 1
a2958 1
CODE (?br) S+ LDA, S+ ORA,
d2966 1
a2966 1
CODE DUP ( a -- a a ) 1 chkPS, S+0 LDD, PSHS, D ;CODE
d2968 1
a2968 1
  S+0 LDD, IFNZ, PSHS, D THEN, ;CODE
d2970 1
a2970 1
  2 S+N LDD, PSHS, D 2 S+N LDD, PSHS, D ;CODE
d2973 2
a2974 1
CODE OVER ( a b -- a b a ) 2 chkPS, 2 S+N LDD, PSHS, D ;CODE
d2978 1
a2981 1
( ----- 455 )
d2986 3
a2988 3
CODE I -2 U+N LDD, PSHS, D ;CODE
CODE I' -4 U+N LDD, PSHS, D ;CODE
CODE J -6 U+N LDD, PSHS, D ;CODE
d3032 1
a3032 1
  S+0 LDD, 1 S+N STA, S+0 CLR, CLRA, PSHS, D ;CODE
d3034 1
a3034 1
  CLRA, S+0 LDB, S+0 CLR, PSHS, D ;CODE
d3046 1
a3046 1
        1 # LDD, PSHS, D ;CODE THEN,
d3081 1
a3081 1
  THEN, ;CODE
@


1.92
log
@8086: check for stack overflow less often
@
text
@d607 4
a610 2
: _cpos ( pos -- a ) BLK( + ;
: _lpos ( ln -- a ) 64 * _cpos ;
d613 1
a613 1
        I EDPOS @@ _cpos = IF '^' EMIT THEN
d624 1
a624 1
: P IBUF _type IBUF EDPOS @@ _cpos 64 MOVE BLK!! ;
d633 1
a633 1
    15 EDPOS @@ 64 / - ?DUP IF
d640 1
a640 1
    FBUF EDPOS @@ _cpos 1+ ( a1 a2 )
d648 1
a648 1
: F FBUF _type _F EDPOS @@ 64 / _pln ;
d653 1
a653 1
    EDPOS @@ 64 MOD 63 -^ ;
d655 2
a656 2
    EDPOS @@ DUP 0xffc0 AND 2DUP = IF 2DROP EXIT THEN DO
    I _cpos DUP C@@ SPC < IF SPC SWAP C! ELSE DROP THEN LOOP ;
d660 1
a660 1
        >R EDPOS @@ _cpos 2DUP + ( ilen a a+ilen R:ctm )
d663 2
a664 2
    DUP IBUF EDPOS @@ _cpos ROT MOVE ( ilen ) EDPOS +! BLK!! ;
: i IBUF _type _i EDPOS @@ 64 / _pln ;
d667 1
a667 1
    IBUF _zbuf EDPOS @@ _cpos IBUF ( n a buf ) ROT MOVE ;
d669 1
a669 1
    DUP icpy EDPOS @@ _cpos 2DUP + ( n a1 a1+n )
d672 1
a672 1
    DUP EDPOS @@ 0xffc0 AND 0x40 + -^ _cpos ( n a )
d674 1
a674 1
: X _X EDPOS @@ 64 / _pln ;
a686 1
: C@@- ( a -- a-1 c ) DUP C@@ SWAP 1- SWAP ;
d689 1
a689 1
: acc@@ ACC @@ 1 MAX ; : pos@@ ( x y -- ) EDPOS @@ 64 /MOD ;
d709 1
a709 1
: pos! ( newpos -- ) EDPOS @@ PREVPOS !
d717 1
a717 1
: cmv ( n -- , char movement ) acc@@ * EDPOS @@ + pos! ;
d738 3
a740 3
: $H EDPOS @@ 0x3c0 AND pos! ;
: $L EDPOS @@ DUP 0x3f OR 2DUP = IF 2DROP EXIT THEN SWAP BEGIN
    ( res p ) 1+ DUP _cpos C@@ WS? NOT IF NIP DUP 1+ SWAP THEN
d746 11
a756 12
: $w EDPOS @@ BLK( + acc@@ 0 DO
    BEGIN C@@+ WS? UNTIL BEGIN C@@+ WS? NOT UNTIL LOOP
    1- BLK( - pos! ;
: $W EDPOS @@ BLK( + acc@@ 0 DO
    1+ BEGIN C@@+ WS? NOT UNTIL BEGIN C@@+ WS? UNTIL LOOP
    2 - BLK( - pos! ;
: $b EDPOS @@ BLK( + acc@@ 0 DO
    1- BEGIN C@@- WS? NOT UNTIL BEGIN C@@- WS? UNTIL LOOP
    2 + BLK( - pos! ;
: $B EDPOS @@ BLK( + acc@@ 0 DO
    BEGIN C@@- WS? UNTIL BEGIN C@@- WS? NOT UNTIL LOOP
    1+ BLK( - pos! ;
d758 1
a758 1
: $f EDPOS @@ PREVPOS @@ 2DUP = IF 2DROP EXIT THEN
d761 1
a761 1
    SWAP _cpos FBUF ( len src dst ) ROT MOVE bufs ;
d766 1
a766 1
        DUP EMIT EDPOS @@ _cpos C! 1 EDPOS +! BLK!! 0
d768 2
a769 2
: $O _U EDPOS @@ 0x3c0 AND DUP pos! _cpos _zbuf BLK!! contents ;
: $o EDPOS @@ 0x3c0 < IF EDPOS @@ 64 + EDPOS ! $O THEN ;
d771 1
a771 1
    acc@@ 0 DO 16 EDPOS @@ 64 / DO I _mvln- LOOP LOOP
a773 1
: UPPER DUP 'a' 'z' =><= IF 32 - THEN ;
d777 1
a777 1
    0 ACC ! UPPER 'Q' = ;
@


1.91
log
@z80: check for stack overflow less often

Checking during next calls is too often. Instead, we check
at two kinds of places:

1. When entering a compiled word, after having pushed to RS
2. After the execution of a native word with a positive PS
   balance.
@
text
@d2652 6
a2663 6
    ( ovfl check )
    BP SP CMPxx,
    IFNC, ( BP >= SP )
        SP PS_ADDR MOVxI, BP RS_ADDR MOVxI,
        DI 0x13 ( oflw ) MOVxm, JMPs, L1 FWRs ( execute )
    THEN,
d2666 1
a2666 1
    ( continue to execute ) L1 FSET
d2681 5
a2685 1
BP INCx, BP INCx, [BP] 0 DX []+x MOV[], ( pushRS )
a2687 1
( ----- 404 )
d2704 1
a2704 1
CODE (?br)
d2734 1
a2734 1
    DX INCx, DX INCx, ;CODE
d2737 1
a2737 1
    DX INCx, ;CODE
d2741 1
a2741 1
    DX PUSHx, DX INCx, DX AX ADDxx, ;CODE
d2762 1
a2762 1
CODE DUP 1 chkPS, AX POPx, AX PUSHx, AX PUSHx, ;CODE
d2764 1
a2764 1
    IFNZ, AX PUSHx, THEN, ;CODE
d2766 1
a2766 1
    DI SP MOVxx, AX [DI] 2 x[]+ MOV[], AX PUSHx, ;CODE
d2774 1
a2774 1
;CODE
d2805 3
a2807 3
CODE I [BP] 0 [w]+ PUSH[], ;CODE
CODE I' [BP] -2 [w]+ PUSH[], ;CODE
CODE J [BP] -4 [w]+ PUSH[], ;CODE
d2809 1
a2809 1
CODE BYE HLT, BEGIN, JMPs, AGAIN, ;CODE
d2820 15
a2834 15
    SI POPx, ( w ) DI SYSVARS 0x2 ( CURRENT ) + MOVxm,
    CH CH XORrr, CL [SI] r[] MOV[], ( CX -> strlen )
    SI INCx, ( first char ) AX AX XORxx, ( initial prev )
    BEGIN, ( loop )
        DI AX SUBxx, ( jump to prev wordref )
        AL [DI] -1 r[]+ MOV[], 0x7f ANDALi, ( strlen )
        CL AL CMPrr, IFZ, ( same len )
            SI PUSHx, DI PUSHx, CX PUSHx, ( --> lvl 3 )
            3 ADDALi, ( header ) AH AH XORrr, DI AX SUBxx,
            CLD, REPZ, CMPSB,
            CX POPx, DI POPx, SI POPx, ( <-- lvl 3 )
            IFZ, DI PUSHx, AX 1 MOVxI, AX PUSHx,
                JMPn, lblnext @@ RPCn, THEN,
        THEN,
DI 3 SUBxi, AX [DI] x[] MOV[], ( prev ) AX AX ORxx, ( cont. )
d2836 2
a2837 3
( cont. find ) JNZ, AGAIN, ( loop )
    SI DECx, SI PUSHx, AX AX XORrr, AX PUSHx,
;CODE
d2856 1
a2856 1
    AL CL MOVrr, AX PUSHx, AL CH MOVrr, AX PUSHx, ;CODE
d2859 1
a2859 1
    AL CH MOVrr, AX PUSHx, AL CL MOVrr, AX PUSHx, ;CODE
d2867 1
a2867 1
;CODE
d2874 1
a2874 1
;CODE
d2920 1
@


1.90
log
@Remove unused C@@- and C!-

C@@- is used in VE and has been bubbled up there.
@
text
@d142 1
a142 3

: JPNEXT, lblnext@@ JP, ;
: ;CODE JPNEXT, ;
d146 1
a146 2
: BEGIN,
    PC DUP 0x8000 AND IF ABORT" PC must be < 0x8000" THEN ;
d162 1
a162 1
: AGAIN, PC - 1- C, ;
d1781 1
a1781 2
VARIABLE lblexec
CREATE lbluflw 0 ,
d1788 6
d1796 1
a1796 1
0 JP, ( 00, main ) NOP, ( unused ) NOP, NOP, ( 04, BOOT )
d1806 1
a1806 1
PC ORG @@ 1 + ! ( main )
d1813 1
a1813 3
HERESTART [IF]
  HL HERESTART LDdi,
[THEN]
d1816 1
a1816 2
  JR, L1 FWR ( execute, B284 )
( ----- 283 )
a1817 10
( This routine is jumped to at the end of every word. In it,
  we jump to current IP, but we also take care of increasing
  it by 2 before jumping. )
	( Before we continue: are we overflowing? )
  IX PUSH, EX(SP)HL, ( do EX to count the IX push in SP )
  SP SUBHLd, HL POP,
  IFNC, ( SP <= IX? overflow )
    SP PS_ADDR LDdi, IX RS_ADDR LDdi,
    BIN( @@ 0x13 ( oflw ) + LDHL(i),
    JR, L2 FWR ( execute, B284 ) THEN,
d1821 2
a1822 2
( ----- 284 )
lblexec BSET L1 FSET ( B282 ) L2 FSET ( B283 )
d1838 1
a1838 1
( ----- 285 )
d1843 3
d1847 1
a1847 2
  LDDE(HL), ( DE is new wordref )
  HL INCd, ( HL is new PFA+2 )
d1849 1
a1849 2
  EXDEHL, ( HL -> wordref )
  JR, lblexec BWR ( execute-B287 )
d1851 4
a1854 1
( ----- 286 )
d1862 1
a1862 1
  IFZ, PUSH0, JPNEXT, THEN,
d1867 1
a1867 1
( ----- 287 )
d1881 2
a1882 2
      PUSH1, JPNEXT, THEN,
( ----- 288 )
d1894 2
a1895 2
  PUSH0, ;CODE
( ----- 289 )
d1900 3
a1902 6
CODE (?br)
  HL POP, HLZ,
  JRZ, L1 BWR ( br + 1. False, branch )
  ( True, skip next byte and don't branch )
  BC INCd, ;CODE
( ----- 290 )
d1909 2
a1910 3
  IX DECd, IX DECd, IX DECd, IX DECd,
  BC INCd, ;CODE
( ----- 291 )
d1920 1
a1920 1
( ----- 292 )
d1924 1
a1924 1
  HL PUSH, ;CODE
d1927 1
a1927 1
  H 0 LDri, HL PUSH, ;CODE
d1930 2
a1931 2
  C A LDrr, BC INCd, ;CODE
( ----- 293 )
d1939 1
a1939 1
  HL POP, HL PUSH, HL PUSH, ;CODE
d1941 2
a1942 2
  HL POP, HL PUSH, HLZ, IFNZ, HL PUSH, THEN, ;CODE
( ----- 294 )
d1948 1
a1948 2
  DE PUSH, ( A ) HL PUSH, ( B ) DE PUSH, ( A ) ;CODE
( ----- 295 )
d1953 2
a1954 2
  DE PUSH, HL PUSH, ;CODE
( ----- 296 )
d1970 1
a1970 1
( ----- 297 )
d1981 1
a1981 1
( ----- 298 )
d1992 1
a1992 1
( ----- 299 )
d2002 1
a2002 1
    IFZ, ( 12t ) JPNEXT, THEN,
d2006 1
a2006 1
( ----- 300 )
d2020 1
a2020 1
( ----- 301 )
d2029 3
a2031 3
CODE I L 0 IX+ LDrIXY, H 1 IX+ LDrIXY, HL PUSH, ;CODE
CODE I' L 2 IX- LDrIXY, H 1 IX- LDrIXY, HL PUSH, ;CODE
CODE J L 4 IX- LDrIXY, H 3 IX- LDrIXY, HL PUSH, ;CODE
d2034 1
a2034 1
( ----- 302 )
d2046 1
a2046 1
( ----- 303 )
d2050 1
a2050 1
    IFNZ, PUSH0, EXX, JPNEXT, THEN,
d2059 1
a2059 1
( ----- 304 )
d2073 1
a2073 1
( ----- 305 )
d2084 1
a2084 1
( ----- 306 )
d2088 1
a2088 1
  E L LDrr, DE PUSH, ;CODE
d2092 1
a2092 1
  E H LDrr, DE PUSH, ;CODE
d2197 1
a2197 1
    A 0x56 ( RTS hi ) LDri, 6850_CTL OUTiA, ;CODE
d2218 1
a2218 1
    A 0b01101010 ( RTS low ) LDri, SIOA_CTL OUTiA, ;CODE
d2246 1
a2246 1
    A 0b01101010 ( RTS low ) LDri, SIOB_CTL OUTiA, ;CODE
d2539 1
a2539 1
  PUSHA, PUSH1, ELSE, PUSH0, THEN, ;CODE
d2598 1
a2598 1
        A L LDrr, 0xeb OUTiA, ( send byte ) JPNEXT,
d2612 1
a2612 1
  A 0b01101101 ( RTS high ) LDri, 0xea OUTiA, ;CODE
d2645 1
a2645 1
    ELSE, PUSH0, THEN, THEN, ;CODE
@


1.89
log
@6809 asm: fix broken [] addressing mode
@
text
@d688 1
d700 1
a701 1
( ----- 112 )
d716 1
a718 1
( ----- 113 )
a1010 2
: C@@- ( a -- a-1 c ) DUP C@@ SWAP 1- SWAP ;
: C!- ( c a -- a-1 ) TUCK C! 1- ;
@


1.88
log
@z80: optimize lblexec for speed

Use DE instead of HL as wordref argument. It makes native
and cell a tiny bit faster (one EXDEHL, saved) and the
rest is unchanged.

Before doing it, I thought I'd save a bit more, but now that
it's done...
@
text
@d458 1
a458 1
: [] ( n ) 0b10011111 3 0x20 ; ( Extended Indirect)
@


1.87
log
@z80: make chkPS, parametrizable and inlined
@
text
@d1806 1
a1806 1
    SP PS_ADDR LDdi, IX RS_ADDR LDdi,
d1810 2
a1811 2
    BIN( @@ 0x08 + LDHL(i),
    SYSVARS 0x02 ( CURRENT ) + LD(i)HL,
d1813 1
a1813 1
    HL HERESTART LDdi,
d1815 3
a1817 3
    SYSVARS 0x04 + LD(i)HL, ( +04 == HERE )
    DE BIN( @@ 0x04 ( BOOT ) + LDd(i),
    JR, L1 FWR ( execute, B287 )
d1824 9
a1832 10
    IX PUSH, EX(SP)HL, ( do EX to count the IX push in SP )
    SP SUBHLd, HL POP,
    IFNC, ( SP <= IX? overflow )
        SP PS_ADDR LDdi, IX RS_ADDR LDdi,
        DE BIN( @@ 0x13 ( oflw ) + LDd(i),
        JR, L2 FWR ( execute, B287 )
    THEN,
    LDA(BC), E A LDrr, BC INCd,
    LDA(BC), D A LDrr, BC INCd,
    ( continue to execute )
d1834 16
a1849 16
lblexec BSET L1 FSET ( B284 ) L2 FSET ( B286 )
    ( DE -> wordref )
    LDA(DE), DE INCd, EXDEHL, ( HL points to PFA )
    A ORr, IFZ, ( native ) JP(HL), THEN,
    A DECr, IFNZ, ( not compiled )
    A DECr, IFZ, ( cell )
        HL PUSH, ( PFA ) JR, lblnext BWR THEN,
    A DECr, IFNZ, ( not does: alias, ialias or const )
    LDDE(HL), ( read PFA )
    A DECr, JRZ, ( alias ) lblexec BWR
    A DECr, IFZ, ( ialias )
        EXDEHL, LDDE(HL), JR, lblexec BWR THEN,
    ( const ) DE PUSH, JR, lblnext BWR
    THEN, ( does )
    LDDE(HL), ( does addr ) HL INCd, HL PUSH, ( PFA ) EXDEHL,
    THEN, ( continue to compiledWord )
d1852 10
a1861 13
  execute now.
  1. Push current IP to RS
  2. Set new IP to PFA+2
  3. Execute wordref )
    IX INCd, IX INCd,
    0 IX+ C LDIXYr,
    1 IX+ B LDIXYr,
( While we inc, dereference into DE for execute call later. )
    LDDE(HL), ( DE is new wordref )
    HL INCd, ( HL is new PFA+2 )
    B H LDrr, C L LDrr, ( --> IP )
    JR, lblexec BWR ( execute-B287 )
lbluflw BSET DE BIN( @@ 0x06 ( uflw ) + LDd(i), JR, lblexec BWR
d1923 1
a1923 1
CODE EXECUTE 1 chkPS, DE POP, lblexec @@ JP,
d1926 1
a1926 1
  IX RS_ADDR LDdi, DE BIN( @@ 0x0a ( main ) + LDd(i),
@


1.86
log
@8086: inline chkPS,
@
text
@a142 2
CREATE lblchkPS 0 ,
: chkPS, lblchkPS @@ CALL, ; ( chkPS, B305 )
a293 1
VARIABLE lblchkPS
d1784 1
a1784 1
( Z80 boot code. See doc/code/z80.txt Load range: B281-B307 )
d1786 1
d1791 2
d1865 1
a1866 15
lblchkPS BSET ( chkPS )
    ( thread carefully in there: sometimes, we're in the
      middle of a EXX to protect BC. BC must never be touched
      here. )
    EXX,
( We have the return address for this very call on the stack
  and protected registers. 2 - is to compensate that. )
    HL PS_ADDR 2 - LDdi,
    SP SUBHLd,
    EXX,
    CNC RETc, ( PS_ADDR >= SP? good )
    ( underflow )
    DE BIN( @@ 0x06 ( uflw ) + LDd(i),
    JR, lblexec BWR
( ----- 287 )
d1869 1
a1869 1
CODE FIND  ( w -- a f )
d1871 1
a1871 1
  HL POP, ( w ) chkPS, HL PUSH, ( --> lvl 1 )
d1879 1
a1879 1
( ----- 288 )
d1894 1
a1894 1
( ----- 289 )
d1907 1
a1907 1
( ----- 290 )
d1917 1
a1917 1
( ----- 291 )
d1926 2
a1927 2
( ----- 292 )
CODE EXECUTE DE POP, chkPS, lblexec @@ JP,
d1936 1
a1936 1
( ----- 293 )
d1947 11
d1959 6
a1964 10
CODE ROT ( a b c -- b c a )
  HL POP, ( C ) DE POP, ( B ) IY POP, ( A ) chkPS,
  DE PUSH, ( B ) HL PUSH, ( C ) IY PUSH, ( A ) ;CODE
CODE ROT> ( a b c -- c a b )
  HL POP, ( C ) DE POP, ( B ) IY POP, ( A ) chkPS,
  HL PUSH, ( C ) IY PUSH, ( A ) DE PUSH, ( B ) ;CODE
CODE DUP ( a -- a a )
  HL POP, chkPS, HL PUSH, HL PUSH, ;CODE
CODE ?DUP
  HL POP, chkPS, HL PUSH, HLZ, IFNZ, HL PUSH, THEN, ;CODE
d1966 3
a1968 12
CODE DROP ( a -- )
  HL POP, chkPS, ;CODE
CODE SWAP ( a b -- b a )
  HL POP, ( B ) DE POP, ( A ) chkPS,
  HL PUSH, ( B ) DE PUSH, ( A ) ;CODE
CODE OVER ( a b -- a b a )
  HL POP, ( B ) DE POP, ( A ) chkPS,
  DE PUSH, ( A ) HL PUSH, ( B ) DE PUSH, ( A ) ;CODE
( ----- 296 )
CODE 2DROP ( a b -- ) HL POP, HL POP, chkPS, ;CODE
CODE 2DUP ( a b -- a b a b )
  HL POP, ( b ) DE POP, ( a ) chkPS,
d1971 3
a1973 3
( ----- 297 )
CODE AND
  HL POP, DE POP, chkPS,
d1977 2
a1978 2
CODE OR
  HL POP, DE POP, chkPS,
d1982 2
a1983 2
CODE XOR
  HL POP, DE POP, chkPS,
d1987 6
a1992 6
( ----- 298 )
CODE NOT HL POP, chkPS, HLZ, PUSHZ, ;CODE
CODE + HL POP, DE POP, chkPS, DE ADDHLd, HL PUSH, ;CODE
CODE - DE POP, HL POP, chkPS, DE SUBHLd, HL PUSH, ;CODE
CODE * EXX, ( protect BC ) ( DE * BC -> HL )
  DE POP, BC POP, chkPS,
d1998 1
a1998 1
( ----- 299 )
d2000 2
a2001 2
CODE /MOD EXX, ( protect BC )
  DE POP, BC POP, chkPS,
d2009 1
a2009 1
( ----- 300 )
d2014 2
a2015 2
CODE TICKS
  HL POP, chkPS,
d2023 3
a2025 3
( ----- 301 )
CODE !
    HL POP, DE POP, chkPS,
d2028 4
a2031 5
CODE @@
    HL POP, chkPS,
    LDDE(HL), DE PUSH, ;CODE
CODE C!
    HL POP, DE POP, chkPS,
d2033 2
a2034 2
CODE C@@
    HL POP, chkPS,
d2037 3
a2039 3
( ----- 302 )
CODE PC! EXX, ( protect BC )
    BC POP, HL POP, chkPS,
d2042 2
a2043 2
CODE PC@@ EXX, ( protect BC )
    BC POP, chkPS,
d2049 1
a2049 1
CODE >R HL POP, chkPS,
d2051 1
a2051 1
( ----- 303 )
d2055 2
a2056 2
CODE 2>R
  DE POP, HL POP, chkPS,
d2063 2
a2064 2
( ----- 304 )
CODE []= EXX, ( protect BC ) BC POP, DE POP, HL POP, chkPS,
d2070 2
a2071 2
CODE = DE POP, HL POP, chkPS, DE SUBHLd, PUSHZ, ;CODE
CODE < DE POP, HL POP, chkPS,
d2073 1
a2073 1
CODE > HL POP, DE POP, chkPS, ( inverted args )
d2076 4
a2079 6
( ----- 305 )
CODE 1+ HL POP, chkPS,
  HL INCd, HL PUSH, ;CODE
CODE 1- HL POP, chkPS,
  HL DECd, HL PUSH, ;CODE
CODE CRC16  ( c n -- c ) EXX, ( protect BC )
d2090 3
a2092 3
( ----- 306 )
CODE RSHIFT ( n u -- n )
  DE POP, ( u ) HL POP, ( n ) chkPS,
d2096 2
a2097 2
CODE LSHIFT ( n u -- n )
  DE POP, ( u ) HL POP, ( n ) chkPS,
d2101 3
a2103 3
( ----- 307 )
CODE |L ( n -- msb lsb )
  HL POP, chkPS,
d2106 2
a2107 2
CODE |M ( n -- lsb msb )
  HL POP, chkPS,
d2123 2
a2124 2
CODE AT28C! ( c a -- )
    HL POP, DE POP, chkPS,
d2137 2
a2138 2
CODE (spix) ( n -- n )
    HL POP, chkPS, A L LDrr,
d2145 2
a2146 2
CODE (spie) ( n -- )
    HL POP, chkPS, A L LDrr,
d2153 2
a2154 2
CODE _ctl ( a -- sends LSB then MSB )
    HL POP, chkPS,
d2158 2
a2159 4
CODE _data
    HL POP, chkPS,
    A L LDrr, TMS_DATAPORT OUTiA,
;CODE
d2196 2
a2197 2
CODE 6850>
    HL POP, chkPS,
d2237 2
a2238 2
CODE SIOA>
    HL POP, chkPS,
d2265 2
a2266 2
CODE SIOB>
    HL POP, chkPS,
d2379 1
a2379 1
CODE (spix) ( x -- x, for port B ) HL POP, chkPS,
d2400 1
a2400 1
CODE _TRA! HL POP, chkPS, ( B0 -> B4, B1 -> B0 )
d2405 1
a2405 1
CODE _THA! HL POP, chkPS, ( B0 -> B5, B1 -> B1 )
d2411 1
a2411 1
CODE _TRB! HL POP, chkPS, ( B0 -> B6, B1 -> B2 )
d2416 1
a2416 1
CODE _THB! HL POP, chkPS, ( B0 -> B7, B1 -> B3 )
d2482 1
a2482 1
CODE _get
a2483 1
    chkPS,
d2557 2
a2558 2
CODE (emit) EXX, ( protect BC )
  BC POP, ( c == @@DSP arg ) chkPS,
d2562 1
a2562 1
CODE AT-XY EXX, ( protect BC )
d2564 1
a2564 1
  DE POP, L E LDrr, ( X ) chkPS,
d2573 2
a2574 2
CODE @@RDSEC ( drv cylsec addr -- f ) EXX, ( protect BC )
  HL POP, DE POP, BC POP, chkPS,
d2577 2
a2578 2
CODE @@WRSEC ( drv cylsec addr -- f ) EXX, ( protect BC )
  HL POP, DE POP, BC POP, chkPS,
d2582 2
a2583 2
CODE @@DCSTAT ( drv -- f ) EXX, ( protect BC )
  BC POP, chkPS,
d2611 1
a2611 1
CODE TX> HL POP, chkPS,
@


1.85
log
@Remove barely used word IMMED?
@
text
@d254 4
a257 2
: MOVri, SWAP 0xb0 OR C, C, ;
: MOVxI, SWAP 0xb8 OR C, T, ;
a296 2
: chkPS, ( sz -- )
    CX SWAP 2 * MOVxI, CALL, lblchkPS @@ RPCn, ;
d2686 5
a2690 25
8086 boot code

Code in the following blocks assemble into a binary that is
suitable to plug into Core words (B210) to achieve a fully
functional Collapse OS. It is structured in a way that is
very similar to Z80 boot code (B280) and requires the same
constants to be pre-declared.

RESERVED REGISTERS: SP is reserved for PSP, BP is for RSP and
DX is for IP. Whenever you use these registers for another
purpose, be sure to protect their initial value. Like with
Z80, you can use SP freely in native code, but you have to make
sure it goes back to its previous level before next is called.


                                                        (cont.)
( ----- 401 )
PS CHECKS: chkPS, is a bit different than in z80: it is para-
metrizable. The idea is that we always call chkPS, before pop-
ping, telling the expected size of stack. This allows for some
interesting optimization. For example, in SWAP, no need to pop,
chkPS, then push, we can chkPS and then proceed to optimized
swapping in PS.

Load range: B402-B417
a2691 1
VARIABLE lblexec
a2723 6
lblchkPS BSET ( CX -> expected size )
    AX PS_ADDR MOVxI, AX SP SUBxx, 2 SUBAXI, ( CALL adjust )
    AX CX CMPxx,
    IFNC, ( we're good ) RET, THEN,
    ( underflow ) DI 0x06 MOVxm, JMPs, lblexec @@ RPCs,

@


1.84
log
@xcomp: Add XWRAP"
@
text
@d973 2
a974 4
    (xentry) 1 ( compiled ) C,
    BEGIN
    WORD DUP LIT" ;" S= IF
        DROP EXIT* @@ T, EXIT THEN
d976 5
a980 6
        DUP IMMED? IF ABORT" immed!" THEN _xapply T,
    ELSE ( w )
        FIND ( a f )
        IF DUP IMMED? NOT IF ABORT THEN EXECUTE
        ELSE (parse) XLITN THEN
    THEN AGAIN ;
a1148 1
: IMMED? 1- C@@ 0x80 AND ;
d1298 6
a1303 6
    (entry) 1 ( compiled ) C,
    BEGIN
        WORD DUP LIT" ;" S= IF DROP COMPILE EXIT EXIT THEN
        FIND IF ( is word ) DUP IMMED? IF EXECUTE ELSE , THEN
        ELSE ( maybe number ) (parse) LITN THEN
    AGAIN ;
@


1.83
log
@asm: remove BREAK,

Too complex and hackish for what it's worth. It was only
implemented in z80 asm so far, and only used in one place.
Forward labels work fine.
@
text
@d958 1
@


1.82
log
@6809 isn't WIP any more
@
text
@d167 1
a167 5
: BREAK, FJR, 0x8000 OR ;
: BREAK?, DUP 0x8000 AND IF
        0x7fff AND 1 ALLOT THEN, -1 ALLOT
    THEN ;
: AGAIN, BREAK?, PC - 1- C, ;
a285 1
( TODO: add BREAK, )
d288 1
a288 1
: AGAIN, ( BREAK?, ) RPCs, ;
a591 1
( TODO: implement BREAK, )
d1905 2
a1906 2
        JRNZ, BREAK,
      DJNZ, AGAIN, THEN,
@


1.81
log
@6809: complete the port!

- Add stack underflow/overflow detection
- Implement QUIT and ABORT
- coco2: add SHIFT support to (key?)
- coco2: implement grid protocol
@
text
@d16 1
a16 1
450 6809 boot code (WIP)      460 6809 drivers
@


1.80
log
@6809 asm: check for 8-bit branching overflows
@
text
@d2990 10
a2999 6
( 6809 Boot code WIP. IP=Y, PS=S, RS=U  )
HERE ORG !
BRA, FBR, L1 ! ( main ) 0x13 ALLOT0
lblnext BSET
  Y++ LDX,
L2 ( exec ) BSET ( X=wordref )
d3004 2
a3005 2
      X+0 LDX, DECA, BEQ, L2 ( exec ) BBR, ( alias )
      DECA, IFZ, ( ialias ) X+0 LDX, BRA, L2 BBR, THEN,
d3009 3
a3011 2
  U++ STY, X Y TFR, Y++ TST, X+0 LDX, BRA, L2 ( exec ) BBR,
( ----- 451 )
d3015 1
a3015 1
BIN( @@ 4 + ( BOOT ) () LDX, BRA, L2 ( exec ) BBR,
d3017 5
d3023 1
a3023 5
CODE EXECUTE PULS, X BRA, L2 ( exec ) BBR,
CODE BYE BEGIN, BRA, AGAIN,
CODE QUIT ( TODO ) ;CODE
CODE ABORT ( TODO ) ;CODE
( ----- 452 )
d3033 7
a3039 6
( ----- 453 )
CODE DROP S++ TST, ;CODE
CODE 2DROP S++ TST, S++ TST, ;CODE
CODE DUP ( a -- a a ) S+0 LDD, PSHS, D ;CODE
CODE ?DUP ( a -- a? a ) S+0 LDD, IFNZ, PSHS, D THEN, ;CODE
CODE 2DUP ( a b -- a b a b )
d3041 1
a3041 1
CODE SWAP ( a b -- b a )
d3043 2
a3044 2
CODE OVER ( a b -- a b a ) 2 S+N LDD, PSHS, D ;CODE
CODE ROT ( a b c -- b c a )
d3047 1
a3047 1
CODE ROT> ( a b c -- c a b )
d3050 1
a3050 1
( ----- 454 )
d3052 1
a3052 1
CODE >R PULS, D U++ STD, ;CODE
d3054 1
a3054 1
CODE 2>R PULS, XD U++ STX, U++ STD, ;CODE
d3058 14
a3071 14
CODE @@ [S+0] LDD, S+0 STD, ;CODE
CODE C@@ [S+0] LDB, CLRA, S+0 STD, ;CODE
CODE ! PULS, X PULS, D X+0 STD, ;CODE
CODE C! PULS, X PULS, D X+0 STB, ;CODE
( ----- 455 )
CODE AND PULS, D S+0 ANDA, 1 S+N ANDB, S+0 STD, ;CODE
CODE OR PULS, D S+0 ORA, 1 S+N ORB, S+0 STD, ;CODE
CODE XOR PULS, D S+0 EORA, 1 S+N EORB, S+0 STD, ;CODE
CODE + ( a b -- a+b ) PULS, D S+0 ADDD, S+0 STD, ;CODE
CODE - ( a b -- a-b )
  2 S+N LDD, S++ SUBD, S+0 STD, ;CODE
CODE 1+ 1 S+N INC, LBNE, lblnext BBR, S+0 INC, ;CODE
CODE 1- 1 S+N TST, IFZ, S+0 DEC, THEN, 1 S+N DEC, ;CODE
CODE LSHIFT ( n u -- n )
d3074 1
a3074 1
CODE RSHIFT ( n u -- n )
d3077 2
a3078 2
( ----- 456 )
CODE /MOD ( a b -- a/b a%b )
d3085 1
a3085 1
CODE * ( a b -- a*b )
d3091 1
a3091 1
( ----- 457 )
d3094 2
a3095 2
CODE = PULS, D S+0 CMPD, BRA, L4 ( PUSH Z ) BBR,
CODE NOT S+0 LDB, 1 S+N ORB, BRA, L4 ( PUSH Z ) BBR,
d3097 4
a3100 3
CODE > PULS, D S+0 CMPD, BRA, L4 ( PUSH C ) BBR,
CODE < ( inv args ) 2 S+N LDD, S++ CMPD, BRA, L4 ( PUSHC ) BBR,
CODE |L ( n -- msb lsb )
d3102 1
a3102 1
CODE |M ( n -- lsb msb )
d3104 1
a3104 1
( ----- 458 )
d3107 1
a3107 1
CODE []= ( a1 a2 u -- f TODO: allow u>0xff )
d3110 1
a3110 1
CODE FIND ( w -- a f )
d3124 1
a3124 1
( CoCo2 drivers. Load range: 461-462 )
d3126 1
a3126 1
   ," BJRZ2:" 0 C,  ," CKS_3:" 0 C,
d3128 5
a3132 1
   ," FNV_6." 0 C,  ," GOW 7/" 0x80 C,
d3135 2
d3140 1
d3142 4
a3145 1
  IFNZ, ( key! )
d3147 3
a3149 2
    ( A = our char ) 1 S+N STA, 1 # LDD, ( f ) PSHS, D
    ( wait for keyup ) BEGIN, L1 LPC () JSR, BNE, AGAIN,
d3151 4
a3154 3
( ----- 462 )
: (emit)
  0x20 - DUP 0x5f < IF
d3156 4
a3159 3
      THEN THEN
    0xa0 RAM+ TUCK @@ C!+ SWAP ! ELSE DROP THEN ;
: COCO2$ 0x400 0xa0 RAM+ ! ;
@


1.79
log
@trs80-4p: Add BREAK checks to QUIT infinite loops
@
text
@d587 1
a587 1
: AGAIN, ( a -- ) HERE - 1- wbr? IF 1- |T C, THEN C, ;
d594 1
a594 1
    IF 1- |T ROT C!+ ( lsb l+1 ) SWAP THEN SWAP C! ;
@


1.78
log
@Remove S0 and 'S

When I began, I thought I'd play with PS a lot through
those, but it turns out I never needed them.
@
text
@d2580 2
d2583 1
d2599 2
a2600 2
: LINES 24 ; : COLS 80 ;
: XYMODE 0x70 RAM+ ;
d2617 3
a2619 3
: FD0 FLUSH 0 [ DRVMEM LITN ] C! ;
: FD1 FLUSH 1 [ DRVMEM LITN ] C! ;
: FDDRV [ DRVMEM LITN ] C@@ ;
d2643 1
a2643 1
  BEGIN, A 0x6a ( @@CKBRKC ) LDri, 0x28 RST, IFNZ, JPNEXT, THEN,
d2650 1
@


1.77
log
@Remove PICK

Its complexity is not worth it and I use it a lot less than
I first thought. Also, I've read that Chuck Moore doesn't
like it and I kind of agree with the rationale.
@
text
@a1012 1
PS_ADDR CONSTANT S0
a1995 1
CODE 'S HL 0 LDdi, SP ADDHLd, HL PUSH, ;CODE
a2842 1
CODE 'S SP PUSHx, ;CODE
@


1.76
log
@Offload some z80 driver comments to doc/
@
text
@d670 2
a671 2
        SWAP EDPOS @@ _cpos 2DUP + ( ctm ilen a a+ilen )
        3 PICK MOVE- ( ctm ilen ) NIP ( ilen )
d1798 1
a1798 1
VARIABLE lbluflw VARIABLE lblexec
d1887 1
a1887 2
    ( continue to uflw )
lbluflw BSET ( abortUnderflow )
a1991 6
CODE PICK
  HL POP, ( x2 ) L SLA, H RL,
  SP ADDHLd, LDDE(HL), DE PUSH,
  ( check PS range before returning )
  EXDEHL, HL PS_ADDR LDdi, DE SUBHLd,
  IFC, lbluflw @@ JP, THEN, ;CODE
d2359 2
a2360 2
  _sel @@ _ BEGIN ( c a ) C@@+ 2 PICK > UNTIL ( c a )
  1- C@@ NIP _sel ! ;
d2456 1
a2456 1
( TI-84+ LCD driver. See doc/hw/z80/ti84/lcd.txt 
d2502 1
a2502 1
    C@@+ 2 PICK 8 -^ LSHIFT
d2627 7
a2633 7
  2 LSHIFT ( 4 * -- wr sec )
  4 0 DO ( wr sec )
    DUP I + _cylsec ( wr sec cs )
    I 8 LSHIFT BLK( + ( wr sec cs addr )
    FDDRV ROT> ( wr sec drv cs addr )
    4 PICK EXECUTE NOT IF _err THEN
  LOOP 2DROP ;
a2836 5
CODE PICK
    DI POPx, DI SHLx1, ( x2 )
    CX DI MOVxx, CX 2 ADDxi, CALL, lblchkPS @@ RPCn,
    DI SP ADDxx, DI [DI] x[] MOV[], DI PUSHx,
;CODE
d2933 1
a2933 1
( PC/AT drivers. Load range: 420-426 ) 
d2968 1
a2968 1
    0x0201 BLK( 2 PICK _
d2972 1
a2972 1
    0x0301 BLK( 2 PICK _
a3041 1
CODE PICK PULS, D LSLB, ( x2 ) S+B LDD, PSHS, D ;CODE
@


1.75
log
@Move all drivers from arch/ into main blk.fs

Earlier, I made the opposite movement because having machine-
specific recipes was too heavy for the main blkfs. However,
now that I begun taking comments and docs out of blkfs, it
begins making more sense, once again, to have all this code
in a single place. It's simpler.

It's a big move and there's still some doc/comment weeding out
(not deleting! moving to doc/ folder) to do.
@
text
@d2154 1
a2154 1
345 SMS KBD                    347 SMS SPI relay
d2156 3
a2158 3
350 TI-84+ LCD                 360 TI-84+ Keyboard
370 TRS-80 4P drivers
380-399 unused
d2173 1
a2173 11
SPI relay driver

This driver is designed for a ad-hoc adapter card that acts as a
SPI relay between the z80 bus and the SPI device. When writing
to SPI_CTL, we expect a bitmask of the device to select, with
0 meaning that everything is de-selected. Reading SPI_CTL
returns 0 if the device is ready or 1 if it's still running an
exchange. Writing to SPI_DATA initiates an exchange.

Provides the SPI relay protocol. Load driver with "313 LOAD".
( ----- 313 )
d2181 1
a2181 2
    HL PUSH,
;CODE
d2184 1
a2184 2
    SPI_CTL OUTiA,
;CODE
d2313 1
a2313 1
( VDP Driver. requires TMS9918 driver. Load range B330-B332. )
a2324 6
( Each row in ~FNT is a row of the glyph and there is 7 of
them.  We insert a blank one at the end of those 7. For each
row we set, we need to send 3 zero-bytes because each pixel in
the tile is actually 4 bits because it can select among 16
palettes. We use only 2 of them, which is why those bytes
always stay zero. )
d2326 2
a2327 2
    7 0 DO C@@+ _data 3 _zero LOOP DROP
    ( blank row ) 4 _zero ;
d2329 2
a2330 2
    2 * 0x7800 OR _ctl ( c )
    0x20 - ( glyph ) 0x5f MOD _data ;
d2333 4
a2336 4
    ( unset palette bit in old tile )
    2 * 1+ 0x7800 OR _ctl 0 _data
    ( set palette bit for at specified pos )
    2 * 1+ 0x7800 OR _ctl 0x8 _data ;
d2338 8
a2345 9
    9 0 DO _idat I 2 * + @@ _ctl LOOP
    ( blank screen ) 0x7800 _ctl COLS LINES * 2 * _zero
    ( palettes )
    0xc000 _ctl
    ( BG ) 1 _zero 0x3f _data 14 _zero
    ( sprite, inverted colors ) 0x3f _data 15 _zero
    0x4000 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont LOOP
    ( bit 6, enable display, bit 7, ?? ) 0x81c0 _ctl ;

d2348 2
a2349 23
Pad driver - read input from MD controller

Conveniently expose an API to read the status of a MD pad A.
Moreover, implement a mechanism to input arbitrary characters
from it. It goes as follow:

* Direction pad select characters. Up/Down move by one,
  Left/Right move by 5
* Start acts like Return
* A acts like Backspace
* B changes "character class": lowercase, uppercase, numbers,
  special chars. The space character is the first among special
  chars.
* C confirms letter selection

                                                        (cont.)
( ----- 336 )
This module is currently hard-wired to VDP driver, that is, it
calls vdp's routines during (key?) to update character
selection.

Load range: 337-342
( ----- 337 )
d2353 3
a2355 13

( Put status for port A in register A. Bits, from MSB to LSB:
Start - A - C - B - Right - Left - Down - Up
Each bit is high when button is unpressed and low if button is
pressed. When no button is pressed, 0xff is returned.
This logic below is for the Genesis controller, which is modal.
TH is an output pin that switches the meaning of TL and TR. When
TH is high (unselected), TL = Button B and TR = Button C. When
TH is low (selected), TL = Button A and TR = Start. )
( ----- 338 )
: _status
    1 _THA! ( output, high/unselected )
    _D1@@ 0x3f AND ( low 6 bits are good )
d2358 3
a2360 3
    0 _THA! ( output, low/selected )
    _D1@@ 0x30 AND 2 LSHIFT OR ;
( ----- 339 )
d2362 2
a2363 2
    _sel C@@ DUP 0x7f > IF 0x20 _sel C! THEN
    0x20 < IF 0x7f _sel C! THEN ;
d2366 3
a2368 4
    _sel @@ _ BEGIN ( c a ) C@@+ 2 PICK > UNTIL ( c a )
    1- C@@ NIP _sel !
;
( ----- 340 )
d2370 12
a2381 13
    _status _prevstat C@@ OVER = IF DROP 0 EXIT THEN
    DUP _prevstat C! ( changed, update ) ( s )
    0x01 ( UP ) OVER AND NOT IF 1 _sel +! THEN
    0x02 ( DOWN ) OVER AND NOT IF -1 _sel +! THEN
    0x04 ( LEFT ) OVER AND NOT IF -5 _sel +! THEN
    0x08 ( RIGHT ) OVER AND NOT IF 5 _sel +! THEN
    0x10 ( BUTB ) OVER AND NOT IF _nxtcls THEN
    ( update sel in VDP )
    _chk _sel C@@ XYPOS @@ CELL!
    ( return whether any of the high 3 bits is low )
    0xe0 AND 0xe0 <
;
( ----- 341 )
d2383 2
a2384 2
    _next C@@ IF _next C@@ 0 _next C! 1 EXIT THEN
    _updsel IF
d2391 2
a2392 4
( ----- 342 )
: PAD$
    0xff _prevstat C! 'a' _sel C! 0 _next C! ;
( ----- 345 )
d2399 7
a2405 7
    _D1@@ 0x10 AND IF 0 EXIT ( nothing ) THEN
    0 _THA! ( Port A TH output, low )
    _D1@@ ( bit 3:0 go in 3:0 ) 0x0f AND ( n )
    1 _THA! ( Port A TH output, high )
    _D1@@ ( bit 3:0 go in 7:4 ) 0x0f AND 4 LSHIFT OR ( n )
	2 _THA! ( TH input ) ;
( ----- 346 )
d2407 9
a2415 9
	( Port B TL is bit 2 )
    _D2@@ 0x04 AND IF 0 EXIT ( nothing ) THEN
    0 _THB! ( Port B TH output, low )
    _D1@@ ( bit 7:6 go in 1:0 ) 6 RSHIFT ( n )
    _D2@@ ( bit 1:0 go in 3:2 ) 0x03 AND 2 LSHIFT OR ( n )
    1 _THB! ( Port B TH output, high )
    _D1@@ ( bit 7:6 go in 5:4 ) 0xc0 AND 2 RSHIFT OR ( n )
    _D2@@ ( bit 1:0 go in 7:6 ) 0x03 AND 6 LSHIFT OR ( n )
	2 _THB! ( TH input ) ;
d2463 2
a2464 56
TI-84+ LCD driver

Implement (emit) on TI-84+ (for now)'s LCD screen.
Load range: 354-358

The screen is 96x64 pixels. The 64 rows are addressed directly
with CMD_ROW but columns are addressed in chunks of 6 or 8 bits
(there are two modes).

In 6-bit mode, there are 16 visible columns. In 8-bit mode,
there are 12.

Note that "X-increment" and "Y-increment" work in the opposite
way than what most people expect. Y moves left and right, X
moves up and down.
                                                        (cont.)
( ----- 351 )
# Z-Offset

This LCD has a "Z-Offset" parameter, allowing to offset rows on
the screen however we wish. This is handy because it allows us
to scroll more efficiently. Instead of having to copy the LCD
ram around at each linefeed (or instead of having to maintain
an in-memory buffer), we can use this feature.

The Z-Offset goes upwards, with wrapping. For example, if we
have an 8 pixels high line at row 0 and if our offset is 8,
that line will go up 8 pixels, wrapping itself to the bottom of
the screen.

The principle is this: The active line is always the bottom
one. Therefore, when active row is 0, Z is FNTH+1, when row is
1, Z is (FNTH+1)*2, When row is 8, Z is 0.              (cont.)
( ----- 352 )
# 6/8 bit columns and smaller fonts

If your glyphs, including padding, are 6 or 8 pixels wide,
you're in luck because pushing them to the LCD can be done in a
very efficient manner.  Unfortunately, this makes the LCD
unsuitable for a Collapse OS shell: 6 pixels per glyph gives us
only 16 characters per line, which is hardly usable.

This is why we have this buffering system. How it works is that
we're always in 8-bit mode and we hold the whole area (8 pixels
wide by FNTH high) in memory. When we want to put a glyph to
screen, we first read the contents of that area, then add our
new glyph, offsetted and masked, to that buffer, then push the
buffer back to the LCD. If the glyph is split, move to the next
area and finish the job.
                                                        (cont.)
( ----- 353 )
That being said, it's important to define clearly what CURX and
CURY variable mean. Those variable keep track of the current
position *in pixels*, in both axes.
( ----- 354 )
( Required config: LCD_MEM )
d2473 5
a2477 9
    BEGIN,
        0x10 ( CMD ) INAi,
        RLA, ( When 7th bit is clr, we can send a new cmd )
    JRC, AGAIN,
;CODE
( ----- 355 )
( two pixel buffers that are 8 pixels wide (1b) by FNTH
  pixels high. This is where we compose our resulting pixels
  blocks when spitting a glyph. )
a2483 1
( ----- 356 )
d2489 3
a2491 5
    HERE [ LCD_MEM LITN ] ! FNTH 2 * ALLOT
    LCDON 0x01 ( 8-bit mode ) _cmd
    FNTH 1+ _zoff!
;
( ----- 357 )
d2493 4
a2496 6
    SWAP _row!
    ( u ) 0 DO
        _yinc 0 _col!
        11 0 DO 0 _data! LOOP
        _xinc 0 _data!
    LOOP ;
d2498 2
a2499 2
    DUP 1+ FNTH 1+ * _zoff!
    FNTH 1+ * FNTH 1+ _clrrows ;
d2501 1
a2501 1
( ----- 358 )
d2505 15
a2519 15
    DUP _atrow! DUP _tocol _col! ROT ( pos coff c )
    0x20 - FNTH * ~FNT + ( pos coff a )
    _xinc _data@@ DROP
    FNTH 0 DO ( pos coff a )
        C@@+ 2 PICK 8 -^ LSHIFT
        _data@@ 8 LSHIFT OR
        LCD_BUF I + 2DUP FNTH + C!
        SWAP 8 RSHIFT SWAP C!
    LOOP 2DROP
    DUP _atrow!
    FNTH 0 DO LCD_BUF I + C@@ _data! LOOP
    DUP _atrow! _tocol NIP 1+ _col!
    FNTH 0 DO LCD_BUF FNTH + I + C@@ _data! LOOP ;
( ----- 360 )
( Requires KBD_MEM, KBD_PORT. Load range: 360-364 )
d2533 1
a2533 1
( ----- 361 )
d2550 1
a2550 1
( ----- 362 )
d2564 1
a2564 1
( ----- 363 )
d2575 1
a2575 1
( ----- 364 )
d2587 2
a2588 2
( ----- 370 )
( TRS-80 4P drivers. Load range: 370-377 )
d2590 4
a2593 5
    A 0x08 LDri, ( @@KBD )
    0x28 RST,
    IFZ, 0xb1 CPi, IFZ, A '|' LDri, THEN,
    0xad CPi, IFZ, A '~' LDri, THEN,
    PUSHA, PUSH1, ELSE, PUSH0, THEN, ;CODE
d2595 2
a2596 3
    BC POP, ( c == @@DSP arg ) chkPS,
    A 0x02 LDri, ( @@DSP )
    0x28 RST,
d2598 1
a2598 1
( ----- 371 )
d2600 4
a2603 4
    DE POP, H E LDrr, ( Y )
    DE POP, L E LDrr, ( X ) chkPS,
    A 0x0f LDri, ( @@VDCTL ) B 3 LDri, ( setcur )
    0x28 RST,
d2608 2
a2609 5
CODE BYE
    HL 0 LDdi,
    A 0x16 LDri, ( @@EXIT )
    0x28 RST,
( ----- 372 )
d2611 2
a2612 7
    HL POP,
    DE POP,
    BC POP,
    chkPS,
    A 0x31 LDri, ( @@RDSEC )
    0x28 RST,
    PUSHZ,
a2613 1
( ----- 373 )
d2615 2
a2616 7
    HL POP,
    DE POP,
    BC POP,
    chkPS,
    A 0x35 LDri, ( @@WRSEC )
    0x28 RST,
    PUSHZ,
d2618 1
a2618 1
( ----- 374 )
d2620 2
a2621 5
    BC POP,
    chkPS,
    A 0x28 LDri, ( @@DCSTAT )
    0x28 RST,
    PUSHZ,
d2627 1
a2627 1
( ----- 375 )
d2629 3
a2631 3
    ( 4 256b sectors per block, 10 sec per cyl, 40 cyl max )
    10 /MOD ( sec cyl ) DUP 39 > IF _err THEN
    8 LSHIFT + ( cylsec ) ;
d2633 8
a2640 8
    1 @@DCSTAT NOT IF _err THEN
    2 LSHIFT ( 4 * -- wr sec )
    4 0 DO ( wr sec )
        DUP I + _cylsec ( wr sec cs )
        I 8 LSHIFT BLK( + ( wr sec cs addr )
        FDDRV ROT> ( wr sec drv cs addr )
        4 PICK EXECUTE NOT IF _err THEN
    LOOP 2DROP ;
d2644 1
a2644 1
( ----- 376 )
d2654 1
a2654 1
( ----- 377 )
d2656 11
a2666 11
    A XORr, ( 256x ) PUSH0, ( pre-push a failure )
    A 0b01101100 ( RTS low ) LDri, 0xea OUTiA,
    BEGIN, EXAFAF', ( preserve cnt )
        0xea INAi, 0x80 ANDi, ( rcv buff full? )
        IFNZ, ( full )
            HL POP, ( pop failure )
            0xeb INAi, PUSHA, PUSH1, A XORr, ( end loop )
        ELSE, EXAFAF', ( recall cnt ) A DECr, THEN,
    JRNZ, AGAIN,
    A 0b01101101 ( RTS high ) LDri, 0xea OUTiA, ;CODE
( ----- 378 )
d2683 1
a2683 1
( ----- 379 )
@


1.74
log
@Bring RC2014 drivers into main blkfs
@
text
@d14 3
a16 2
280 Z80 boot code             310 Z80 Drivers
400 8086 boot code            450 6809 boot code (WIP)
d2153 6
a2158 1
330-399 unused
d2324 511
d3080 56
d3259 28
@


1.73
log
@Move 8086 and 6809 boot code to make blkfs more compact

For now, I'm assigning 50 blks for each arch for their boot
code + drivers.
@
text
@d2151 2
d2235 83
@


1.72
log
@Move arch-independent xcomp-related code to B200-B279

Forth core, subsystems, font compiler all belong together.
@
text
@d3 1
d15 1
a15 2
320-349 unused                440 8086 boot code
460-469 unused                470 6809 boot code (WIP)
d2233 1
a2233 1
( ----- 440 )
d2237 1
a2237 1
suitable to plug into Core words (B350) to achieve a fully
d2250 1
a2250 1
( ----- 441 )
d2258 2
a2259 2
Load range: B442-B457
( ----- 442 )
d2275 1
a2275 1
( ----- 443 )
d2292 1
a2292 1
( ----- 444 )
d2308 1
a2308 1
( ----- 445 )
d2320 1
a2320 1
( ----- 446 )
d2329 1
a2329 1
( ----- 447 )
d2342 1
a2342 1
( ----- 448 )
d2353 1
a2353 1
( ----- 449 )
d2366 1
a2366 1
( ----- 450 )
d2383 1
a2383 1
( ----- 451 )
d2394 1
a2394 1
( ----- 452 )
d2410 1
a2410 1
( ----- 453 )
d2425 1
a2425 1
( ----- 454 )
d2435 1
a2435 1
( ----- 455 )
d2452 1
a2452 1
( ----- 456 )
d2462 2
a2463 2
( ----- 457 )
( See comment in B321. TODO: test on real hardware. in qemu,
d2478 1
a2478 1
( ----- 470 )
d2495 1
a2495 1
( ----- 471 )
d2506 1
a2506 1
( ----- 472 )
d2516 1
a2516 1
( ----- 473 )
d2533 1
a2533 1
( ----- 474 )
d2545 1
a2545 1
( ----- 475 )
d2560 1
a2560 1
( ----- 476 )
d2574 1
a2574 1
( ----- 477 )
d2586 1
a2586 1
( ----- 478 )
@


1.71
log
@Move xcomp from B260 to B200
@
text
@a2 1

d10 3
d14 2
a15 6
320-349 unused                350 Core words
401 Grid subsystem            410 PS/2 keyboard subsystem
420 SD Card subsystem         430-439 unused
440 8086 boot code            460-469 unused
470 6809 boot code (WIP)      480-519 unused
520 Fonts
d1004 819
a1822 28
( ----- 280 )
( Z80 boot code. See doc/code/z80.txt Load range: B281-B307 )
VARIABLE lbluflw VARIABLE lblexec
( see comment at TICKS' definition )
( 7.373MHz target: 737t. outer: 37t inner: 16t )
( tickfactor = (737 - 37) / 16 )
CREATE tickfactor 44 ,
( ----- 281 )
HERE ORG ! ( STABLE ABI )
0 JP, ( 00, main ) NOP, ( unused ) NOP, NOP, ( 04, BOOT )
NOP, NOP, ( 06, uflw ) NOP, NOP, ( 08, LATEST )
NOP, NOP, ( 0a (main) ) 0 JP, ( 0c QUIT ) NOP,
0 JP, ( RST 10 )  NOP, NOP, ( 13, oflw ) NOP, NOP, NOP,
0 JP, ( RST 18 ) 5 ALLOT0
0 JP, ( RST 20 ) 5 ALLOT0
0 JP, ( RST 28 ) 5 ALLOT0
0 JP, ( RST 30 ) 5 ALLOT0
0 JP, ( RST 38 )
( ----- 282 )
PC ORG @@ 1 + ! ( main )
    SP PS_ADDR LDdi, IX RS_ADDR LDdi,
( LATEST is a label to the latest entry of the dict. It is
  written at offset 0x08 by the process or person building
  Forth. )
    BIN( @@ 0x08 + LDHL(i),
    SYSVARS 0x02 ( CURRENT ) + LD(i)HL,
HERESTART [IF]
    HL HERESTART LDdi,
d2149 17
a2165 441
311 AT28 EEPROM                312 SPI relay
315 TMS9918
( ----- 311 )
CODE AT28C! ( c a -- )
    HL POP, DE POP, chkPS,
    (HL) E LDrr, A E LDrr, ( orig ) D E LDrr, ( save )
    E (HL) LDrr, ( poll ) BEGIN,
        A (HL) LDrr, ( poll ) E CPr, ( same as old? )
        E A LDrr, ( save old poll, Z preserved )
    JRNZ, AGAIN,
( equal to written? SUB instead of CP to ensure IOERR is NZ )
    D SUBr, IFNZ, SYSVARS 0x41 + ( IOERR ) LD(i)A, THEN,
;CODE
: AT28! ( n a -- ) 2DUP AT28C! 1+ SWAP 8 RSHIFT SWAP AT28C! ;
: AT28$ ['] AT28C! W" C!" :* ['] AT28! W" !" :* ;
( ----- 312 )
SPI relay driver

This driver is designed for a ad-hoc adapter card that acts as a
SPI relay between the z80 bus and the SPI device. When writing
to SPI_CTL, we expect a bitmask of the device to select, with
0 meaning that everything is de-selected. Reading SPI_CTL
returns 0 if the device is ready or 1 if it's still running an
exchange. Writing to SPI_DATA initiates an exchange.

Provides the SPI relay protocol. Load driver with "313 LOAD".
( ----- 313 )
CODE (spix) ( n -- n )
    HL POP, chkPS, A L LDrr,
    SPI_DATA OUTiA,
    ( wait until xchg is done )
    BEGIN, SPI_CTL INAi, 1 ANDi, JRNZ, AGAIN,
    SPI_DATA INAi,
    L A LDrr,
    HL PUSH,
;CODE
CODE (spie) ( n -- )
    HL POP, chkPS, A L LDrr,
    SPI_CTL OUTiA,
;CODE
( ----- 315 )
( Z80 driver for TMS9918. Implements grid protocol. Requires
TMS_CTLPORT, TMS_DATAPORT and ~FNT from the Font compiler at
B520. Patterns are at addr 0x0000, Names are at 0x3800.
Load range B315-317 )
CODE _ctl ( a -- sends LSB then MSB )
    HL POP, chkPS,
    A L LDrr, TMS_CTLPORT OUTiA,
    A H LDrr, TMS_CTLPORT OUTiA,
;CODE
CODE _data
    HL POP, chkPS,
    A L LDrr, TMS_DATAPORT OUTiA,
;CODE
( ----- 316 )
: _zero ( x -- send 0 _data x times )
    ( x ) 0 DO 0 _data LOOP ;
( Each row in ~FNT is a row of the glyph and there is 7 of
them.  We insert a blank one at the end of those 7. )
: _sfont ( a -- Send font to TMS )
    7 0 DO C@@+ _data LOOP DROP
    ( blank row ) 0 _data ;
: _sfont^ ( a -- Send inverted font to TMS )
    7 0 DO C@@+ 0xff XOR _data LOOP DROP
    ( blank row ) 0xff _data ;
: CELL! ( c pos )
    0x7800 OR _ctl ( tilenum )
    SPC - ( glyph ) 0x5f MOD _data ;
( ----- 317 )
: CURSOR! ( new old -- )
    DUP 0x3800 OR _ctl [ TMS_DATAPORT LITN ] PC@@
    0x7f AND ( new old glyph ) SWAP 0x7800 OR _ctl _data
    DUP 0x3800 OR _ctl [ TMS_DATAPORT LITN ] PC@@
    0x80 OR ( new glyph ) SWAP 0x7800 OR _ctl _data ;
: COLS 40 ; : LINES 24 ;
: TMS$
    0x8100 _ctl ( blank screen )
    0x7800 _ctl COLS LINES * _zero
    0x4000 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont LOOP
    0x4400 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont^ LOOP
    0x820e _ctl ( name table 0x3800 )
    0x8400 _ctl ( pattern table 0x0000 )
    0x87f0 _ctl ( colors 0 and 1 )
    0x8000 _ctl 0x81d0 _ctl ( text mode, display on ) ;
( ----- 350 )
Core words

This section contains arch-independent core words of Collapse
OS. Those words are written in a way that make them entirely
cross-compilable (see B260). When building Collapse OS, these
words come right after the boot binary. See doc/cross.txt.

This unit is loaded in two "low" and "high" parts. The low part
is the biggest chunk and has the most definitions. The high
part is the "sensitive" chunk and contains "LITN", ":" and ";"
definitions which, once defined, kind of make any more defs
impossible.

The gap between these 2 parts is the ideal place to put device
driver code. Load the low part with "353 LOAD", the high part
with "390 LOAD"
( ----- 353 )
: RAM+ [ SYSVARS LITN ] + ; : BIN+ [ BIN( @@ LITN ] + ;
SYSVARS 0x02 + CONSTANT CURRENT
SYSVARS 0x04 + CONSTANT H
SYSVARS 0x0c + CONSTANT C<*
SYSVARS 0x41 + CONSTANT IOERR
PS_ADDR CONSTANT S0
: HERE H @@ ;
1 23 LOADR+
( ----- 354 )
: 0< 32767 > ; : >= < NOT ; : <= > NOT ;
: =><= ( n l h -- f ) OVER - ROT> ( h n l ) - >= ;
: NIP SWAP DROP ; : TUCK SWAP OVER ;
: -^ SWAP - ;
: C@@+ ( a -- a+1 c ) DUP C@@ SWAP 1+ SWAP ;
: C!+ ( c a -- a+1 ) TUCK C! 1+ ;
: C@@- ( a -- a-1 c ) DUP C@@ SWAP 1- SWAP ;
: C!- ( c a -- a-1 ) TUCK C! 1- ;
: LEAVE R> R> DROP I 1- >R >R ; : UNLOOP R> 2R> 2DROP >R ;
( ----- 355 )
: +! TUCK @@ + SWAP ! ;
: *! ( addr alias -- ) 1+ ! ;
: **! ( addr ialias -- ) 1+ @@ ! ;
: / /MOD NIP ;
: MOD /MOD DROP ;
: ALLOT H +! ;
: FILL ( a n b -- )
    ROT> OVER ( b a n a ) + SWAP ( b a+n a ) DO ( b )
        DUP I C! LOOP DROP ;
: ALLOT0 ( n -- ) HERE OVER 0 FILL ALLOT ;
( ----- 356 )
SYSVARS 0x53 + :** EMIT
: STYPE C@@+ ( a len ) 0 DO C@@+ EMIT LOOP DROP ;
: EOT 0x4 ; : BS 0x8 ; : LF 0xa ; : CR 0xd ; : SPC 0x20 ;
: SPC> SPC EMIT ;
: NL> 0x50 RAM+ C@@ ?DUP IF EMIT ELSE CR EMIT LF EMIT THEN ;
: EOT? EOT = ;
: ERR STYPE ABORT ;
: (uflw) LIT" stack underflow" ERR ;
XCURRENT @@ _xapply ORG @@ 0x06 ( stable ABI uflw ) + T!
: (oflw) LIT" stack overflow" ERR ;
XCURRENT @@ _xapply ORG @@ 0x13 ( stable ABI oflw ) + T!
: (wnf) STYPE LIT"  word not found" ERR ;
( ----- 357 )
: . ( n -- )
    ?DUP NOT IF '0' EMIT EXIT THEN ( 0 is a special case )
    DUP 0< IF '-' EMIT -1 * THEN
    0xff SWAP ( stop indicator ) BEGIN
        10 /MOD ( r q ) SWAP '0' + SWAP ( d q ) ?DUP NOT UNTIL
    BEGIN EMIT DUP '9' > UNTIL DROP ;
: ? @@ . ;
: _ DUP 9 > IF 10 - 'a' + ELSE '0' + THEN ;
( For hex display, there are no negatives )
: .x 0xff AND 16 /MOD ( l h ) _ EMIT _ EMIT ;
: .X |M .x .x ;
( ----- 358 )
( Parse digit c and accumulate into result r.
  Flag f is true when c was a valid digit )
: _pdacc ( r c -- r f )
    '0' - DUP 10 < IF ( good, add to running result )
        SWAP 10 * + 1 ( r*10+n f )
        ELSE ( bad ) DROP 0 THEN ;
: _pd ( s -- n f, parse decimal )
    C@@+ OVER C@@ 0 ( a len firstchar startat )
( if we have '-', we only advance. more processing later. )
    SWAP '-' = IF 1+ THEN ( a len startat )
    0 ROT> ( len ) ( startat ) DO ( a r )
        OVER I + C@@ ( a r c ) _pdacc ( a r f )
        NOT IF DROP 1- 0 UNLOOP EXIT THEN LOOP ( a r )
( if we had '-', we need to invert result. )
    SWAP C@@ '-' = IF 0 -^ THEN 1 ( r 1 ) ;
( ----- 359 )
: _pref ( s p -- s len-or-0 )
  1+ OVER 1+ 2 []= NOT IF 0 EXIT THEN ( s )
  DUP C@@ DUP 3 < IF DROP 0 EXIT THEN ;
: _ph ( s -- n f, parse hex )
  LIT" 0x" _pref DUP IF ( s len )
    0 SWAP 1+ ( len+1 ) 3 DO ( s r )
      4 LSHIFT ( s r*16 ) OVER I + C@@ ( s r c )
      '0' - DUP 9 > IF 0x31 ( 'a'-'0' ) - DUP 6 < IF
      10 + ELSE 2DROP 0 UNLOOP EXIT THEN THEN ( s r n )
      + ( s r+n ) LOOP NIP 1 THEN ;
( ----- 360 )
: _pb ( s -- n f, parse binary )
  LIT" 0b" _pref DUP IF ( s len )
    0 SWAP 1+ ( len+1 ) 3 DO ( s r )
      1 LSHIFT ( s r*2 ) OVER I + C@@ ( s r c )
      '0' - DUP 1 > IF 2DROP 0 UNLOOP EXIT THEN ( s r n )
      + ( s r+n ) LOOP NIP 1 THEN ;
: _pc ( a -- n f, parse character )
	DUP C@@+ 3 = IF ( a a+1 ) C@@+ ''' = IF ( a a+2 )
        DUP 1+ C@@ ''' = IF C@@ NIP 1 EXIT THEN THEN THEN
	DROP 0 ;
: (parse) ( a -- n )
    _pc IF EXIT THEN _ph IF EXIT THEN
    _pb IF EXIT THEN _pd IF EXIT THEN (wnf) ;
( ----- 361 )
SYSVARS 0x55 + :** KEY?
: KEY> [ SYSVARS 0x51 + LITN ] C! ;
: KEY [ SYSVARS 0x51 + LITN ] C@@ ?DUP IF 0 KEY>
    ELSE BEGIN KEY? UNTIL THEN ;
: BS? DUP 0x7f ( DEL ) = SWAP BS = OR ;
SYSVARS 0x30 + CONSTANT IN> ( current position in INBUF )
SYSVARS 0x60 + CONSTANT IN( ( points to INBUF )
: IN$ 0 IN( DUP IN> ! ! ; ( flush input buffer )
( ----- 362 )
: RDLN ( Read 1 line in input buff and make IN> point to it )
  IN$ BEGIN
  ( buffer overflow? same as if we typed a newline )
  IN> @@ IN( - 0x3e = IF CR ELSE KEY THEN ( c )
  DUP BS? IF
    IN> @@ IN( > IF -1 IN> +! BS EMIT THEN SPC> BS EMIT
  ELSE DUP LF = IF DROP CR THEN ( same as CR )
    DUP SPC >= IF DUP EMIT ( echo back ) THEN
    DUP IN> @@ C!+ IN> ! THEN ( c )
  DUP CR = SWAP EOT? OR UNTIL 0 IN> @@ C! IN( IN> ! ;
: RDLN<
  IN> @@ C@@ ( c )
  DUP IF ( not EOL? good, inc and return ) 1 IN> +!
  ELSE ( EOL ? readline. we still return null though )
    SPC> LIT" ok" STYPE NL> RDLN NL>
  THEN ( c ) ;
( ----- 363 )
: C< C<* @@ ?DUP NOT IF RDLN< ELSE EXECUTE THEN ;
: , HERE ! 2 ALLOT ;
: C, HERE C! 1 ALLOT ;
: ,"
    BEGIN
        C< DUP 34 ( ASCII " ) = IF DROP EXIT THEN C,
    AGAIN ;
: EOT, EOT C, ;
: WS? SPC <= ;

: TOWORD ( -- c, c being the first letter of the word )
    0 ( dummy ) BEGIN
        DROP C< DUP WS? NOT OVER EOT? OR UNTIL ;
( ----- 364 )
( Read word from C<, copy to WORDBUF, null-terminate, and
  return WORDBUF. )
SYSVARS 0x0e + CONSTANT _wb
: _eot EOT 1 _wb C!+ C! _wb ;
: WORD ( -- a )
    [ SYSVARS 0x32 + ( WORD LIT ) LITN ] @@ ?DUP IF
        0 [ SYSVARS 0x32 + LITN ] ! EXIT THEN
    _wb 1+ TOWORD ( a c )
    DUP EOT? IF 2DROP _eot EXIT THEN
    BEGIN
        OVER C! 1+ C< ( a c )
        OVER 0x2e RAM+ = OVER WS? OR UNTIL ( a c )
    SWAP _wb - 1- ( ws len ) _wb C!
    EOT? IF _eot ELSE _wb THEN ;
: IMMEDIATE CURRENT @@ 1- DUP C@@ 128 OR SWAP C! ;
: IMMED? 1- C@@ 0x80 AND ;
( ----- 365 )
: MOVE ( a1 a2 u -- )
    ?DUP IF ( u ) 0 DO ( a1 a2 )
        OVER I + C@@ ( src dst x )
        OVER I + ( src dst x dst )
        C! ( src dst )
    LOOP THEN 2DROP ;
: MOVE- ( a1 a2 u -- )
    ?DUP IF ( u ) 0 DO ( a1 a2 )
        OVER I' + I - 1- C@@ ( src dst x )
        OVER I' + I - 1- ( src dst x dst )
        C! ( src dst )
    LOOP THEN 2DROP ;
: MOVE, ( a u -- ) HERE OVER ALLOT SWAP MOVE ;
( ----- 366 )
: (entry) WORD
    C@@+ ( w+1 len ) TUCK MOVE, ( len )
    ( write prev value )
    HERE CURRENT @@ - ,
    C, ( write size )
    HERE CURRENT ! ;
: CREATE (entry) 2 ( cellWord ) C, ;
: VARIABLE CREATE 2 ALLOT ;
: :* ( addr -- ) (entry) 4 ( alias ) C, , ;
: :** ( addr -- ) (entry) 5 ( ialias ) C, , ;
( ----- 367 )
: '? WORD FIND ;
: ' '? NOT IF (wnf) THEN ;
: FORGET
    ' DUP ( w w )
    ( HERE must be at the end of prev's word, that is, at the
      beginning of w. )
    DUP 1- C@@ ( name len field )
    0x7f AND  ( remove IMMEDIATE flag )
    3 +       ( fixed header len )
    - H !     ( w )
    ( get prev addr ) 3 - DUP @@ - CURRENT ! ;
: EMPTY LIT" _sys" FIND IF DUP H ! CURRENT ! THEN ;
( ----- 368 )
: DOES> CURRENT @@ ( cur )
    3 ( does ) OVER C! ( make CURRENT into a DOES )
    1+ DUP ( pfa pfa )
    ( move PFA by 2 ) HERE OVER - ( pfa pfa u )
    OVER 2 + SWAP MOVE- 2 ALLOT
    ( Write DOES> pointer ) R> SWAP ( does-addr pfa ) !
    ( Because we've popped RS, we'll exit parent definition ) ;
: CONSTANT (entry) 6 ( constant ) C, , ;
: S= ( s1 s2 -- f ) C@@+ ( s1 s2 l2 ) ROT C@@+ ( s2 l2 s1 l1 )
    ROT OVER = IF ( same len, s2 s1 l ) []=
    ELSE DROP 2DROP 0 THEN ;
: [IF] IF EXIT THEN LIT" [THEN]" BEGIN DUP WORD S= UNTIL DROP ;
: [THEN] ;
( ----- 369 )
( n -- Fetches block n and write it to BLK( )
SYSVARS 0x34 + :** BLK@@*
( n -- Write back BLK( to storage at block n )
SYSVARS 0x36 + :** BLK!*
( Current blk pointer -1 means "invalid" )
SYSVARS 0x38 + CONSTANT BLK>
( Whether buffer is dirty )
SYSVARS 0x3a + CONSTANT BLKDTY
: BLK( 0x3c RAM+ @@ ;
: BLK) BLK( 1024 + ;
: BLK$
    HERE 0x3c ( BLK(* ) RAM+ !
    1024 ALLOT
    ( LOAD detects end of block with ASCII EOT. This is why
      we write it there. )
    EOT, 0 BLKDTY ! -1 BLK> ! ;
( ----- 370 )
: BLK! ( -- ) BLK> @@ BLK!* 0 BLKDTY ! ;
: FLUSH BLKDTY @@ IF BLK! THEN -1 BLK> ! ;
: BLK@@ ( n -- )
    DUP BLK> @@ = IF DROP EXIT THEN
    FLUSH DUP BLK> ! BLK@@* ;
: BLK!! 1 BLKDTY ! ;
: WIPE BLK( 1024 0 FILL BLK!! ;
: COPY ( src dst -- )
    FLUSH SWAP BLK@@ BLK> ! BLK! ;
( ----- 373 )
: _ ( a -- a+8 )
    DUP ( a a )
    ':' EMIT DUP .x SPC>
    4 0 DO DUP @@ |L .x .x SPC> 2 + LOOP
    DROP ( a )
    8 0 DO
        C@@+ DUP SPC 0x7e =><= NOT IF DROP '.' THEN EMIT
    LOOP NL> ;
: DUMP ( n a -- )
    SWAP 8 /MOD SWAP IF 1+ THEN
    0 DO _ LOOP DROP ;
( ----- 374 )
: LIST
    BLK@@
    16 0 DO
        I 1+ DUP 10 < IF SPC> THEN . SPC>
        64 I * BLK( + DUP 64 + SWAP DO
            I C@@ DUP 0x1f > IF EMIT ELSE DROP LEAVE THEN
        LOOP
        NL>
    LOOP ;
( ----- 375 )
: INTERPRET BEGIN
    WORD DUP 1+ C@@ EOT? IF DROP EXIT THEN
    FIND NOT IF (parse) ELSE EXECUTE THEN AGAIN ;
SYSVARS 0x2e + CONSTANT MEM<*
( Read char from MEM<* and inc it. )
: MEM<
    MEM<* @@ C@@+ ( a+1 c )
    SWAP MEM<* ! ( c ) ;
( ----- 376 )
: LOAD
( save restorable variables to RSP. to allow for nested LOADs,
  we save/restore BLKs, but only when C<* is 0, that is, then
  RDLN< is active. )
    C<* @@ IF BLK> @@ >R THEN
    C<* @@ >R MEM<* @@ >R
    BLK@@ BLK( MEM<* ! ( Point to beginning of BLK )
    ['] MEM< C<* !
    INTERPRET
    R> MEM<* ! R> C<* !
    C<* @@ IF R> BLK@@ THEN ;
: LOAD+ BLK> @@ + LOAD ;
( b1 b2 -- )
: LOADR 1+ SWAP DO I DUP . SPC> LOAD LOOP ;
: LOADR+ BLK> @@ + SWAP BLK> @@ + SWAP LOADR ;
( ----- 390 )
( xcomp core high )
: (main) 0 C<* ! IN$ INTERPRET BYE ;
XCURRENT @@ _xapply ORG @@ 0x0a ( stable ABI (main) ) + T!
: BOOT
    CURRENT @@ MEM<* !
    0 IOERR C!
    0 [ SYSVARS 0x50 + LITN ] ! ( NL> + KEY> )
    0 [ SYSVARS 0x32 + LITN ] ! ( WORD LIT )
    ['] (emit) ['] EMIT **! ['] (key?) ['] KEY? **!
    ['] MEM< C<* !
    INTERPRET
    W" _sys" (entry)
    LIT" Collapse OS" STYPE (main) ;
XCURRENT @@ _xapply ORG @@ 0x04 ( stable ABI BOOT ) + T!
1 3 LOADR+
( ----- 391 )
( Now we have "as late as possible" stuff. See bootstrap doc. )
: _bchk DUP 0x7f + 0xff > IF LIT" br ovfl" STYPE ABORT THEN ;
: DO COMPILE 2>R HERE ; IMMEDIATE
: LOOP COMPILE (loop) HERE - _bchk C, ; IMMEDIATE
( LEAVE is implemented in low xcomp )
: LITN DUP 0xff > IF COMPILE (n) , ELSE COMPILE (b) C, THEN ;
: :
    (entry) 1 ( compiled ) C,
    BEGIN
        WORD DUP LIT" ;" S= IF DROP COMPILE EXIT EXIT THEN
        FIND IF ( is word ) DUP IMMED? IF EXECUTE ELSE , THEN
        ELSE ( maybe number ) (parse) LITN THEN
    AGAIN ;
( ----- 392 )
: IF ( -- a | a: br cell addr )
    COMPILE (?br) HERE 1 ALLOT ( br cell allot ) ; IMMEDIATE
: THEN ( a -- | a: br cell addr )
    DUP HERE -^ _bchk SWAP ( a-H a ) C! ; IMMEDIATE
: ELSE ( a1 -- a2 | a1: IF cell a2: ELSE cell )
    COMPILE (br) 1 ALLOT [COMPILE] THEN
    HERE 1- ( push a. 1- for allot offset ) ; IMMEDIATE
: ( BEGIN LIT" )" WORD S= UNTIL ;
    ( no more comment from here ) IMMEDIATE
: LIT"
    COMPILE (s) HERE 0 C, ,"
    DUP HERE -^ 1- SWAP C! ; IMMEDIATE
: W"
    [COMPILE] LIT" [ SYSVARS 0x32 + LITN ] LITN
    COMPILE ! ; IMMEDIATE
( ----- 393 )
: ." [COMPILE] LIT" COMPILE STYPE ; IMMEDIATE
: ABORT" [COMPILE] ." COMPILE ABORT ; IMMEDIATE
: BEGIN HERE ; IMMEDIATE
: AGAIN COMPILE (br) HERE - _bchk C, ; IMMEDIATE
: UNTIL COMPILE (?br) HERE - _bchk C, ; IMMEDIATE
: [ INTERPRET ; IMMEDIATE
: ] R> DROP ;
: COMPILE ' LITN ['] , , ; IMMEDIATE
: [COMPILE] ' , ; IMMEDIATE
: ['] ' LITN ; IMMEDIATE
( ----- 401 )
Grid subsystem

See doc/grid.txt.
d2167 6
a2172 23
Load range: B402-B403
( ----- 402 )
: XYPOS [ GRID_MEM LITN ] ; : XYMODE [ GRID_MEM LITN ] 2 + ;
'? CURSOR! NIP NOT [IF] : CURSOR! 2DROP ; [THEN]
: XYPOS! COLS LINES * MOD DUP XYPOS @@ CURSOR! XYPOS ! ;
: AT-XY ( x y -- ) COLS * + XYPOS! ;
'? NEWLN NIP NOT [IF]
: NEWLN ( ln -- ) COLS * DUP COLS + SWAP DO SPC I CELL! LOOP ;
[THEN]
: _lf XYMODE C@@ IF EXIT THEN
    XYPOS @@ COLS / 1+ LINES MOD DUP NEWLN
    COLS * XYPOS! ;
: _bs SPC XYPOS @@ TUCK CELL! ( pos ) 1- XYPOS! ;
( ----- 403 )
: (emit)
    DUP BS? IF DROP _bs EXIT THEN
    DUP CR = IF DROP _lf EXIT THEN
    DUP SPC < IF DROP EXIT THEN
    XYPOS @@ CELL!
    XYPOS @@ 1+ DUP COLS MOD IF XYPOS! ELSE DROP _lf THEN ;
: GRID$ 0 XYPOS ! 0 XYMODE C! ;
( ----- 410 )
PS/2 keyboard subsystem
d2174 59
a2232 203
Provides (key?) from a driver providing the PS/2 protocol. That
is, for a driver taking care of providing all key codes emanat-
ing from a PS/2 keyboard, this subsystem takes care of mapping
those keystrokes to ASCII characters. This code is designed to
be cross-compiled and loaded with drivers.

Requires PS2_MEM to be defined.

Load range: 411-414
( ----- 411 )
: PS2_SHIFT [ PS2_MEM LITN ] ;
: PS2$ 0 PS2_SHIFT C! ;

( A list of the values associated with the 0x80 possible scan
codes of the set 2 of the PS/2 keyboard specs. 0 means no
value. That value is a character that can be read in (key?)
No make code in the PS/2 set 2 reaches 0x80. )
CREATE PS2_CODES
( 00 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( 08 ) 0 C, 0 C, 0 C, 0 C, 0 C, 9 C, '`' C, 0 C,
( 10 ) 0 C, 0 C, 0 C, 0 C, 0 C, 'q' C, '1' C, 0 C,
( I don't know why, but the key 2 is sent as 0x1f by 2 of my
  keyboards. Is it a timing problem on the ATtiny? TODO )
( 18 ) 0 C, 0 C, 'z' C, 's' C, 'a' C, 'w' C, '2' C, '2' C,
( 20 ) 0 C, 'c' C, 'x' C, 'd' C, 'e' C, '4' C, '3' C, 0 C,
( 28 ) 0 C, 32 C, 'v' C, 'f' C, 't' C, 'r' C, '5' C, 0 C,
( ----- 412 )
( 30 ) 0 C, 'n' C, 'b' C, 'h' C, 'g' C, 'y' C, '6' C, 0 C,
( 38 ) 0 C, 0 C, 'm' C, 'j' C, 'u' C, '7' C, '8' C, 0 C,
( 40 ) 0 C, ',' C, 'k' C, 'i' C, 'o' C, '0' C, '9' C, 0 C,
( 48 ) 0 C, '.' C, '/' C, 'l' C, ';' C, 'p' C, '-' C, 0 C,
( 50 ) 0 C, 0 C, ''' C, 0 C, '[' C, '=' C, 0 C, 0 C,
( 58 ) 0 C, 0 C, 13 C, ']' C, 0 C, '\' C, 0 C, 0 C,
( 60 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 8 C, 0 C,
( 68 ) 0 C, '1' C, 0 C, '4' C, '7' C, 0 C, 0 C, 0 C,
( 70 ) '0' C, '.' C, '2' C, '5' C, '6' C, '8' C, 27 C, 0 C,
( 78 ) 0 C, 0 C, '3' C, 0 C, 0 C, '9' C, 0 C, 0 C,
( Same values, but shifted )
( 00 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( 08 ) 0 C, 0 C, 0 C, 0 C, 0 C, 9 C, '~' C, 0 C,
( 10 ) 0 C, 0 C, 0 C, 0 C, 0 C, 'Q' C, '!' C, 0 C,
( 18 ) 0 C, 0 C, 'Z' C, 'S' C, 'A' C, 'W' C, '@@' C, '@@' C,
( 20 ) 0 C, 'C' C, 'X' C, 'D' C, 'E' C, '$' C, '#' C, 0 C,
( ----- 413 )
( 28 ) 0 C, 32 C, 'V' C, 'F' C, 'T' C, 'R' C, '%' C, 0 C,
( 30 ) 0 C, 'N' C, 'B' C, 'H' C, 'G' C, 'Y' C, '^' C, 0 C,
( 38 ) 0 C, 0 C, 'M' C, 'J' C, 'U' C, '&' C, '*' C, 0 C,
( 40 ) 0 C, '<' C, 'K' C, 'I' C, 'O' C, ')' C, '(' C, 0 C,
( 48 ) 0 C, '>' C, '?' C, 'L' C, ':' C, 'P' C, '_' C, 0 C,
( 50 ) 0 C, 0 C, '"' C, 0 C, '{' C, '+' C, 0 C, 0 C,
( 58 ) 0 C, 0 C, 13 C, '}' C, 0 C, '|' C, 0 C, 0 C,
( 60 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 8 C, 0 C,
( 68 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( 70 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 27 C, 0 C,
( 78 ) 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C, 0 C,
( ----- 414 )
: _shift? ( kc -- f ) DUP 0x12 = SWAP 0x59 = OR ;
: (key?) ( -- c? f )
    (ps2kc) DUP NOT IF EXIT THEN ( kc )
    DUP 0xe0 ( extended ) = IF ( ignore ) DROP 0 EXIT THEN
    DUP 0xf0 ( break ) = IF DROP ( )
        ( get next kc and see if it's a shift )
        BEGIN (ps2kc) ?DUP UNTIL ( kc )
        _shift? IF ( drop shift ) 0 PS2_SHIFT C! THEN
        ( whether we had a shift or not, we return the next )
        0 EXIT THEN
    DUP 0x7f > IF DROP 0 EXIT THEN
    DUP _shift? IF DROP 1 PS2_SHIFT C! 0 EXIT THEN
    ( ah, finally, we have a gentle run-of-the-mill KC )
    PS2_CODES PS2_SHIFT C@@ IF 0x80 + THEN + C@@ ( c, maybe 0 )
    ?DUP ( c? f ) ;
( ----- 420 )
( SD Card subsystem Load range: B420-B428 )
: _idle ( -- n ) 0xff (spix) ;

( spix 0xff until the response is something else than 0xff
  for a maximum of 20 times. Returns 0xff if no response. )
: _wait ( -- n )
    0 ( dummy ) 20 0 DO
        DROP _idle DUP 0xff = NOT IF LEAVE THEN LOOP ;
( ----- 421 )
( The opposite of sdcWaitResp: we wait until response is 0xff.
  After a successful read or write operation, the card will be
  busy for a while. We need to give it time before interacting
  with it again. Technically, we could continue processing on
  our side while the card it busy, and maybe we will one day,
  but at the moment, I'm having random write errors if I don't
  do this right after a write, so I prefer to stay cautious
  for now. )
: _ready ( -- ) BEGIN _idle 0xff = UNTIL ;
( ----- 422 )
( Computes n into crc c with polynomial 0x09
  Note that the result is "left aligned", that is, that 8th
  bit to the "right" is insignificant (will be stop bit). )
: _crc7 ( c n -- c )
    XOR           ( c )
    8 0 DO
        2 *       ( <<1 )
        DUP 255 > IF
            ( MSB was set, apply polynomial )
            0xff AND
            0x12 XOR  ( 0x09 << 1, we apply CRC on high bits )
        THEN
    LOOP ;
( send-and-crc7 )
: _s+crc ( n c -- c ) SWAP DUP (spix) DROP _crc7 ;
( ----- 423 )
( cmd arg1 arg2 -- resp )
( Sends a command to the SD card, along with arguments and
  specified CRC fields. (CRC is only needed in initial commands
  though). This does *not* handle CS. You have to
  select/deselect the card outside this routine. )
: _cmd
    _wait DROP ROT    ( a1 a2 cmd )
    0 _s+crc          ( a1 a2 crc )
    ROT |M ROT        ( a2 h l crc )
    _s+crc _s+crc     ( a2 crc )
    SWAP |M ROT       ( h l crc )
    _s+crc _s+crc     ( crc )
    1 OR              ( ensure stop bit )
    (spix) DROP       ( send CRC )
    _wait  ( wait for a valid response... ) ;
( ----- 424 )
( cmd arg1 arg2 -- r )
( Send a command that expects a R1 response, handling CS. )
: SDCMDR1 [ SDC_DEVID LITN ] (spie) _cmd 0 (spie) ;

( cmd arg1 arg2 -- r arg1 arg2 )
( Send a command that expects a R7 response, handling CS. A R7
  is a R1 followed by 4 bytes. arg1 contains bytes 0:1, arg2
  has 2:3 )
: SDCMDR7
    [ SDC_DEVID LITN ] (spie)
    _cmd                 ( r )
    _idle 8 LSHIFT _idle +  ( r arg1 )
    _idle 8 LSHIFT _idle +  ( r arg1 arg2 )
    0 (spie)
;
( ----- 425 )
: _err 0 (spie) LIT" SDerr" ERR ;

( Tight definition ahead, pre-comment.

  Initialize a SD card. This should be called at least 1ms
  after the powering up of the card. We begin by waking up the
  SD card. After power up, a SD card has to receive at least
  74 dummy clocks with CS and DI high. We send 80.
  Then send cmd0 for a maximum of 10 times, success is when
  we get 0x01. Then comes the CMD8. We send it with a 0x01aa
  argument and expect a 0x01aa argument back, along with a
  0x01 R1 response. After that, we need to repeatedly run
  CMD55+CMD41 (0x40000000) until the card goes out of idle
  mode, that is, when it stops sending us 0x01 response and
  send us 0x00 instead. Any other response means that
  initialization failed. )
( ----- 426 )
: SDC$
    10 0 DO _idle DROP LOOP
    0 ( dummy ) 10 0 DO  ( r )
        DROP 0x40 0 0 SDCMDR1  ( CMD0 )
        1 = DUP IF LEAVE THEN
    LOOP NOT IF _err THEN
    0x48 0 0x1aa ( CMD8 ) SDCMDR7 ( r arg1 arg2 )
    ( expected 1 0 0x1aa )
    0x1aa = ROT ( arg1 f r ) 1 = AND SWAP ( f&f arg1 )
    NOT ( 0 expected ) AND ( f&f&f ) NOT IF _err THEN
    BEGIN
        0x77 0 0 SDCMDR1  ( CMD55 )
        1 = NOT IF _err THEN
        0x69 0x4000 0 SDCMDR1  ( CMD41 )
        DUP 1 > IF _err THEN
    NOT UNTIL ; ( out of idle mode, success! )
( ----- 427 )
: _ ( dstaddr blkno -- )
    [ SDC_DEVID LITN ] (spie)
    0x51 ( CMD17 ) 0 ROT ( a cmd 0 blkno ) _cmd
    IF _err THEN
    _wait 0xfe = NOT IF _err THEN
    0 SWAP ( crc a ) 512 0 DO ( crc a )
        _idle ( crc a n ) DUP ROT C!+ ( crc n a+1 )
        ROT> CRC16 ( a+1 crc ) SWAP LOOP ( crc a+1 )
    DROP ( crc1 )
    _idle 8 LSHIFT _idle + ( crc2 )
    _wait DROP 0 (spie) = NOT IF _err THEN ;
: SDC@@ ( blkno -- )
    2 * DUP BLK( SWAP ( b a b ) _
    1+ BLK( 512 + SWAP _ ;
( ----- 428 )
: _ ( srcaddr blkno -- )
    [ SDC_DEVID LITN ] (spie)
    0x58 ( CMD24 ) 0 ROT ( a cmd 0 blkno ) _cmd
    IF _err THEN
    _idle DROP 0xfe (spix) DROP 0 SWAP ( crc a )
    512 0 DO ( crc a )
        C@@+ ( crc a+1 n ) ROT OVER ( a n crc n )
        CRC16 ( a n crc ) SWAP ( a crc n )
        (spix) DROP ( a crc ) SWAP LOOP ( crc a )
    DROP ( crc ) |M ( lsb msb )
    (spix) DROP (spix) DROP
    _wait DROP 0 (spie) ;
: SDC! ( blkno -- )
    2 * DUP BLK( SWAP ( b a b ) _
    1+ BLK( 512 + SWAP _ ;
a2600 228
( ----- 520 )
Fonts

Fonts are kept in "source" form in the following blocks and
then compiled to binary bitmasks by the following code. In
source form, fonts are a simple sequence of '.' and 'X'. '.'
means empty, 'X' means filled. Glyphs are entered one after the
other, starting at 0x21 and ending at 0x7e. To be space
efficient in blocks, we align glyphs horizontally in the blocks
to fit as many character as we can. For example, a 5x7 font
would mean that we would have 12x2 glyphs per block.

521 Font compiler              530 3x5 font
532 5x7 font                   536 7x7 font
( ----- 521 )
( Converts "dot-X" fonts to binary "glyph rows". One byte for
  each row. In a 5x7 font, each glyph thus use 7 bytes.
  Resulting bytes are aligned to the left of the byte.
  Therefore, for a 5-bit wide char, "X.X.X" translates to
  0b10101000. Left-aligned bytes are easier to work with when
  compositing glyphs. )
( ----- 522 )
VARIABLE _w VARIABLE _h
: _g ( given a top-left of dot-X in BLK(, spit H bin lines )
    _h @@ 0 DO
    0 _w @@ 0 DO ( a r )
        1 LSHIFT
        OVER J 64 * I + + C@@ 'X' = IF 1+ THEN
    LOOP 8 _w @@ - LSHIFT C, LOOP DROP ;
: _l ( a u -- a, spit a line of u glyphs )
    ( u ) 0 DO ( a )
        DUP I _w @@ * + _g
    LOOP ;
( ----- 523 )
: CPFNT3x5 3 _w ! 5 _h !
    _h @@ ALLOT0 ( space char )
    525 BLK@@ BLK( 21 _l 320 + 21 _l 320 + 21 _l DROP ( 63 )
    526 BLK@@ BLK( 21 _l 320 + 10 _l DROP ( 94! ) ;
: CPFNT5x7 5 _w ! 7 _h !
    _h @@ ALLOT0 ( space char )
    530 527 DO I BLK@@ BLK( 12 _l 448 + 12 _l DROP LOOP ( 72 )
    530 BLK@@ BLK( 12 _l 448 + 10 _l DROP ( 94! ) ;
: CPFNT7x7 7 _w ! 7 _h !
    _h @@ ALLOT0 ( space char )
    536 531 DO I BLK@@ BLK( 9 _l 448 + 9 _l DROP LOOP ( 90 )
    536 BLK@@ BLK( 4 _l DROP ( 94! ) ;
( ----- 525 )
.X.X.XX.X.XXX...X..X...XX...X...............X.X..X.XX.XX.X.XXXX
.X.X.XXXXXX...XX.X.X..X..X.XXX.X............XX.XXX...X..XX.XX..
.X........XX.X..X.....X..X..X.XXX...XXX....X.X.X.X..X.XX.XXXXX.
......XXXXX.X..X.X....X..X.X.X.X..X.......X..X.X.X.X....X..X..X
.X....X.X.X...X.XX.....XX........X......X.X...X.XXXXXXXX...XXX.
.XXXXXXXXXXX........X...X..XX..X..X.XX..XXXX.XXXXXX.XXX.XXXXXXX
X....XX.XX.X.X..X..X.XXX.X...XXXXX.XX.XX..X.XX..X..X..X.X.X...X
XXX.X.XXXXXX......X.......X.X.XXXXXXXX.X..X.XXX.XX.X.XXXX.X...X
X.XX..X.X..X.X..X..X.XXX.X....X..X.XX.XX..X.XX..X..X.XX.X.X...X
XXXX..XXXXX....X....X...X...X..XXX.XXX..XXXX.XXXX...XXX.XXXXXX.
X.XX..X.XXX.XXXXX.XXXXX..XXXXXX.XX.XX.XX.XX.XXXXXXXX..XXX.X....
XX.X..XXXX.XX.XX.XX.XX.XX...X.X.XX.XX.XX.XX.X..XX..X....XX.X...
X..X..XXXX.XX.XXX.X.XXX..X..X.X.XX.XXXX.X..X..X.X...X...X......
XX.X..X.XX.XX.XX..XXXX.X..X.X.X.XX.XXXXX.X.X.X..X....X..X......
X.XXXXX.XX.XXXXX...XXX.XXX..X.XXX.X.X.XX.X.X.XXXXXX..XXXX...XXX
!"#$%&'()*+,-./0123456789:;<=>?@@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_
( ----- 526 )
X.....X.......X....XX...X...X...XX..XX.......................X.
.X.XX.X...XX..X.X.X...X.X........X.X.X.X.XXX..X.XX..XX.XX.XXXXX
.....XXX.X...XXX.XXX.X.XXX..X...XXX..X.XXXX.XX.XX.XX.XX..XX..X.
...XXXX.XX..X.XXX.X...XXX.X.X...XX.X.X.X.XX.XX.XXX..XXX....X.X.
...XXXXX..XX.XX.XXX..XX.X.X.X.XX.X.X.XXX.XX.X.X.X....XX..XX..XX
...................XX.X.XX.....................................
X.XX.XX.XX.XX.XXXX.X..X..X..XX
X.XX.XX.X.X..X..XXX...X...XXX.
X.XX.XXXX.X..X.XX..X..X..X....
XXX.X.X.XX.X.X.XXX.XX.X.XX....
`abcdefghijklmnopqrstuvwxyz{|}~
( ----- 527 )
..X...X.X........X..............X....X....X.................
..X...X.X..X.X..XXXXX...X.XX....X...X......X.X.X.X..X.......
..X.......XXXXXX.......X.X..X......X........X.XXX...X.......
..X........X.X..XXX...X...XX.......X........XXXXXXXXXXX.....
..........XXXXX....X.X....XX.X.....X........X.XXX...X.......
..X........X.X.XXXX.X...XX..X.......X......X.X.X.X..X.....X.
..X..............X.......XXX.X.......X....X..............X..
................XXX...XX..XXX..XXX...XX.XXXXX.XXX.XXXXX.XXX.
..............XX...X.X.X.X...XX...X.X.X.X....X........XX...X
.............X.X..XX...X.....X....XX..X.XXXX.X........XX...X
XXXXX.......X..X.X.X...X....X...XX.XXXXX....XXXXX....X..XXX.
...........X...XX..X...X...X......X...X.....XX...X..X..X...X
......XX..X....X...X...X..X...X...X...X.X...XX...X.X...X...X
......XX........XXX..XXXXXXXXX.XXX....X..XXX..XXX.X.....XXX.
!"#$%&'()*+,-./012345678
( ----- 528 )
.XXX...............X.....X.....XXX..XXX..XXX.XXXX..XXX.XXXX.
X...X..X....X....XX.......XX..X...XX...XX...XX...XX...XX...X
X...X..X....X...XX..XXXXX..XX.....XX..XXX...XX...XX....X...X
.XXX...........X.............X...X.X..XXXXXXXXXXX.X....X...X
....X..X....X...XX..XXXXX..XX...X..X....X...XX...XX....X...X
....X..X...X.....XX.......XX.......X...XX...XX...XX...XX...X
.XXX...............X.....X......X...XXX.X...XXXXX..XXX.XXXX.
XXXXXXXXXX.XXX.X...X.XXX....XXX..X.X....X...XX...X.XXX.XXXX.
X....X....X...XX...X..X......XX.X..X....XX.XXXX..XX...XX...X
X....X....X....X...X..X......XXX...X....X.X.XXX..XX...XX...X
XXXX.XXXX.X..XXXXXXX..X......XX....X....X...XX.X.XX...XXXXX.
X....X....X...XX...X..X......XXX...X....X...XX..XXX...XX....
X....X....X...XX...X..X..X...XX.X..X....X...XX..XXX...XX....
XXXXXX.....XXX.X...X.XXX..XXX.X..X.XXXXXX...XX...X.XXX.X....
9:;<=>?@@ABCDEFGHIJKLMNOP
( ----- 529 )
.XXX.XXXX..XXX.XXXXXX...XX...XX...XX...XX...XXXXXXXXX.......
X...XX...XX...X..X..X...XX...XX...XX...XX...XX...XX....X....
X...XX...XX......X..X...XX...XX...X.X.X..X.X....X.X.....X...
X...XXXXX..XXX...X..X...XX...XX...X..X....X....X..X......X..
X.X.XX.X......X..X..X...XX...XX.X.X.X.X...X...X...X.......X.
X..XXX..X.X...X..X..X...X.X.X.X.X.XX...X..X..X...XX........X
.XXXXX...X.XXX...X...XXX...X...X.X.X...X..X..XXXXXXXX.......
..XXX..X.........X..........................................
....X.X.X.........X.........................................
....XX...X...........XXX.X.....XXX.....X.XXX..XX....XXXX....
....X...................XX....X...X....XX...XX..X..X..XX....
....X................XXXXXXX..X......XXXXXXXXX......XXXXXX..
....X...............X...XX..X.X...X.X..XX....XXX......XX..X.
..XXX.....XXXXX......XXXXXXX...XXX...XXX.XXXXX......XX.X..X.
QRSTUVWXYZ[\]^_`abcdefgh
( ----- 530 )
............................................................
............................................................
..X......XX..X..XX...X.X.XXX...XXX.XXX....XXXX.XX..XXX..X...
..........X.X....X..X.X.XX..X.X...XX..X..X..XXX...X....XXX..
..X......XXX.....X..X...XX...XX...XXXX....XXXX.....XXX..X...
..X...X..XX.X....X..X...XX...XX...XX........XX........X.X...
..X....XX.X..X...XX.X...XX...X.XXX.X........XX.....XXX...XX.
................................XX...X...XX.......
...............................X.....X.....X......
X...XX...XX...XX...XX...XXXXXX.X.....X.....X..X.X.
X...XX...XX...X.X.X..X.X....X.X......X......XX.X..
X...XX...XX...X..X....X....X...X.....X.....X......
X...X.X.X.X.X.X.X.X..X....X....X.....X.....X......
.XXX...X...X.X.X...XX....XXXXX..XX...X...XX.......
ijklmnopqrstuvwxyz{|}~
( ----- 531 )
..XX....XX.XX..XX.XX....XX..XX......XXX......XX.....XX...XX....
..XX....XX.XX..XX.XX..XXXXXXXX..XX.XX.XX....XX.....XX.....XX...
..XX....XX.XX.XXXXXXXXX.X......XX..XX.XX...XX.....XX.......XX..
..XX...........XX.XX..XXXXX...XX....XXX...........XX.......XX..
..XX..........XXXXXXX...X.XX.XX....XX.XX.X........XX.......XX..
...............XX.XX.XXXXXX.XX..XX.XX..XX..........XX.....XX...
..XX...........XX.XX...XX.......XX..XXX.XX..........XX...XX....
...........................................XXXX....XX....XXXX..
..XX.....XX............................XX.XX..XX..XXX...XX..XX.
XXXXXX...XX...........................XX..XX.XXX...XX.......XX.
.XXXX..XXXXXX........XXXXXX..........XX...XXXXXX...XX......XX..
XXXXXX...XX.........................XX....XXX.XX...XX.....XX...
..XX.....XX.....XX............XX...XX.....XX..XX...XX....XX....
...............XX.............XX...........XXXX..XXXXXX.XXXXXX.
!"#$%&'()*+,-./012
( ----- 532 )
.XXXX.....XX..XXXXXX...XXX..XXXXXX..XXXX...XXXX................
XX..XX...XXX..XX......XX........XX.XX..XX.XX..XX...............
....XX..XXXX..XXXXX..XX........XX..XX..XX.XX..XX...XX.....XX...
..XXX..XX.XX......XX.XXXXX....XX....XXXX...XXXXX...XX.....XX...
....XX.XXXXXX.....XX.XX..XX..XX....XX..XX.....XX...............
XX..XX....XX..XX..XX.XX..XX..XX....XX..XX....XX....XX.....XX...
.XXXX.....XX...XXXX...XXXX...XX.....XXXX...XXX.....XX....XX....
...XX.........XX......XXXX...XXXX...XXXX..XXXXX...XXXX..XXXX...
..XX...........XX....XX..XX.XX..XX.XX..XX.XX..XX.XX..XX.XX.XX..
.XX....XXXXXX...XX......XX..XX.XXX.XX..XX.XX..XX.XX.....XX..XX.
XX...............XX....XX...XX.X.X.XXXXXX.XXXXX..XX.....XX..XX.
.XX....XXXXXX...XX.....XX...XX.XXX.XX..XX.XX..XX.XX.....XX..XX.
..XX...........XX...........XX.....XX..XX.XX..XX.XX..XX.XX.XX..
...XX.........XX.......XX....XXXX..XX..XX.XXXXX...XXXX..XXXX...
3456789:;<=>?@@ABCD
( ----- 533 )
XXXXXX.XXXXXX..XXXX..XX..XX.XXXXXX..XXXXX.XX..XX.XX.....XX...XX
XX.....XX.....XX..XX.XX..XX...XX......XX..XX.XX..XX.....XXX.XXX
XX.....XX.....XX.....XX..XX...XX......XX..XXXX...XX.....XXXXXXX
XXXXX..XXXXX..XX.XXX.XXXXXX...XX......XX..XXX....XX.....XX.X.XX
XX.....XX.....XX..XX.XX..XX...XX......XX..XXXX...XX.....XX.X.XX
XX.....XX.....XX..XX.XX..XX...XX...XX.XX..XX.XX..XX.....XX...XX
XXXXXX.XX......XXXX..XX..XX.XXXXXX..XXX...XX..XX.XXXXXX.XX...XX
XX..XX..XXXX..XXXXX...XXXX..XXXXX...XXXX..XXXXXX.XX..XX.XX..XX.
XX..XX.XX..XX.XX..XX.XX..XX.XX..XX.XX..XX...XX...XX..XX.XX..XX.
XXX.XX.XX..XX.XX..XX.XX..XX.XX..XX.XX.......XX...XX..XX.XX..XX.
XXXXXX.XX..XX.XXXXX..XX..XX.XXXXX...XXXX....XX...XX..XX.XX..XX.
XX.XXX.XX..XX.XX.....XX.X.X.XX.XX......XX...XX...XX..XX.XX..XX.
XX..XX.XX..XX.XX.....XX.XX..XX..XX.XX..XX...XX...XX..XX..XXXX..
XX..XX..XXXX..XX......XX.XX.XX..XX..XXXX....XX....XXXX....XX...
EFGHIJKLMNOPQRSTUVWXYZ[\]^_
( ----- 534 )
XX...XXXX..XX.XX..XX.XXXXXX.XXXXX.........XXXXX....XX..........
XX...XXXX..XX.XX..XX.....XX.XX.....XX........XX...XXXX.........
XX.X.XX.XXXX..XX..XX....XX..XX......XX.......XX..XX..XX........
XX.X.XX..XX....XXXX....XX...XX.......XX......XX..X....X........
XXXXXXX.XXXX....XX....XX....XX........XX.....XX................
XXX.XXXXX..XX...XX...XX.....XX.........XX....XX................
XX...XXXX..XX...XX...XXXXXX.XXXXX.........XXXXX.........XXXXXXX
.XX...........XX................XX..........XXX.........XX.....
..XX..........XX................XX.........XX.....XXXX..XX.....
...XX...XXXX..XXXXX...XXXX...XXXXX..XXXX...XX....XX..XX.XXXXX..
...........XX.XX..XX.XX..XX.XX..XX.XX..XX.XXXXX..XX..XX.XX..XX.
........XXXXX.XX..XX.XX.....XX..XX.XXXXXX..XX.....XXXXX.XX..XX.
.......XX..XX.XX..XX.XX..XX.XX..XX.XX......XX........XX.XX..XX.
........XXXXX.XXXXX...XXXX...XXXXX..XXXX...XX.....XXX...XX..XX.
WXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
( ----- 535 )
..XX.....XX...XX......XXX......................................
..............XX.......XX......................................
.XXX....XXX...XX..XX...XX....XX.XX.XXXXX...XXXX..XXXXX...XXXXX.
..XX.....XX...XX.XX....XX...XXXXXXXXX..XX.XX..XX.XX..XX.XX..XX.
..XX.....XX...XXXX.....XX...XX.X.XXXX..XX.XX..XX.XX..XX.XX..XX.
..XX.....XX...XX.XX....XX...XX.X.XXXX..XX.XX..XX.XXXXX...XXXXX.
.XXXX..XX.....XX..XX..XXXX..XX...XXXX..XX..XXXX..XX.........XX.
...............XX..............................................
...............XX..............................................
XX.XX...XXXXX.XXXXX..XX..XX.XX..XX.XX...XXXX..XX.XX..XX.XXXXXX.
XXX.XX.XX......XX....XX..XX.XX..XX.XX.X.XX.XXXX..XX..XX....XX..
XX......XXXX...XX....XX..XX.XX..XX.XX.X.XX..XX...XX..XX...XX...
XX.........XX..XX....XX..XX..XXXX..XXXXXXX.XXXX...XXXXX..XX....
XX.....XXXXX....XXX...XXXXX...XX....XX.XX.XX..XX.....XX.XXXXXX.
ijklmnopqrstuvwxyz{|}~
( ----- 536 )
...XX....XX...XX......XX...X
..XX.....XX....XX....XX.X.XX
..XX.....XX....XX....X...XX.
XXX......XX.....XXX.........
..XX.....XX....XX...........
..XX.....XX....XX...........
...XX....XX...XX............
{|}~
@


1.70
log
@6809: fix init and 1- and remove tmp code

We have BOOT!
@
text
@d10 1
a10 1
170-259 unused                260 Cross compilation
d925 3
a927 9
( ----- 260 )
Cross compilation program

This programs allows cross compilation of boot binary and
core. Run "262 LOAD" right before your cross compilation and
then "270 LOAD" to apply xcomp overrides.

See /doc/cross.txt for details.
( ----- 262 )
d940 1
a940 2
1 4 LOADR+
( ----- 263 )
d951 1
a951 1
( ----- 264 )
d965 1
a965 1
( ----- 265 )
d977 1
a977 1
( ----- 266 )
d990 1
a990 1
( ----- 270 )
@


1.69
log
@core: fix endian issues in RDLN and _eot
@
text
@d2300 3
a2302 2
BIN( @@ 4 + () LDX, SYSVARS 0x02 ( CURRENT ) + () STX,
BRA, L2 ( exec ) BBR,
d2356 1
a2356 1
CODE 1- 1 S+N TST, IFZ, S+0 DEC, THEN 1 S+N DEC, ;CODE
a2403 8
( ----- 479 )
: (emit) 0xa0 RAM+ TUCK @@ C!+ SWAP ! ;
: BOOT 0x400 0xa0 RAM+ ! ['] (emit) ['] EMIT **!
  LIT" ab" DUP 3 []= . LIT" ab" LIT" CD" 3 []= . SPC> 'X' EMIT
  LIT" EMIT" FIND .X .X LIT" FOO" FIND .X .X
  0x80 0 DO I EMIT LOOP
  BEGIN (key?) IF EMIT THEN AGAIN ;
XCURRENT @@ _xapply ORG @@ 4 + T!
@


1.68
log
@Make Z80 boot code and drivers more compact in blkfs
@
text
@d1575 9
a1583 9
    IN$ BEGIN
    ( buffer overflow? same as if we typed a newline )
    IN> @@ IN( - 0x3e = IF CR ELSE KEY THEN ( c )
    DUP BS? IF
        IN> @@ IN( > IF -1 IN> +! BS EMIT THEN SPC> BS EMIT
    ELSE DUP LF = IF DROP CR THEN ( same as CR )
        DUP SPC >= IF DUP EMIT ( echo back ) THEN
        DUP IN> @@ ! 1 IN> +! THEN ( c )
    DUP CR = SWAP EOT? OR UNTIL IN( IN> ! ;
d1585 5
a1589 5
    IN> @@ C@@ ( c )
    DUP IF ( not EOL? good, inc and return ) 1 IN> +!
    ELSE ( EOL ? readline. we still return null though )
        SPC> LIT" ok" STYPE NL> RDLN NL>
    THEN ( c ) ;
d1608 1
a1608 1
: _eot 0x0401 _wb ! _wb ;
@


1.67
log
@6809: add LPC to assembler and move (key?) to coco2 blkfs

Drivers belong in arch-specific blkfs...
@
text
@d11 2
a12 2
280 Z80 boot code             320 Z80 Drivers
330-349 unused                350 Core words
d1014 1
a1014 16
Z80 boot code

This assembles the boot binary. It requires the Z80 assembler
(B5) and cross compilation setup (B260). It requires some
constants to be set. See doc/bootstrap.txt for details.

RESERVED REGISTERS: At all times, IX points to RSP TOS and BC
is IP. SP points to PSP TOS, but you can still use the stack
in native code. you just have to make sure you've restored it
before "next".

The boot binary is loaded in 2 parts. The first part, "decla-
rations", are loaded after xcomp, before xcomp overrides, with
"281 LOAD". The rest, after xcomp overrides, with "282 318
LOADR".
( ----- 281 )
d1020 1
a1020 1
( ----- 282 )
d1031 1
a1031 1
( ----- 283 )
d1045 1
a1045 1
( ----- 284 )
d1061 1
a1061 1
( ----- 285 )
d1078 1
a1078 1
( ----- 286 )
d1092 1
a1092 1
( ----- 287 )
d1108 1
a1108 1
( ----- 288 )
d1112 24
a1135 13
    SYSVARS 0x02 ( CURRENT ) + LDHL(i), EXDEHL,
    HL POP, ( w ) chkPS, HL PUSH, ( --> lvl 1 )
	( First, figure out string len )
    A (HL) LDrr, A ORr,
	( special case. zero len? we never find anything. )
    IFZ, PUSH0, JPNEXT, THEN,
    BC PUSH, ( --> lvl 2, protect )
( Let's do something weird: We'll hold HL by the *tail*.
  Because of our dict structure and because we know our
  lengths, it's easier to compare starting from the end. )
    C A LDrr, B 0 LDri, ( C holds our length )
    BC ADDHLd, HL INCd, ( HL points to after-last-char )
                                                     ( cont . )
d1137 12
a1148 16
    BEGIN, ( loop )
    ( DE is a wordref, first step, do our len correspond? )
        HL PUSH, ( --> lvl 3 ) DE PUSH, ( --> lvl 4 )
        DE DECd, LDA(DE), 0x7f ANDi, ( remove IMMEDIATE flag )
        C CPr, IFZ,
            ( match, let's compare the string then )
            DE DECd, ( Skip prev field. One less because we )
            DE DECd, ( pre-decrement )
            B C LDrr, ( loop C times )
            BEGIN,
                ( pre-decrement for easier Z matching )
                DE DECd, HL DECd,
                LDA(DE), (HL) CPr,
                JRNZ, BREAK,
            DJNZ, AGAIN,
        THEN,                                         ( cont. )
d1150 9
a1158 13
( At this point, Z is set if we have a match. In all cases,
  we want to pop HL and DE )
        DE POP, ( <-- lvl 4 )
        IFZ, ( match, we're done! )
            HL POP, BC POP, HL POP, ( <-- lvl 1-3 ) DE PUSH,
            PUSH1, JPNEXT,
        THEN,
        ( no match, go to prev and continue )
        DE DECd, DE DECd, DE DECd, ( prev field )
        DE PUSH, ( --> lvl 4 )
        EXDEHL,
        LDDE(HL),
                                                      ( cont. )
d1160 8
a1167 14
        ( DE contains prev offset )
        HL POP, ( <-- lvl 4, prev field )
        DEZ, IFNZ, ( offset not zero )
            ( get absolute addr from offset )
            ( carry cleared from "or e" )
            DE SBCHLd,
            EXDEHL, ( result in DE )
        THEN,
        HL POP, ( <-- lvl 3 )
    JRNZ, AGAIN, ( loop-B292, try to match again )
    BC POP, ( <-- lvl 2 )
    ( Z set? end of dict, not found. "w" already on PSP TOS )
    PUSH0,
;CODE
a1168 24
CODE (br)
L1 BSET ( used in ?br and loop )
    LDA(BC), H 0 LDri, L A LDrr,
    RLA, IFC, H DECr, THEN,
    BC ADDHLd, B H LDrr, C L LDrr,
;CODE
CODE (?br)
    HL POP,
    HLZ,
    JRZ, L1 BWR ( br + 1. False, branch )
    ( True, skip next byte and don't branch )
    BC INCd,
;CODE
( ----- 293 )
CODE (loop)
    0 IX+ INC(IXY+), IFZ, 1 IX+ INC(IXY+), THEN, ( I++ )
    ( Jump if I <> I' )
    A 0 IX+ LDrIXY, 2 IX- CP(IXY+), JRNZ, L1 BWR ( branch )
    A 1 IX+ LDrIXY, 1 IX- CP(IXY+), JRNZ, L1 BWR ( branch )
    ( don't branch )
    IX DECd, IX DECd, IX DECd, IX DECd,
    BC INCd,
;CODE
( ----- 294 )
d1172 3
a1174 6
    IX RS_ADDR LDdi,
    DE BIN( @@ 0x0a ( main ) + LDd(i),
    lblexec @@ JP,
CODE ABORT
    SP PS_ADDR LDdi,
    JR, L1 BWR
d1177 13
a1189 26
    C 0 IX+ LDrIXY, B 1 IX+ LDrIXY,
    IX DECd, IX DECd,
    JPNEXT,
( ----- 295 )
CODE (n) ( number literal )
  ( Literal value to push to stack is next to (n) reference
    in the atom list. That is where IP is currently pointing.
    Read, push, then advance IP. )
    LDA(BC), L A LDrr, BC INCd,
    LDA(BC), H A LDrr, BC INCd,
    HL PUSH, ;CODE
CODE (b) ( byte literal )
    LDA(BC), L A LDrr, BC INCd,
    H 0 LDri, HL PUSH, ;CODE
( ----- 296 )
CODE (s) ( string literal )
( Like (n) but instead of being followed by a 2 bytes
  number, it's followed by a string. When called, puts the
  string's address on PS )
    BC PUSH,
    LDA(BC), C ADDr,
    IFC, B INCr, THEN,
    C A LDrr,
    BC INCd,
;CODE
( ----- 297 )
d1191 2
a1192 3
    HL POP, ( C ) DE POP, ( B ) IY POP, ( A ) chkPS,
    DE PUSH, ( B ) HL PUSH, ( C ) IY PUSH, ( A )
;CODE
d1194 2
a1195 3
    HL POP, ( C ) DE POP, ( B ) IY POP, ( A ) chkPS,
    HL PUSH, ( C ) IY PUSH, ( A ) DE PUSH, ( B )
;CODE
d1197 1
a1197 3
    HL POP, chkPS,
    HL PUSH, HL PUSH,
;CODE
d1199 2
a1200 4
    HL POP, chkPS, HL PUSH,
    HLZ, IFNZ, HL PUSH, THEN,
;CODE
( ----- 298 )
d1202 1
a1202 2
    HL POP, chkPS,
;CODE
d1204 2
a1205 4
    HL POP, ( B ) DE POP, ( A )
    chkPS,
    HL PUSH, ( B ) DE PUSH, ( A )
;CODE
d1207 3
a1209 5
    HL POP, ( B ) DE POP, ( A )
    chkPS,
    DE PUSH, ( A ) HL PUSH, ( B ) DE PUSH, ( A )
;CODE
( ----- 299 )
d1211 5
a1215 5
    HL POP, ( x2 ) L SLA, H RL,
    SP ADDHLd, LDDE(HL), DE PUSH,
    ( check PS range before returning )
    EXDEHL, HL PS_ADDR LDdi, DE SUBHLd,
    IFC, lbluflw @@ JP, THEN, ;CODE
d1218 3
a1220 3
    HL POP, ( b ) DE POP, ( a ) chkPS,
    DE PUSH, HL PUSH,
    DE PUSH, HL PUSH, ;CODE
d1222 1
a1222 1
( ----- 300 )
d1224 4
a1227 4
    HL POP, DE POP, chkPS,
    A E LDrr, L ANDr, L A LDrr,
    A D LDrr, H ANDr, H A LDrr,
    HL PUSH, ;CODE
d1229 4
a1232 4
    HL POP, DE POP, chkPS,
    A E LDrr, L ORr, L A LDrr,
    A D LDrr, H ORr, H A LDrr,
    HL PUSH, ;CODE
d1234 17
a1250 35
    HL POP, DE POP, chkPS,
    A E LDrr, L XORr, L A LDrr,
    A D LDrr, H XORr, H A LDrr,
    HL PUSH, ;CODE
( ----- 301 )
CODE NOT
    HL POP, chkPS,
    HLZ, PUSHZ, ;CODE
CODE +
    HL POP, DE POP, chkPS,
    DE ADDHLd, HL PUSH, ;CODE
CODE -
    DE POP, HL POP, chkPS,
    DE SUBHLd, HL PUSH, ;CODE
( ----- 302 )
CODE * EXX, ( protect BC )
    ( DE * BC -> DE (high) and HL (low) )
    DE POP, BC POP, chkPS,
    HL 0 LDdi,
    A 0x10 LDri,
    BEGIN,
        HL ADDHLd,
        E RL, D RL,
        IFC,
            BC ADDHLd,
            IFC, DE INCd, THEN,
        THEN,
        A DECr,
    JRNZ, AGAIN,
    HL PUSH,
EXX, ( unprotect BC ) ;CODE
( ----- 303 )
( Borrowed from http://wikiti.brandonw.net/ )
( Divides AC by DE and places the quotient in AC and the
  remainder in HL )
d1252 9
a1260 12
    DE POP, BC POP, chkPS,
    A B LDrr, B 16 LDri,
    HL 0 LDdi,
    BEGIN,
        SCF, C RL, RLA,
        HL ADCHLd, DE SBCHLd,
        IFC, DE ADDHLd, C DECr, THEN,
    DJNZ, AGAIN,
    B A LDrr,
    HL PUSH, BC PUSH,
EXX, ( unprotect BC ) ;CODE
( ----- 304 )
d1266 9
a1274 9
    HL POP, chkPS,
    ( we pre-dec to compensate for initialization )
    BEGIN,
        HL DECd, ( 6t )
        IFZ, ( 12t ) JPNEXT, THEN,
        A tickfactor @@ LDri, ( 7t )
        BEGIN, A DECr, ( 4t ) JRNZ, ( 12t ) AGAIN,
    JR, ( 12t ) AGAIN, ( outer: 37t inner: 16t )
( ----- 305 )
d1289 1
a1289 1
( ----- 306 )
d1303 1
a1303 1
( ----- 307 )
d1305 2
a1306 2
    L 0 IX+ LDrIXY, H 1 IX+ LDrIXY, IX DECd, IX DECd, HL PUSH,
;CODE
d1308 3
a1310 4
    DE POP, HL POP, chkPS,
    IX INCd, IX INCd, 0 IX+ L LDIXYr, 1 IX+ H LDIXYr,
    IX INCd, IX INCd, 0 IX+ E LDIXYr, 1 IX+ D LDIXYr,
;CODE
d1312 4
a1315 5
    L 0 IX+ LDrIXY, H 1 IX+ LDrIXY, IX DECd, IX DECd,
    E 0 IX+ LDrIXY, D 1 IX+ LDrIXY, IX DECd, IX DECd,
    DE PUSH, HL PUSH,
;CODE
( ----- 308 )
d1317 6
a1322 8
    L1 BSET ( loop )
        LDA(DE), DE INCd, CPI,
        IFNZ, PUSH0, EXX, JPNEXT, THEN,
        CPE L1 @@ JPc, ( BC not zero? loop )
    PUSH1, EXX, ;CODE
( ----- 309 )
CODE = DE POP, HL POP, chkPS,
    DE SUBHLd, PUSHZ, ;CODE
d1324 1
a1324 1
    DE SUBHLd, IFC, PUSH1, ELSE, PUSH0, THEN, ;CODE
d1326 1
a1326 1
    DE SUBHLd, IFC, PUSH1, ELSE, PUSH0, THEN, ;CODE
d1328 1
a1328 1
( ----- 310 )
d1330 1
a1330 1
    HL INCd, HL PUSH, ;CODE
d1332 1
a1332 1
    HL DECd, HL PUSH, ;CODE
d1334 11
a1344 11
    HL POP, ( n ) DE POP, ( c )
    A L LDrr, D XORr, D A LDrr,
    B 8 LDri, BEGIN,
        E SLA, D RL,
        IFC, ( msb is set, apply polynomial )
            A D LDrr, 0x10 XORi, D A LDrr,
            A E LDrr, 0x21 XORi, E A LDrr,
        THEN,
    DJNZ, AGAIN,
    DE PUSH, EXX, ( unprotect BC ) ;CODE
( ----- 311 )
d1346 4
a1349 6
    DE POP, ( u ) HL POP, ( n ) chkPS,
    A E LDrr,
    A ORr, IFNZ,
        BEGIN, H SRL, L RR, A DECr, JRNZ, AGAIN,
    THEN,
    HL PUSH, ;CODE
d1351 5
a1355 7
    DE POP, ( u ) HL POP, ( n ) chkPS,
    A E LDrr,
    A ORr, IFNZ,
        BEGIN, L SLA, H RL, A DECr, JRNZ, AGAIN,
    THEN,
    HL PUSH, ;CODE
( ----- 312 )
d1357 3
a1359 3
    HL POP, chkPS,
    D 0 LDri, E H LDrr, DE PUSH,
    E L LDrr, DE PUSH, ;CODE
d1361 4
a1364 4
    HL POP, chkPS,
    D 0 LDri, E L LDrr, DE PUSH,
    E H LDrr, DE PUSH, ;CODE
( ----- 320 )
d1367 3
a1369 3
321 AT28 EEPROM                322 SPI relay
325 TMS9918
( ----- 321 )
d1382 1
a1382 1
( ----- 322 )
d1392 2
a1393 2
Provides the SPI relay protocol. Load driver with "323 LOAD".
( ----- 323 )
d1407 1
a1407 1
( ----- 325 )
d1411 1
a1411 1
Load range B325-327 )
d1421 1
a1421 1
( ----- 326 )
d1435 1
a1435 1
( ----- 327 )
@


1.66
log
@6809: implement EXECUTE, 2DUP, XOR, []= and FIND

Also, fix |L and |M.
@
text
@d587 1
a2501 17
PC ," @@HPX08" CR C, ," AIQY19" 0 C,
   ," BJRZ2:" 0 C,  ," CKS_3:" 0 C,
   ," DLT_4," 0 C,  ," EMU" BS C, ," 5-" 0 C,
   ," FNV_6." 0 C,  ," GOW 7/" 0x80 C,
CODE (key?) ( -- c? f )
  ( PC ) # LDX,
  CLRA, CLRB, PSHS, D 0xfe # LDA, BEGIN, ( 8 times )
    0xff02 () STA, ( set col ) 0xff00 () LDB, ( read row )
    INCB, IFNZ, ( key pressed )
      DECB, 0xff # LDA, BEGIN, INCA, LSRB, BCS, AGAIN,
      ( X+A = our char ) X+A LDB, 1 S+N STB, ( char )
      1 # LDD, ( f ) PSHS, D CLRA, THEN,
    ( inc col ) 7 X+N LEAX,
    1 # ORCC, ROLA, BCS, AGAIN,
  CLRA, 0xff00 # LDX, 2 X+N STA, BEGIN, ( wait for keyup )
    X+0 LDA, INCA, BNE, AGAIN, ;CODE
( ----- 480 )
@


1.65
log
@Fix endian bug in INTERPRET
@
text
@d2397 2
a2398 1
BIN( @@ 4 + () LDX, BRA, L2 ( exec ) BBR,
d2401 1
d2420 2
d2447 1
d2482 1
a2482 1
  CLRA, 1 S+N LDB, PSHS, D S+0 CLR, ;CODE
d2484 1
a2484 1
  CLRA, S+0 LDB, PSHS, D 1 S+N CLR, ;CODE
d2486 15
d2517 1
a2517 1
( ----- 479 )
d2519 4
a2522 1
: BOOT 0x400 0xa0 RAM+ ! ['] (emit) ['] EMIT **! 'X' EMIT
@


1.64
log
@Fix endian issues in core
@
text
@d1820 3
a1822 5
: INTERPRET
    BEGIN
    WORD DUP @@ 0x0401 = ( EOT ) IF DROP EXIT THEN
    FIND NOT IF (parse) ELSE EXECUTE THEN
    AGAIN ;
@


1.63
log
@6809: keyboard!

Debouncing is weird, but it kinda works.

Also, add *, |M, |L.
@
text
@d1604 1
a1604 1
XCURRENT @@ _xapply ORG @@ 0x06 ( stable ABI uflw ) + !
d1606 1
a1606 1
XCURRENT @@ _xapply ORG @@ 0x13 ( stable ABI oflw ) + !
d1849 1
a1849 1
XCURRENT @@ _xapply ORG @@ 0x0a ( stable ABI (main) ) + !
d1860 1
a1860 1
XCURRENT @@ _xapply ORG @@ 0x04 ( stable ABI BOOT ) + !
@


1.62
log
@Remove unused ><, 0>= and simplify =><=
@
text
@d2463 7
a2469 2
  2 S+N LDX, 2 S+N STD, ( rem ) S+0 STX, ( quotient )
;CODE
d2478 4
d2483 17
d2501 2
a2502 2
: BOOT 0x400 0xa0 RAM+ ! ['] (emit) ['] EMIT **!
  LIT" HELLO WORLD!" STYPE BYE ;
@


1.61
log
@Define formatting words a bit earlier in core words

This will facilitate the progression of the 6809 port.
@
text
@d1575 2
a1576 3
: 0< 32767 > ; : >= < NOT ; : <= > NOT ; : 0>= 0< NOT ;
: >< ( n l h -- f ) 2 PICK > ( n l f ) ROT> > AND ;
: =><= 2 PICK >= ( n l f ) ROT> >= AND ;
@


1.60
log
@Remove WIPED? from core

Not used
@
text
@d1610 12
d1637 1
a1637 1
( ----- 358 )
d1648 1
a1648 1
( ----- 359 )
d1662 1
a1662 1
( ----- 360 )
d1671 1
a1671 1
( ----- 361 )
d1688 1
a1688 1
( ----- 362 )
d1702 1
a1702 1
( ----- 363 )
d1714 1
a1714 2
        OVER 0x2e RAM+ = OVER WS? OR
    UNTIL ( a c )
d1717 1
a1717 4
( ----- 364 )
: IMMEDIATE
    CURRENT @@ 1-
    DUP C@@ 128 OR SWAP C! ;
d1742 2
a1797 23
( ----- 371 )
: :* ( addr -- ) (entry) 4 ( alias ) C, , ;
: :** ( addr -- ) (entry) 5 ( ialias ) C, , ;
: . ( n -- )
    ?DUP NOT IF '0' EMIT EXIT THEN ( 0 is a special case )
    ( handle negative )
    DUP 0< IF '-' EMIT -1 * THEN
    999 SWAP        ( stop indicator )
    BEGIN
        10 /MOD ( r q )
        SWAP '0' + SWAP ( d q )
        ?DUP NOT UNTIL
    BEGIN EMIT DUP '9' > UNTIL DROP ( drop stop ) ;
( ----- 372 )
: ? @@ . ;
: _
    DUP 9 > IF 10 - 'a' +
    ELSE '0' + THEN ;
( For hex display, there are no negatives )
: .x
    0xff AND 16 /MOD ( l h )
    _ EMIT _ EMIT ;
: .X |M .x .x ;
@


1.59
log
@Make parsing words endian-independant

And also make them a bit tighter.
@
text
@a1785 3
: WIPED? ( -- f )
    1 ( f ) BLK) BLK( DO
        I C@@ IF DROP 0 ( f ) LEAVE THEN LOOP ;
@


1.58
log
@6809 port: HELLO WORLD!
@
text
@d1573 1
a1573 1
1 25 LOADR+
a1609 1
( r c -- r f )
d1612 1
a1612 1
: _pdacc
d1616 1
a1616 2
( ----- 358 )
: _pd ( a -- n f, parse decimal )
a1619 2
( if we can do the whole string, success. if _pdacc returns
  false before, failure. )
d1625 11
d1637 6
a1642 3
( strings being sent to parse routines are always null
  terminated )

d1644 6
a1649 6
    ( apostrophe is ASCII 39 )
    DUP 1+ C@@ 39 = OVER 3 + C@@ 39 = AND  ( a f )
    NOT IF 0 EXIT THEN   ( a 0 )
    ( surrounded by apos, good, return )
    2 + C@@ 1                             ( n 1 )
;
a1650 34
( returns negative value on error )
: _            ( c -- n )
    DUP '0' '9' =><= IF '0' - EXIT THEN
    DUP 'a' 'f' =><= IF 0x57 ( 'a' - 10 ) - EXIT THEN
    DROP -1 ( bad )
;
: _ph          ( a -- n f, parse hex )
    ( '0': ASCII 0x30 'x': 0x78 0x7830 )
    DUP 1+ @@ 0x7830 = NOT IF 0 EXIT THEN ( a 0 )
    ( We have "0x" prefix )
    DUP C@@ ( a len )
    0 SWAP 1+ ( len+1 ) 3 DO ( a r )
        OVER I + C@@ ( a r c ) _ ( a r n )
        DUP 0< IF 2DROP 0 UNLOOP EXIT THEN
        SWAP 4 LSHIFT + ( a r*16+n ) LOOP
    NIP 1 ;
( ----- 361 )
: _pb          ( a -- n f, parse binary )
    ( '0': ASCII 0x30 'b': 0x62 0x6230 )
    DUP 1+ @@ 0x6230 = NOT IF 0 EXIT THEN ( a 0 )
    ( We have "0b" prefix )
    DUP C@@ ( a len )
    0 SWAP 1+ ( len+1 ) 3 DO ( a r )
        OVER I + C@@ ( a r c )
        DUP '0' '1' =><= NOT IF 2DROP 0 UNLOOP EXIT THEN
        '0' - SWAP 1 LSHIFT + ( a r*2+n ) LOOP
    NIP 1 ;
: (parse) ( a -- n )
    _pc IF EXIT THEN
    _ph IF EXIT THEN
    _pb IF EXIT THEN
    _pd IF EXIT THEN
    ( nothing works ) (wnf) ;
( ----- 362 )
d1659 1
a1659 1
( ----- 363 )
d1676 1
a1676 1
( ----- 364 )
d1690 1
a1690 1
( ----- 365 )
d1706 1
a1706 1
( ----- 366 )
d1711 1
a1711 1
( ----- 367 )
d1725 1
a1725 1
( ----- 368 )
d1734 1
a1734 1
( ----- 369 )
d1747 1
a1747 1
( ----- 370 )
d1761 1
a1761 1
( ----- 371 )
d1778 1
a1778 1
( ----- 372 )
d1791 1
a1791 1
( ----- 373 )
d1804 1
a1804 1
( ----- 374 )
d1814 1
a1814 1
( ----- 375 )
d1826 1
a1826 1
( ----- 376 )
d1836 1
a1836 1
( ----- 377 )
d1847 1
a1847 1
( ----- 378 )
@


1.57
log
@6809: fix bad opcode in assembler
@
text
@d666 1
a666 1
    I _cpos DUP C@@ SPC < IF SPC SWAP C! ELSE DROP THEN LOOP ;
d2444 3
d2449 8
a2456 5
CODE @@ [S+0] LDD, S+0 STD, ;CODE
CODE C@@ [S+0] LDB, CLRA, S+0 STD, ;CODE
CODE ! PULS, X PULS, D X+0 STD, ;CODE
CODE C! PULS, X PULS, D X+0 STB, ;CODE
( ----- 472 )
d2460 1
d2471 1
a2471 1
( ----- 473 )
d2476 8
a2483 4
CODE I -2 S+N LDD, PSHS, D ;CODE
CODE I' -4 S+N LDD, PSHS, D ;CODE
CODE J -6 S+N LDD, PSHS, D ;CODE
( ----- 474 )
d2491 7
a2497 1
( ----- 475 )
d2506 1
a2506 1
( ----- 476 )
d2514 1
a2514 1
( ----- 477 )
d2516 2
a2517 2
: .1 '0' + (emit) ;
: BOOT 0x400 0xa0 RAM+ ! 5 2 /MOD .1 .1 BYE ;
@


1.56
log
@Move _crc16 from SDC subsystem to z80 boot code

This routine is used by the new XMODEM word in Remote Shell.
Also, make the SDC subsystem a bit tighter in its blocks.
@
text
@d547 1
a547 1
0xba OP1 ORA,         0xca OP1 ORB,       0x1a OP1 ORCC,
@


1.55
log
@Add XMODEM words to Remote Shell

These new words imperfectly implement the XMODEM protocol
and allow the use of "sx" and "rx" tools, which should
make in-house tools I've created for data transfer obsolete.

Also, remove rsh> and rsh<? aliases. For simplicity, we say
that all RS-232 drivers must provide RX<? and TX> words.
@
text
@d14 4
a17 3
420 SD Card subsystem         440 8086 boot code
460-469 unused                470 6809 boot code (WIP)
480-519 unused                520 Fonts
d1422 1
a1422 2
CODE 1+
    HL POP, chkPS,
d1424 1
a1424 2
CODE 1-
    HL POP, chkPS,
d1426 11
d2045 2
a2046 3
SD Card subsystem

Load range: B423-B436
a2047 27
This subsystem is designed for a ad-hoc adapter card that acts
as a SPI relay between the z80 bus and the SD card. It requires
a driver providing the SPI Relay protocol. You need to define
SDC_DEVID to specify which ID will be supplied to (spie).

Through that layer, this driver implements the SDC protocol
allowing it to provide BLK@@ and BLK!.
( ----- 423 )
( Computes n into crc c with polynomial 0x1021 )
CODE _crc16  ( c n -- c ) EXX, ( protect BC )
    HL POP, ( n ) DE POP, ( c )
    A L LDrr, D XORr, D A LDrr,
    B 8 LDri,
    BEGIN,
        E SLA, D RL,
        IFC, ( msb is set, apply polynomial )
            A D LDrr, 0x10 XORi, D A LDrr,
            A E LDrr, 0x21 XORi, E A LDrr,
        THEN,
    DJNZ, AGAIN,
    DE PUSH,
EXX, ( unprotect BC ) ;CODE
( ----- 424 )
( -- n )
: _idle 0xff (spix) ;

( -- n )
d2050 1
a2050 1
: _wait
d2052 2
a2053 4
        DROP _idle DUP 0xff = NOT IF LEAVE THEN
    LOOP ;
( ----- 425 )
( -- )
d2062 2
a2063 3
: _ready BEGIN _idle 0xff = UNTIL ;
( ----- 426 )
( c n -- c )
d2067 1
a2067 1
: _crc7
d2076 1
a2076 3
    LOOP
;
( ----- 427 )
d2078 2
a2079 3
( n c -- c )
: _s+crc SWAP DUP (spix) DROP _crc7 ;
( ----- 428 )
d2094 2
a2095 3
    _wait  ( wait for a valid response... )
;
( ----- 429 )
d2111 1
a2111 1
( ----- 430 )
d2128 1
a2128 1
( ----- 431 )
d2145 2
a2146 2
( ----- 432 )
: _  ( dstaddr blkno -- )
d2151 7
a2157 13
    0 SWAP               ( crc a )
    512 0 DO             ( crc a )
        _idle            ( crc a n )
        DUP ROT C!+      ( crc n a+1 )
        ROT> _crc16      ( a+1 crc )
        SWAP             ( crc a+1 )
    LOOP
    DROP                 ( crc1 )
    _idle 8 LSHIFT _idle +  ( crc2 )
    _wait DROP 0 (spie)
    = NOT IF _err THEN ;
( ----- 433 )
: SDC@@
d2159 3
a2161 4
    1+ BLK( 512 + SWAP _
;
( ----- 434 )
: _  ( srcaddr blkno -- )
d2166 4
a2169 8
    512 0 DO         ( crc a )
        C@@+          ( crc a+1 n )
        ROT OVER     ( a n crc n )
        _crc16       ( a n crc )
        SWAP         ( a crc n )
        (spix) DROP  ( a crc )
        SWAP         ( crc a )
    LOOP
d2173 1
a2173 2
( ----- 435 )
: SDC!
d2175 1
a2175 2
    1+ BLK( 512 + SWAP _
;
@


1.54
log
@6809 asm: add R+0 shortcuts

"0 R+N" is the most common type of indexing so I'm making it
a little bit more readable with R+0.
@
text
@d796 2
a797 3
0 :* rsh<? 0 :* rsh>
: _<< ( print everything available from rsh<? )
    BEGIN rsh<? IF EMIT ELSE EXIT THEN AGAIN ;
d799 3
a801 3
    BEGIN _<< 100 TICKS rsh<? IF EMIT ELSE EXIT THEN AGAIN ;
: rsh< BEGIN rsh<? UNTIL ;
: _<<1r rsh< EMIT _<<r ;
d803 1
a803 1
    KEY? IF DUP EOT? IF DROP EXIT ELSE rsh> THEN THEN
d806 2
a807 2
    C@@+ ( s len ) 0 DO C@@+ rsh> _<<r LOOP DROP _<<r CR rsh>
    rsh< DROP _<<r ;
d809 1
a809 1
    rstype BEGIN rsh< WS? NOT UNTIL _<<1r ;
d812 1
a812 1
: out unpack rsh> rsh> ; : out2 |M out out ;
d823 42
d955 1
a955 1
: X'? WORD _xfind _xapply ;
@


1.53
log
@6809 port: still making progress

I can now load B354! Not all words in there have been tested, but
important ones were.
@
text
@d460 1
a460 2

: D 0 ; : X 1 ; : Y 2 ; : U 3 ; : S 4 ;
d463 4
a466 10
( Immediate )
: # ( n ) 1 0 ;
( Direct )
: <> ( n ) 1 0x10 ;
( Extended )
: () ( n ) |T 2 0x30 ;
( Extended Indirect )
: [] ( n ) 0b10011111 3 0x20 ;
1 9 LOADR+
( ----- 051 )
d472 2
d483 1
d486 2
d2425 1
a2425 1
  0 X+N TST, IFZ, 1 X+N JMP, THEN, ( fast path for native )
d2429 2
a2430 2
      0 X+N LDX, DECA, BEQ, L2 ( exec ) BBR, ( alias )
      DECA, IFZ, ( ialias ) 0 X+N LDX, BRA, L2 BBR, THEN,
d2434 1
a2434 1
  U++ STY, X Y TFR, Y++ TST, 0 X+N LDX, BRA, L2 ( exec ) BBR,
d2443 4
a2446 4
CODE @@ 0 [S+N] LDD, 0 S+N STD, ;CODE
CODE C@@ 0 [S+N] LDB, CLRA, 0 S+N STD, ;CODE
CODE ! PULS, X PULS, D 0 X+N STD, ;CODE
CODE C! PULS, X PULS, D 0 X+N STB, ;CODE
d2450 1
a2450 1
CODE DUP ( a -- a a ) 0 S+N LDD, PSHS, D ;CODE
d2452 1
a2452 1
  0 S+N LDD, 2 S+N LDX, 0 S+N STX, 2 S+N STD, ;CODE
d2455 2
a2456 2
  4 S+N LDX, ( a ) 2 S+N LDD, ( b ) 4 S+N STD, 0 S+N LDD, ( c )
  2 S+N STD, 0 S+N STX, ;CODE
d2458 1
a2458 1
  0 S+N LDX, ( c ) 2 S+N LDD, ( b ) 0 S+N STD, 4 S+N LDD, ( a )
d2470 3
a2472 3
CODE AND PULS, D 0 S+N ANDA, 1 S+N ANDB, 0 S+N STD, ;CODE
CODE OR PULS, D 0 S+N ORA, 1 S+N ORB, 0 S+N STD, ;CODE
CODE + ( a b -- a+b ) PULS, D 0 S+N ADDD, 0 S+N STD, ;CODE
d2474 3
a2476 3
  2 S+N LDD, S++ SUBD, 0 S+N STD, ;CODE
CODE 1+ 1 S+N INC, LBNE, lblnext BBR, 0 S+N INC, ;CODE
CODE 1- 1 S+N TST, IFZ, 0 S+N DEC, THEN 1 S+N DEC, ;CODE
d2481 2
a2482 2
    ROLB, ROLA, 0 S+N SUBD,
    IF<, 0 S+N ADDD, 3 S+N DEC, ( a lsb ) THEN,
d2484 1
a2484 1
  2 S+N LDX, 2 S+N STD, ( rem ) 0 S+N STX, ( quotient )
d2488 5
a2492 5
  1 # ANDB, CLRA, 0 S+N STD, ;CODE
CODE = PULS, D 0 S+N CMPD, BRA, L4 ( PUSH Z ) BBR,
CODE NOT 0 S+N LDB, 1 S+N ORB, BRA, L4 ( PUSH Z ) BBR,
L4 BSET ( PUSH C ) CCR B TFR, 1 # ANDB, CLRA, 0 S+N STD, ;CODE
CODE > PULS, D 0 S+N CMPD, BRA, L4 ( PUSH C ) BBR,
@


1.52
log
@Swap DOES> word's PFA and does-addr

This allows such word to have more than 2b attached to them.
Also, fix 8086 DOES> execution model which was broken.
@
text
@d2446 1
d2449 3
d2453 21
d2477 23
a2499 3
( ----- 472 )
: (emit) 0xa0 RAM+ @@ C! 0xa0 RAM+ @@ 1 + 0xa0 RAM+ ! ;
: BOOT 0x400 0xa0 RAM+ ! 'A' 7 + DUP (emit) 1 - (emit) BYE ;
@


1.51
log
@6809: implement all word types

The wheel is beginning to turn, now it's a matter of slowly
including all words from the Forth core.

Also, add 6809 ;CODE and fix broken (xentry).
@
text
@d1050 1
a1050 1
    HL PUSH, ( PFA ) HL INCd, HL INCd, LDDE(HL), EXDEHL,
d1723 7
a1729 9
: DOES>
    3 ( does ) CURRENT @@ C! ( make CURRENT into a DOES )
    ( When we have a DOES>, we forcefully place HERE to 4
      bytes after CURRENT. This allows a DOES word to use ","
      and "C," without messing everything up. )
    CURRENT @@ 3 + H !
    ( HERE points to where we should write R> ) R> ,
    ( We're done. Because we've popped RS, we'll exit parent
      definition ) ;
d2223 3
a2225 5
AL DECr, IFZ, ( does )
    DI PUSHx, DI INCx, DI INCx, DI [DI] x[] MOV[], THEN,
( alias, ialias, or const ) DI [DI] x[] MOV[], ( rd PFA )
AL DECr, IFZ, ( alias ) lblexec @@ RPCs, THEN,
AL DECr, IFZ, ( ialias )
d2227 3
a2229 1
AL DECr, IFZ, ( const ) DI PUSHx, JMPs, lblnext @@ RPCs, THEN,
d2434 1
a2434 1
    PSHS, X ( PFA ) 2 [X+N] LDX, ( X=DOES> addr )
@


1.50
log
@xcomp: make (xentry) endian-aware
@
text
@d599 1
d897 2
a898 2
: (xentry) WORD C@@+ TUCK MOVE, HERE XCURRENT @@ - ,
    C, HERE XCURRENT T! ;
d2429 13
a2441 4
  X+ TST, IFZ, 0 X+N JMP, ELSE, X Y TFR, Y++ TST,
    0 X+N LDX, BRA, L2 ( exec ) BBR, THEN,
L1 FSET ( main ) 0xc000 () LDA, INCA, 0x400 () STA,
PS_ADDR # LDS, BIN( @@ 4 + () LDX, BRA, L2 ( exec ) BBR,
d2443 3
a2445 3
CODE EXIT 0x400 # LDX, PULS, D X+ STB, INCB, X+ STB,
BEGIN, BRA, AGAIN,
( ----- 471 )
d2447 11
a2457 2
CODE + PULS, D 0 S+N ADDD, 0 S+N STD, ;CODE
: BOOT 'A' 3 + ; XCURRENT @@ _xapply ORG @@ 4 + T!
@


1.49
log
@xcomp: remove mis-documentation
@
text
@a891 1
CREATE CURRENT^ CURRENT @@ ,
d896 5
a900 4
: XCON CURRENT @@ CURRENT^ ! XCURRENT @@ CURRENT ! ;
: XCOFF CURRENT @@ XCURRENT ! CURRENT^ @@ CURRENT ! ;
: (xentry) XCON (entry) XCOFF ; : XCREATE (xentry) 2 C, ;
: XCONSTANT (xentry) 6 C, T, ; : XIMM XCON IMMEDIATE XCOFF ;
@


1.48
log
@xcomp: minimize the number of XFIND calls

Now that XFIND is in Forth, it's really slow. Let's avoid
spurious calls to it...
@
text
@a889 16
This unit depends on a properly initialized z80a with ORG and
BIN( set. That is how we determine compilation offsets.

This redefines defining words to achieve cross compilation.
The goal is two-fold:

1. Add an offset to all word references in definitions.
2. Don't shadow important words we need right now.

                                                        (cont.)
( ----- 261 )
Words overrides like ":", "IMMEDIATE" and "CODE" are not
automatically shadowed to allow the harmless inclusion of
this unit. This shadowing has to take place in your xcomp
configuration.

@


1.47
log
@Replace native _find with FIND

We don't need to FIND with an alternate dict anymore.
@
text
@d910 3
d916 1
a916 2
: XCONSTANT (xentry) 6 C, T, ;
: XCODE XCON CODE XCOFF ; : XIMM XCON IMMEDIATE XCOFF ;
d920 1
a920 1
1 3 LOADR+
d931 1
a931 5
: XLITN DUP 0xff > IF LIT" (n)" XFIND T, T,
    ELSE LIT" (b)" XFIND T, C, THEN ;
: X'? WORD _xfind _xapply ; : X['] WORD XFIND XLITN ;
: XCOMPILE X['] LIT" ," XFIND T, ;
: X[COMPILE] WORD XFIND T, ;
d933 13
a945 10
: XDO LIT" 2>R" XFIND T, HERE ;
: XLOOP LIT" (loop)" XFIND T, HERE - C, ;
: XIF LIT" (?br)" XFIND T, HERE 1 ALLOT ;
: XELSE LIT" (br)" XFIND T, 1 ALLOT [COMPILE] THEN HERE 1- ;
: XAGAIN LIT" (br)" XFIND T, HERE - C, ;
: XUNTIL LIT" (?br)" XFIND T, HERE - C, ;
: XLIT"
    LIT" (s)" XFIND T, HERE 0 C, ,"
    DUP HERE -^ 1- SWAP C! ;
: XW" XLIT" SYSVARS 0x32 + XLITN LIT" !" XFIND T, ; ( " )
d947 12
d963 1
a963 1
        DROP LIT" EXIT" XFIND T, EXIT THEN
a971 1
: CODE XCODE ;
@


1.46
log
@xcomp: use _xfind in X:
@
text
@d1087 4
a1090 4
HERE 5 + XCURRENT ! ( make next CODE have 0 prev field )
CODE _find  ( cur w -- a f )
    HL POP, ( w ) DE POP, ( cur ) chkPS,
    HL PUSH, ( --> lvl 1 )
a1712 1
: FIND ( w -- a f ) CURRENT @@ SWAP _find ;
d2383 2
a2384 2
CODE _find ( cur w -- a f ) 2 chkPS,
    SI POPx, ( w ) DI POPx, ( cur )
@


1.45
log
@Add T@@ word for reading words using target's endian

Use this new word in XFIND.
@
text
@d925 1
a925 1
    2DUP W= IF NIP ( w ) _xapply 1 EXIT THEN
d928 1
a928 1
: XFIND ( s -- w ) _xfind NOT IF (wnf) THEN ;
d931 1
a931 1
: X'? WORD _xfind ; : X['] WORD XFIND XLITN ;
d951 2
a952 4
    XCURRENT @@ SWAP ( xcur w ) _find ( a f )
    IF   ( a )
        DUP IMMED? IF ABORT THEN
        _xapply T,
d954 1
a954 1
        0x02 RAM+ @@ SWAP ( cur w ) _find ( a f )
d957 1
a957 2
    THEN
    AGAIN ;
@


1.44
log
@xcomp: implement XFIND in Forth instead of re-using _xfind

I'm on a collision course with big-endian and prev fields,
which are hardcoded in _find implementations. To avert this
I'm first re-implementing XFIND so that it performs the whole
logic and stops using the XCON/XCOFF dance.

This include all find-related words. I had a bit of a problem
with X' which was used to give ":" and "(" its names in late
xcomp because it was the only XFIND-related word that didn't
apply offset on its result. I reorganized the ":" and "("
words so that XFIND wasn't used there anymore.
@
text
@d24 2
a25 1
' |L :* |T
d28 1
d459 1
a459 1
-48 LOAD+ ( common words ) ' |M ' |T *! ( big endian )
d926 1
a926 1
    3 - ( prev field ) DUP @@ ?DUP NOT IF DROP 0 EXIT THEN
@


1.43
log
@Remove CMP and make = > and < native

CMP wasn't used anywhere. Wasn't worth it.
@
text
@a911 2
1 3 LOADR+
( ----- 263 )
d916 11
a926 1
: XFIND XCURRENT @@ SWAP _find DROP _xapply ;
d929 3
a931 5
: X' XCON ' XCOFF ; : X'? XCON '? XCOFF ;
: X['] XCON ' _xapply XLITN XCOFF ;
: XCOMPILE XCON ' _xapply XLITN
    LIT" ," FIND DROP _xapply T, XCOFF ;
: X[COMPILE] XCON ' _xapply T, XCOFF ;
d942 1
a942 1
: XW" XLIT" SYSVARS 0x32 + XLITN LIT" !" XFIND T, ;
d1868 1
a1868 3
( gets its name at the very end. can't comment afterwards )
: _ BEGIN LIT" )" WORD S= UNTIL ; IMMEDIATE
: _ ( : will get its name almost at the very end )
d1883 2
d1887 1
a1887 1
    DUP HERE -^ 1- ( a len ) SWAP C! ; IMMEDIATE
a1891 1
( We don't use ." and ABORT in core, they're not xcomp-ed )
a1901 2
':' X' _ 4 - C! ( give : its name )
'(' X' _ 4 - C!
@


1.42
log
@Move native S= to Forth and replace with native []=

S= is lightly used in code and doesn't need to be full native,
and I'm going to need []= soon.
@
text
@d1372 6
a1377 7
CODE CMP HL  POP, DE  POP, chkPS,
    DE SUBHLd, DE 0 LDdi,
    IFNZ, ( < or > )
        DE INCd,
        IFNC, ( < ) DE DECd, DE DECd, THEN,
    THEN,
    DE PUSH, ;CODE
a1523 1
: = CMP NOT ; : < CMP -1 = ; : > CMP 1 = ;
d2376 5
a2380 7
CODE CMP 2 chkPS,
    BX POPx, AX POPx, CX CX XORxx, AX BX CMPxx,
    IFNZ, ( < or > )
        CX INCx, IFC, ( < ) CX DECx, CX DECx, THEN,
    THEN,
    CX PUSHx,
;CODE
@


1.41
log
@6809 asm: fix broken SUBD,
@
text
@d1365 6
a1370 15
CODE S= EXX, ( protect BC )
    DE POP, HL POP, chkPS,
    LDA(DE),
    (HL) CPr,
    IFZ, ( same size? )
        B A LDrr, ( loop A times )
        BEGIN,
            HL INCd, DE INCd,
            LDA(DE),
            (HL) CPr,
            JRNZ, BREAK, ( not equal? break early. NZ is set. )
        DJNZ, AGAIN,
    THEN,
    PUSHZ,
EXX, ( unprotect BC ) ;CODE
d1725 1
a1725 2
    ( Overwrite cellWord in CURRENT )
    3 ( does ) CURRENT @@ C!
d1730 1
a1730 2
    ( HERE points to where we should write R> )
    R> ,
d1734 4
a1737 3
: [IF]
    IF EXIT THEN
    LIT" [THEN]" BEGIN DUP WORD S= UNTIL DROP ;
d2375 3
a2377 8
CODE S= 2 chkPS,
    SI POPx, DI POPx, CH CH XORrr, CL [SI] r[] MOV[],
    CL [DI] r[] CMP[],
    IFZ, ( same size? )
        SI INCx, DI INCx, CLD, REPZ, CMPSB,
    THEN,
    PUSHZ,
;CODE
@


1.40
log
@Make z80 boot code bloacks a bit more compact
@
text
@d556 1
a556 1
0x80 OP1 SUBA,        0xc0 OP1 SUBB,      0xc0 OP2 SUBD,
@


1.39
log
@z80: make PICK slightly more compact
@
text
@d1237 2
a1238 6
    HL POP,
    ( x2 )
    L SLA, H RL,
    SP ADDHLd,
    LDDE(HL),
    DE PUSH,
d1240 1
a1240 3
    EXDEHL,
    HL PS_ADDR LDdi,
    DE SUBHLd,
a1241 1
( ----- 300 )
d1248 1
a1248 1
( ----- 303 )
d1264 1
a1264 1
( ----- 304 )
d1274 1
a1274 1
( ----- 305 )
d1291 1
a1291 1
( ----- 306 )
d1307 1
a1307 1
( ----- 307 )
d1321 1
a1321 1
( ----- 308 )
d1328 1
a1328 6
    E (HL) LDrr,
    HL INCd,
    D (HL) LDrr,
    DE PUSH,
;CODE
( ----- 309 )
d1336 1
a1336 1
( ----- 310 )
a1340 1

d1343 1
a1343 3
    H 0 LDri,
    L INr(C),
    HL PUSH,
d1345 6
a1350 18
( ----- 311 )
CODE I
    L 0 IX+ LDrIXY, H 1 IX+ LDrIXY,
    HL PUSH,
;CODE
CODE I'
    L 2 IX- LDrIXY, H 1 IX- LDrIXY,
    HL PUSH,
;CODE
CODE J
    L 4 IX- LDrIXY, H 3 IX- LDrIXY,
    HL PUSH,
;CODE
CODE >R
    HL POP, chkPS,
    IX INCd, IX INCd, 0 IX+ L LDIXYr, 1 IX+ H LDIXYr,
;CODE
( ----- 312 )
d1364 1
a1364 1
( ----- 313 )
d1380 3
a1382 7
( ----- 314 )
CODE CMP
    HL  POP,
    DE  POP,
    chkPS,
    DE SUBHLd,
    DE 0 LDdi,
d1385 1
a1385 4
        IFNC, ( < )
            DE DECd,
            DE DECd,
        THEN,
d1387 3
a1389 8
    DE PUSH,
;CODE
( ----- 315 )
CODE (im1)
    IM1,
    EI,
;CODE
( ----- 316 )
d1396 1
a1396 1
( ----- 317 )
d1411 1
a1411 1
( ----- 318 )
@


1.38
log
@Make S0 into a Forth word

There's no good reason to have this native.
@
text
@d1236 1
a1236 1
CODE PICK EXX, ( protect BC )
d1241 2
a1242 3
    C (HL) LDrr,
    HL INCd,
    B (HL) LDrr,
d1247 1
a1247 3
    IFC, EXX, lbluflw @@ JP, THEN,
    BC PUSH,
EXX, ( unprotect BC ) ;CODE
d1254 1
a1254 5
CODE 'S
    HL 0 LDdi,
    SP ADDHLd,
    HL PUSH,
;CODE
@


1.37
log
@Add "(b)" byte literal word

This makes literals smaller than 0x100 1b shorter. This more
than compensates for the removal of 0, 1 and -1 words and make
porting easier.
@
text
@d1251 2
a1252 5
( ----- 301 )
CODE 2DROP ( a b -- )
    HL POP, HL POP, chkPS,
;CODE

d1254 1
a1254 2
    HL POP, ( b ) DE POP, ( a )
    chkPS,
d1256 1
a1256 8
    DE PUSH, HL PUSH,
;CODE
( ----- 302 )
CODE S0
    HL PS_ADDR LDdi,
    HL PUSH,
;CODE

d1576 1
a2394 1
CODE S0 AX PS_ADDR MOVxI, AX PUSHx, ;CODE
@


1.36
log
@Remove 0, 1 and -1 native words

It makes the binary fatter, but I'm about to make it slimmer again.
@
text
@d919 2
a920 1
: XLITN LIT" (n)" XFIND T, T, ;
d1189 4
a1192 2
    HL PUSH,
;CODE
d1929 1
a1929 1
: LITN COMPILE (n) , ;
d2359 4
a2362 2
    DX INCx, DX INCx,
;CODE
d2366 1
a2366 2
    DX PUSHx, DX INCx, DX AX ADDxx,
;CODE
@


1.35
log
@Remove 2+ and 2-

Not worth the space they take.
@
text
@a1442 8

CODE 0 PUSH0, ;CODE
CODE 1 PUSH1, ;CODE

CODE -1
    HL -1 LDdi,
    HL PUSH,
;CODE
a2473 3
CODE 0 AX AX XORxx, AX PUSHx, ;CODE
CODE 1 AX 1 MOVxI, AX PUSHx, ;CODE
CODE -1 AX -1 MOVxI, AX PUSHx, ;CODE
@


1.34
log
@6809 port: implement native and compiled exec model

BOOT prints "DE" (A+3, then +1) on the screen then halts.
@
text
@d290 1
a290 1
: RPCn, PC - 2- T, ;
d759 1
a759 1
    2- BLK( - pos! ;
d762 1
a762 1
    2+ BLK( - pos! ;
d786 1
a786 1
    DUP CMD 2+ C! CMD FIND IF EXECUTE ELSE DROP THEN
d1070 2
a1071 2
  and protected registers. 2- is to compensate that. )
    HL PS_ADDR 2- LDdi,
a1457 6
CODE 2+
    HL POP, chkPS,
    HL INCd, HL INCd, HL PUSH, ;CODE
CODE 2-
    HL POP, chkPS,
    HL DECd, HL DECd, HL PUSH, ;CODE
d1659 1
a1659 1
    2+ C@@ 1                             ( n 1 )
d1723 2
a1724 2
: , HERE ! HERE 2+ H ! ;
: C, HERE C!+ H ! ;
d1867 1
a1867 1
    4 0 DO DUP @@ |L .x .x SPC> 2+ LOOP
d1979 1
a1979 1
: XYPOS [ GRID_MEM LITN ] ; : XYMODE [ GRID_MEM LITN ] 2+ ;
a2486 4
CODE 2+ 1 chkPS,
    DI SP MOVxx, [DI] [w] INC[], [DI] [w] INC[], ;CODE
CODE 2- 1 chkPS,
    DI SP MOVxx, [DI] [w] DEC[], [DI] [w] DEC[], ;CODE
@


1.33
log
@6809 asm: invert TFR arguments order

In 6809 documentation, we put source before dest in argument
order. Let's follow this order in our assembler to avoid
confusion.
@
text
@d2518 12
a2529 5
( 6809 Boot code WIP. Well, not so much a WIP as a...
  placeholder. But this is the first step in a glorious
  journey to the 6809 port! )
0x400 # LDX, 'B' # LDA, X+ STA,
INCA, X+ STA,
d2531 4
@


1.32
log
@Make xcomp tools endian-aware

Previously, it would write words in the host's endian-ness.
@
text
@d515 1
a515 1
: OPRR CREATE C, DOES> C@@ C, <<4 OR C, ;
@


1.31
log
@Fix inconvenient crash in 6809 assembler

Also, make CODE definition common.
@
text
@d911 1
a911 1
: XCONSTANT (xentry) 6 C, , ;
d917 1
a917 1
: X:* (xentry) 4 C, _xapply , ; : X:** (xentry) 5 C, , ;
d919 1
a919 1
: XLITN LIT" (n)" XFIND , , ;
d923 2
a924 2
    LIT" ," FIND DROP _xapply , XCOFF ;
: X[COMPILE] XCON ' _xapply , XCOFF ;
d926 6
a931 6
: XDO LIT" 2>R" XFIND , HERE ;
: XLOOP LIT" (loop)" XFIND , HERE - C, ;
: XIF LIT" (?br)" XFIND , HERE 1 ALLOT ;
: XELSE LIT" (br)" XFIND , 1 ALLOT [COMPILE] THEN HERE 1- ;
: XAGAIN LIT" (br)" XFIND , HERE - C, ;
: XUNTIL LIT" (?br)" XFIND , HERE - C, ;
d933 1
a933 1
    LIT" (s)" XFIND , HERE 0 C, ,"
d935 1
a935 1
: XW" XLIT" SYSVARS 0x32 + XLITN LIT" !" XFIND , ;
d941 1
a941 1
        DROP LIT" EXIT" XFIND , EXIT THEN
d945 1
a945 1
        _xapply ,
@


1.30
log
@Remove ~C! mechanism

It was added to allow AT28 write overrides, but it was a bad
idea because it was unnecessary: an in-memory override of
C! and ! is much simpler, elegant, and faster!
@
text
@d30 1
a143 1
: CODE (entry) 0 ( native ) C, ;
a295 2
: CODE ( same as CREATE, but with native word )
    (entry) 0 ( native ) C, ;
d482 1
a482 1
: [R+N] CREATE C, DOES> C@@ 0x10 OR ( roff ) R>
@


1.29
log
@Add word W"

This allows us to remove [entry] and saves us from the trouble
of adding a similar hack for :* in upcoming development.
@
text
@a992 4
( Perform a byte write by taking into account the SYSVARS+3e
  override. )
: LD(HL)E*, SYSVARS 0x3e + LDA(i), A ORr,
    IFZ, (HL) E LDrr, ELSE, SYSVARS 0x3e + CALL, THEN, ;
a1015 2
    A XORr, SYSVARS 0x3e + LD(i)A, ( 3e == ~C! )
    SYSVARS 0x41 + LD(i)A, ( 41 == ~C!ERR )
d1348 2
a1349 3
    LD(HL)E*, HL INCd,
    E D LDrr, LD(HL)E*,
;CODE
d1360 1
a1360 1
    LD(HL)E*, ;CODE
a1364 7
CODE ~C!
    HL POP, chkPS,
    SYSVARS 0x3f + LD(i)HL,
    HLZ, ( makes A zero if Z is set ) IFNZ,
        A 0xc3 ( JP ) LDri, THEN,
    ( A is either 0 or c3 ) SYSVARS 0x3e + LD(i)A,
;CODE
d1496 3
a1498 5
( Write byte E at addr HL, assumed to be an AT28 EEPROM. After
  that, poll repeatedly that address until writing is complete.
  If last polled value is different than orig, set ~C!ERR )
(entry) ~AT28 ( warning: don't touch D register )
    (HL) E LDrr, A E LDrr, ( orig ) EXAFAF', ( save )
d1503 5
a1507 3
    EXAFAF', ( orig ) E SUBr, ( equal? )
    IFNZ, SYSVARS 0x41 + ( ~C!ERR ) LD(i)A, THEN,
    RET,
d1599 1
a1599 1
SYSVARS 0x41 + CONSTANT ~C!ERR
d1849 2
d1926 1
d1935 1
a1935 1
1 4 LOADR+
a1937 3
: :* ( addr -- ) (entry) 4 ( alias ) C, , ;
: :** ( addr -- ) (entry) 5 ( ialias ) C, , ;
( ----- 392 )
d1952 1
a1952 1
( ----- 393 )
d1966 1
a1966 1
( ----- 394 )
@


1.28
log
@Add WIP 6809 boot code
@
text
@d936 2
a937 2
    DUP HERE -^ 1- SWAP C!
;
d963 2
a964 1
: LIT" XLIT" ; IMMEDIATE : LITN XLITN ;
d1762 3
a1764 1
: WORD
d1793 1
a1793 1
: [entry] ( w -- )
a1798 1
: (entry) WORD [entry] ;
d1938 2
a1939 1
    0 0x50 RAM+ ! ( NL> + KEY> )
d1943 1
a1943 1
    LIT" _sys" [entry]
d1968 1
a1968 2
    COMPILE (?br) HERE 1 ALLOT ( br cell allot )
; IMMEDIATE
d1970 1
a1970 2
    DUP HERE -^ _bchk SWAP ( a-H a ) C!
; IMMEDIATE
d1972 2
a1973 5
    COMPILE (br)
    1 ALLOT
    [COMPILE] THEN
    HERE 1- ( push a. 1- for allot offset )
; IMMEDIATE
d1976 4
a1979 2
    DUP HERE -^ 1- ( a len ) SWAP C!
; IMMEDIATE
@


1.27
log
@Improve RSH reliability

rupload is now pretty usable!
@
text
@d15 2
a16 1
460-519 unused                520 Fonts
d2533 7
@


1.26
log
@Move Z80 drivers in their own zone and make font compiler more compact

I've also fixed the 7x7 compiler which didn't properly compile its
last 4 characters.
@
text
@d799 2
d802 1
a802 1
: _<<n ( n ) 0 DO rsh< EMIT LOOP ;
d806 5
a811 1
: pack 0xf0 AND SWAP 0x0f AND OR ;
d813 1
a813 1
: chk ( a u -- ) 0 ROT> OVER + SWAP DO I C@@ + LOOP .X ;
d815 9
a823 10
    2 PICK OVER chk
    ['] rsh> ['] EMIT **!
    ." : in KEY 0xf0 AND KEY 0x0f AND OR ;" NL>
    ( sig: chk a u -- )
    ." : _ OVER + SWAP DO in DUP ROT + SWAP I C! LOOP ; 0 "
    DUP ROT ( loca u u rema ) . SPC> . SPC> '_' EMIT NL>
    OVER + SWAP ( loca+u loca ) DO I C@@ unpack EMIT EMIT LOOP
    ." FORGET in" NL>
    ['] (emit) ['] EMIT **! '.' rsh> 'X' rsh> SPC rsh>
    CR rsh> 7 _<<n ;
@


1.25
log
@Add LIVETGT to assemblers
@
text
@d11 3
a13 4
280 Z80 boot code             320-349 unused
350 Core words
400 AT28 EEPROM driver        401 Grid subsystem
410 PS/2 keyboard subsystem   418 Z80 SPI Relay driver
d15 1
a15 2
460-469 unused                470 Z80 TMS9918 driver
480-519 unused                520 Fonts
d1497 87
a1987 13
( ----- 400 )
( Write byte E at addr HL, assumed to be an AT28 EEPROM. After
  that, poll repeatedly that address until writing is complete.
  If last polled value is different than orig, set ~C!ERR )
(entry) ~AT28 ( warning: don't touch D register )
    (HL) E LDrr, A E LDrr, ( orig ) EXAFAF', ( save )
    E (HL) LDrr, ( poll ) BEGIN,
        A (HL) LDrr, ( poll ) E CPr, ( same as old? )
        E A LDrr, ( save old poll, Z preserved )
    JRNZ, AGAIN,
    EXAFAF', ( orig ) E SUBr, ( equal? )
    IFNZ, SYSVARS 0x41 + ( ~C!ERR ) LD(i)A, THEN,
    RET,
a2087 25
( ----- 418 )
SPI relay driver

This driver is designed for a ad-hoc adapter card that acts as a
SPI relay between the z80 bus and the SPI device. When writing
to SPI_CTL, we expect a bitmask of the device to select, with
0 meaning that everything is de-selected. Reading SPI_CTL
returns 0 if the device is ready or 1 if it's still running an
exchange. Writing to SPI_DATA initiates an exchange.

Provides the SPI relay protocol. Load driver with "419 LOAD".
( ----- 419 )
CODE (spix) ( n -- n )
    HL POP, chkPS, A L LDrr,
    SPI_DATA OUTiA,
    ( wait until xchg is done )
    BEGIN, SPI_CTL INAi, 1 ANDi, JRNZ, AGAIN,
    SPI_DATA INAi,
    L A LDrr,
    HL PUSH,
;CODE
CODE (spie) ( n -- )
    HL POP, chkPS, A L LDrr,
    SPI_CTL OUTiA,
;CODE
a2526 44
( ----- 470 )
( Z80 driver for TMS9918. Implements grid protocol. Requires
TMS_CTLPORT, TMS_DATAPORT and ~FNT from the Font compiler at
B520. Patterns are at addr 0x0000, Names are at 0x3800.
Load range B470-472 )
CODE _ctl ( a -- sends LSB then MSB )
    HL POP, chkPS,
    A L LDrr, TMS_CTLPORT OUTiA,
    A H LDrr, TMS_CTLPORT OUTiA,
;CODE
CODE _data
    HL POP, chkPS,
    A L LDrr, TMS_DATAPORT OUTiA,
;CODE
( ----- 471 )
: _zero ( x -- send 0 _data x times )
    ( x ) 0 DO 0 _data LOOP ;
( Each row in ~FNT is a row of the glyph and there is 7 of
them.  We insert a blank one at the end of those 7. )
: _sfont ( a -- Send font to TMS )
    7 0 DO C@@+ _data LOOP DROP
    ( blank row ) 0 _data ;
: _sfont^ ( a -- Send inverted font to TMS )
    7 0 DO C@@+ 0xff XOR _data LOOP DROP
    ( blank row ) 0xff _data ;
: CELL! ( c pos )
    0x7800 OR _ctl ( tilenum )
    SPC - ( glyph ) 0x5f MOD _data ;
( ----- 472 )
: CURSOR! ( new old -- )
    DUP 0x3800 OR _ctl [ TMS_DATAPORT LITN ] PC@@
    0x7f AND ( new old glyph ) SWAP 0x7800 OR _ctl _data
    DUP 0x3800 OR _ctl [ TMS_DATAPORT LITN ] PC@@
    0x80 OR ( new glyph ) SWAP 0x7800 OR _ctl _data ;
: COLS 40 ; : LINES 24 ;
: TMS$
    0x8100 _ctl ( blank screen )
    0x7800 _ctl COLS LINES * _zero
    0x4000 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont LOOP
    0x4400 _ctl 0x5f 0 DO ~FNT I 7 * + _sfont^ LOOP
    0x820e _ctl ( name table 0x3800 )
    0x8400 _ctl ( pattern table 0x0000 )
    0x87f0 _ctl ( colors 0 and 1 )
    0x8000 _ctl 0x81d0 _ctl ( text mode, display on ) ;
d2549 4
a2552 3
: _g ( given a top-left of dot-X in BLK(, spit 5 bin lines )
    5 0 DO
    0 3 0 DO ( a r )
d2555 1
a2555 1
    LOOP 5 LSHIFT C, LOOP DROP ;
d2558 1
a2558 1
        DUP I 3 * + _g
a2559 5
: CPFNT3x5
    0 , 0 , 0 C, ( space char )
    530 BLK@@ BLK( 21 _l 320 + 21 _l 320 + 21 _l DROP ( 63 )
    531 BLK@@ BLK( 21 _l 320 + 10 _l DROP ( 94! )
;
d2561 13
a2573 32
: _g ( given a top-left of dot-X in BLK(, spit 7 bin lines )
    7 0 DO
    0 5 0 DO ( a r )
        1 LSHIFT
        OVER J 64 * I + + C@@ 'X' = IF 1+ THEN
    LOOP 3 LSHIFT C, LOOP DROP ;
: _l ( a u -- a, spit a line of u glyphs )
    ( u ) 0 DO ( a )
        DUP I 5 * + _g
    LOOP ;
: CPFNT5x7
    0 , 0 , 0 , 0 C, ( space char )
    535 532 DO I BLK@@ BLK( 12 _l 448 + 12 _l DROP LOOP ( 72 )
    535 BLK@@ BLK( 12 _l 448 + 10 _l DROP ( 94! )
;
( ----- 524 )
: _g ( given a top-left of dot-X in BLK(, spit 7 bin lines )
    7 0 DO
    0 7 0 DO ( a r )
        1 LSHIFT
        OVER J 64 * I + + C@@ 'X' = IF 1+ THEN
    LOOP 1 LSHIFT C, LOOP DROP ;
: _l ( a u -- a, spit a line of u glyphs )
    ( u ) 0 DO ( a )
        DUP I 7 * + _g
    LOOP ;
: CPFNT7x7
    0 , 0 , 0 , 0 C, ( space char )
    541 536 DO I BLK@@ BLK( 9 _l 448 + 9 _l DROP LOOP ( 90 )
    542 BLK@@ BLK( 4 _l DROP ( 94! )
;
( ----- 530 )
d2590 1
a2590 1
( ----- 531 )
d2602 1
a2602 1
( ----- 532 )
d2618 1
a2618 1
( ----- 533 )
d2634 1
a2634 1
( ----- 534 )
d2650 1
a2650 1
( ----- 535 )
d2666 1
a2666 1
( ----- 536 )
d2682 1
a2682 1
( ----- 537 )
d2698 1
a2698 1
( ----- 538 )
d2714 1
a2714 1
( ----- 539 )
d2730 1
a2730 1
( ----- 540 )
d2746 1
a2746 1
( ----- 541 )
@


1.24
log
@Fix endian-ness bugs in 6809 assembler
@
text
@d30 1
d1020 1
a1020 1
lblnext BSET
d1505 1
a1505 1
words come right after the boot binary (B280).
a1506 27
Because this unit is designed to be cross-compiled, things are
a little weird. It is compiling in the context of a full
Forth interpreter with all bells and whistles (and z80
assembler), but it has to obey strict rules:

1. Although it cannot compile a word that isn't defined yet,
   it can still execute an immediate from the host system.

                                                        (cont.)
( ----- 351 )
2. Immediate words that have been cross compiled *cannot* be
   used. Only immediates from the host system can be used.
3. If an immediate word compiles words, it can only be words
   that are part of the stable ABI.

All of this is because when cross compiling, all atom ref-
erences are offsetted to the target system and are thus
unusable directly. For the same reason, any reference to a word
in the host system will obviously be wrong in the target
system. More details in B260.





                                                        (cont.)
( ----- 352 )
d1517 1
a1517 1
: RAM+ [ SYSVARS LITN ] + ;
d2253 1
a2253 1
lblnext BSET
@


1.23
log
@Add QUIT to stable ABI
@
text
@d459 1
a459 1
-48 LOAD+ ( common words )
d469 1
a469 1
: () ( n ) |L 2 0x30 ;
d478 1
a478 1
: _16 |L 0x89 3 ;
d506 1
a506 1
: ,? DUP 0xff > IF |M C, THEN C, ;
d512 1
a512 1
: OP2 CREATE , DOES> @@ OVER + ,? IF ,N ELSE DROP , THEN ;
d588 1
a588 1
: AGAIN, ( a -- ) HERE - 1- wbr? IF 1- |M C, THEN C, ;
d595 1
a595 1
    IF 1- |M ROT C!+ ( lsb l+1 ) SWAP THEN SWAP C! ;
@


1.22
log
@Remove next jump from stable ABI

By moving native words around in the 8086 port, we don't have
any pre-lblnext jumps any more, so we have no need of having
this clutch in the stable ABI anymore.

Also, add verbose abort on any attempt to generate a JPNEXT,
without having first set lblnext.
@
text
@d16 1
a16 1
470 Z80 TMS9918 driver
d995 1
a995 1
NOP, NOP, ( 0a (main) ) NOP, NOP, NOP, ( 0c QUIT ) NOP,
d1171 1
a1171 1
L1 BSET ( used in ABORT )
d2272 2
a2273 2
Load range: B445-B461
( ----- 445 )
d2277 2
a2278 2
0x11 ALLOT0 ( Stable ABI )
( ----- 446 )
d2289 1
a2289 1
( ----- 447 )
d2306 1
a2306 1
( ----- 448 )
d2322 1
a2322 1
( ----- 449 )
d2334 1
a2334 1
( ----- 450 )
d2343 1
a2343 1
( ----- 451 )
d2347 1
d2356 1
a2356 1
( ----- 452 )
d2366 1
a2366 1
( ----- 453 )
d2379 1
a2379 1
( ----- 454 )
d2396 1
a2396 1
( ----- 455 )
d2408 1
a2408 1
( ----- 456 )
d2424 1
a2424 1
( ----- 457 )
d2439 1
a2439 1
( ----- 458 )
d2456 1
a2456 1
( ----- 459 )
d2473 1
a2473 1
( ----- 460 )
d2490 1
a2490 1
( ----- 461 )
@


1.21
log
@Add |T T! and T, to assemblers

This allows assembling binaries on hosts with a different
endian-ness than the target.

I haven't touched the 6809 assembler in this commit because I
have pending changes on my TRS-80 4P floppies. I'll integrate
these words on the floppies.

I haven't touched Forth core words yet, but these words will
certainly have to be used there and I will certainly have a
lot of fun discovering where they must be used when working
on the 6809 port...
@
text
@d28 2
d142 2
a143 4
CREATE lblnext 0 , ( stable ABI until set in B300 )
: JPNEXT, lblnext @@ ?DUP IF JP, ELSE 0x1a BJP, THEN ;
: CODE ( same as CREATE, but with native word )
    (entry) 0 C, ( 0 == native ) ;
d298 1
a298 1
: ;CODE JMPn, 0x1a ( next ) RPCn, ;
d995 3
a997 4
NOP, NOP, NOP, NOP, NOP, NOP, ( unused )
0 JP, ( RST 10 )  NOP, NOP, ( 13, oflw )
NOP, NOP, NOP, NOP, NOP, ( unused )
0 JP, ( 1a, next ) NOP, NOP, NOP, ( unused )
d1019 1
a1019 1
lblnext BSET PC ORG @@ 0x1b + ! ( next )
d2274 1
a2274 1
VARIABLE lblexec VARIABLE lblnext
d2277 1
a2277 6
0 , ( 04, BOOT )
0 , ( 06, uflw ) 0 , ( 08, LATEST ) 0 , ( unused )
0 C, 0 , ( 0b, EXIT )
0 , 0 , ( unused ) 0 , ( 13, oflw )
0 , 0 , 0 C, ( unused )
JMPn, 0 , ( 1a, next )
d2279 1
a2279 22
( TODO: move these words with other native words. )
HERE 4 + XCURRENT ! ( make next CODE have 0 prev field )
CODE (br) L1 BSET ( used in ?br )
    DI DX MOVxx, AL [DI] r[] MOV[], AH AH XORrr, CBW,
    DX AX ADDxx,
;CODE
CODE (?br)
    AX POPx, AX AX ORxx, JZ, L1 @@ RPCs, ( False, branch )
    ( True, skip next byte and don't branch )
    DX INCx,
;CODE
( ----- 447 )
CODE (loop)
    [BP] 0 [w]+ INC[], ( I++ )
    ( Jump if I <> I' )
    AX [BP] 0 x[]+ MOV[], AX [BP] -2 x[]+ CMP[],
    JNZ, L1 @@ RPCs, ( branch )
    ( don't branch )
    BP 4 SUBxi, DX INCx,
;CODE
( ----- 448 )
lblnext BSET PC 0x1d - ORG @@ 0x1b + ! ( next )
d2289 1
a2289 1
( ----- 449 )
d2306 1
a2306 1
( ----- 450 )
d2322 21
a2343 1
( native words )
@


1.20
log
@Remove ROLL, it wasn't used anywhere
@
text
@d25 3
d91 3
a93 3
: LDdi, ( d n ) SWAP <<4 0x01 OR C, , ;
: LDd(i), ( d i ) 0xed C, SWAP <<4 0x4b OR C, , ;
: LD(i)d, ( i d ) 0xed C, <<4 0x43 OR C, , ;
d124 1
a124 1
: OP3i CREATE C, DOES> C@@ ( i op ) C, , ;
d133 1
a133 1
: JPc, SWAP <<3 0xc2 OR C, , ;
d235 1
a235 1
        ( disp low+high ) , ELSE ( low only ) C, THEN
d253 1
a253 1
: OPI CREATE C, DOES> C@@ C, , ;
d257 1
a257 1
: MOVxI, SWAP 0xb8 OR C, , ;
d259 4
a262 4
: MOVrm, 0x8a C, SWAP <<3 0x6 OR C, , ;
: MOVxm, 0x8b C, SWAP <<3 0x6 OR C, , ;
: MOVmr, 0x88 C, <<3 0x6 OR C, , ;
: MOVmx, 0x89 C, <<3 0x6 OR C, , ;
d267 1
a267 1
: JMPf, ( seg off ) 0xea C, |L C, C, , ;
d290 1
a290 1
: RPCn, PC - 2- , ;
d317 1
a317 1
: OPRd CREATE , DOES> @@ SWAP _r32c _Rdp , ;
d331 1
a331 1
    SWAP _r32c _Rdp , ;
d340 1
a340 1
    8 LSHIFT OR 0xff0f AND ( rd op' ) SWAP _r32c _Rdp , ;
d357 1
a357 1
: OPNA CREATE , DOES> @@ , ;
d370 1
a370 1
    SWAP _r8c _Rdp , ;
d375 1
a375 1
    ROT _r32c _Rdp SWAP _r8c OR , ;
d388 1
a388 1
: RJMP, RJMP , ; : RCALL, RCALL , ;
d406 1
a406 1
    OR OR ( Rd op' ) SWAP _Rdp , ;
d411 2
a412 2
: LBL, ( l op -- ) SWAP @@ 1- SWAP EXECUTE , ;
: SKIP, PC 0 , ;
d419 1
a419 1
: FLBL, ( l -- ) LBL! 0 , ;
d421 1
a421 1
: BEGIN, PC ; : AGAIN?, ( op ) SWAP 1- SWAP EXECUTE , ;
@


1.19
log
@Make QUIT and ABORT native words

To make it work, I had to add (main) to the stable ABI.
Those new native words replace (resSP) and (resRS) which were
only used by QUIT and ABORT.
The goal of this change is to allow QUITing from native code.
One example I have in mind is a tight loop check for a BREAK
key press which triggers QUIT. I would need this to break free
of stuck RS-232 wait loops without having to reset the whole
system.
@
text
@a1247 16
( ----- 300 )
( Low-level part of ROLL. Example:
  "1 2 3 4 4 (roll)" --> "1 3 4 4". No sanity checks, never
  call with 0. )
CODE (roll)
    HL POP,
    B H LDrr,
    C L LDrr,
    SP ADDHLd,
    HL INCd,
    D H LDrr,
    E L LDrr,
    HL DECd,
    HL DECd,
    LDDR,
;CODE
a1707 5
: ROLL
    ?DUP NOT IF EXIT THEN
    1+ DUP PICK          ( n val )
    SWAP 2 * (roll)      ( val )
    NIP ;
a2399 5
CODE (roll) ( "2 3 4 5 4 --> 2 4 5 5". See B311 )
    CX POPx, CX 2 ADDxi, CALL, lblchkPS @@ RPCn, CX 2 SUBxi,
    SI SP MOVxx, SI CX ADDxx,
    DI SI MOVxx, DI 2 ADDxi, STD, REPZ, MOVSB,
;CODE
@


1.18
log
@Rename HERE to H and H@@ to HERE
@
text
@d11 2
a12 1
280 Z80 boot code             350 Core words
d976 1
a976 1
"282 LOAD". The rest, after xcomp overrides, with "283 335
d978 1
a978 1
( ----- 282 )
d988 1
a988 1
( ----- 283 )
d1000 1
a1000 1
( ----- 284 )
d1016 1
a1016 1
( ----- 286 )
d1032 1
a1032 1
( ----- 287 )
d1049 1
a1049 1
( ----- 289 )
d1063 1
a1063 1
( ----- 290 )
d1079 1
a1079 1
( ----- 291 )
d1096 1
a1096 1
( ----- 292 )
d1099 3
a1101 8
        HL PUSH, ( --> lvl 3 )
        DE PUSH, ( --> lvl 4 )
        DE DECd,
        LDA(DE),
        0x7f ANDi, ( remove IMMEDIATE flag )
        C CPr,                                        ( cont. )
( ----- 293 )
        IFZ,
d1108 2
a1109 4
                DE DECd,
                HL DECd,
                LDA(DE),
                (HL) CPr,
d1112 2
a1113 3
        THEN,
                                                      ( cont. )
( ----- 294 )
a1125 2


d1127 1
a1127 1
( ----- 295 )
d1142 1
a1142 1
( ----- 297 )
d1156 1
a1156 1
( ----- 298 )
d1166 6
a1171 4
( ----- 305 )
CODE EXECUTE
    DE POP,
    chkPS,
d1173 4
a1176 1

d1178 1
a1178 2
    C 0 IX+ LDrIXY,
    B 1 IX+ LDrIXY,
d1181 1
a1181 1
( ----- 306 )
d1190 1
a1190 1
( ----- 307 )
d1201 1
a1201 1
( ----- 308 )
d1218 1
a1218 1
( ----- 309 )
d1232 1
a1232 1
( ----- 310 )
d1248 1
a1248 1
( ----- 311 )
d1264 1
a1264 1
( ----- 312 )
d1275 1
a1275 1
( ----- 313 )
d1286 1
a1286 1
( ----- 314 )
d1288 4
a1291 12
    HL POP,
    DE POP,
    chkPS,
    A E LDrr,
    L ANDr,
    L A LDrr,
    A D LDrr,
    H ANDr,
    H A LDrr,
    HL PUSH,
;CODE
( ----- 315 )
d1293 4
a1296 12
    HL POP,
    DE POP,
    chkPS,
    A E LDrr,
    L ORr,
    L A LDrr,
    A D LDrr,
    H ORr,
    H A LDrr,
    HL PUSH,
;CODE
( ----- 316 )
d1298 5
a1302 12
    HL POP,
    DE POP,
    chkPS,
    A E LDrr,
    L XORr,
    L A LDrr,
    A D LDrr,
    H XORr,
    H A LDrr,
    HL PUSH,
;CODE
( ----- 317 )
d1304 2
a1305 6
    HL POP,
    chkPS,
    HLZ,
    PUSHZ,
;CODE
( ----- 318 )
d1307 2
a1308 7
    HL POP,
    DE POP,
    chkPS,
    DE ADDHLd,
    HL PUSH,
;CODE

d1310 3
a1312 7
    DE POP,
    HL POP,
    chkPS,
    DE SUBHLd,
    HL PUSH,
;CODE
( ----- 319 )
d1329 1
a1329 1
( ----- 320 )
d1345 1
a1345 1
( ----- 321 )
d1359 1
a1359 1
( ----- 322 )
d1372 1
a1372 1
( ----- 323 )
d1387 1
a1387 1
( ----- 324 )
d1399 1
a1399 1
( ----- 325 )
d1416 1
a1416 1
( ----- 326 )
d1430 1
a1430 13
( ----- 327 )
CODE BYE
    HALT,
;CODE

CODE (resSP)
    SP PS_ADDR LDdi,
;CODE

CODE (resRS)
    IX RS_ADDR LDdi,
;CODE
( ----- 328 )
d1446 1
a1446 1
( ----- 329 )
d1462 1
a1462 1
( ----- 331 )
d1475 1
a1475 1
( ----- 332 )
d1477 2
a1478 6
    HL POP,
    chkPS,
    HL INCd,
    HL PUSH,
;CODE

d1480 2
a1481 6
    HL POP,
    chkPS,
    HL DECd,
    HL PUSH,
;CODE
( ----- 333 )
d1483 2
a1484 7
    HL POP,
    chkPS,
    HL INCd,
    HL INCd,
    HL PUSH,
;CODE

d1486 3
a1488 7
    HL POP,
    chkPS,
    HL DECd,
    HL DECd,
    HL PUSH,
;CODE
( ----- 334 )
d1503 1
a1503 1
( ----- 335 )
a1562 2
: FIND ( w -- a f ) CURRENT @@ SWAP _find ;
: QUIT (resRS) LIT" (main)" FIND DROP EXECUTE ;
a1564 1
: ABORT (resSP) QUIT ;
a1723 2
: '? WORD FIND ;
: ' '? NOT IF (wnf) THEN ;
d1754 3
d1887 1
d2366 1
a2366 1
    JMPn, lblexec @@ RPCn, ( execute )
d2371 6
a2467 2
CODE (resSP) SP PS_ADDR MOVxI, ;CODE
CODE (resRS) BP RS_ADDR MOVxI, ;CODE
@


1.17
log
@Add first draft of 6809 assembler

This hasn't assembled any real code yet, but the results
look good.
@
text
@d21 1
a21 1
: PC H@@ ORG @@ - BIN( @@ + ;
d301 1
a301 1
: PC H@@ ORG @@ - 1 RSHIFT ;
d411 3
a413 3
    2 * ORG @@ + PC 1- H@@ ( opw addr tgt hbkp )
    ROT HERE ! ( opw tgt hbkp ) SWAP ROT EXECUTE H@@ ! ( hbkp )
    HERE ! ;
d582 1
a582 1
: BEGIN, ( -- a ) H@@ ;
d584 1
a584 1
: AGAIN, ( a -- ) H@@ - 1- wbr? IF 1- |M C, THEN C, ;
d590 1
a590 1
: THEN, ( a -- ) DUP H@@ -^ 1- ( l off ) OVER C@@ ( l off wbr )
d919 6
a924 6
: XDO LIT" 2>R" XFIND , H@@ ;
: XLOOP LIT" (loop)" XFIND , H@@ - C, ;
: XIF LIT" (?br)" XFIND , H@@ 1 ALLOT ;
: XELSE LIT" (br)" XFIND , 1 ALLOT [COMPILE] THEN H@@ 1- ;
: XAGAIN LIT" (br)" XFIND , H@@ - C, ;
: XUNTIL LIT" (?br)" XFIND , H@@ - C, ;
d926 2
a927 2
    LIT" (s)" XFIND , H@@ 0 C, ,"
    DUP H@@ -^ 1- SWAP C!
d988 1
a988 1
H@@ ORG ! ( STABLE ABI )
d1080 1
a1080 1
H@@ 5 + XCURRENT ! ( make next CODE have 0 prev field )
d1629 1
a1629 1
SYSVARS 0x04 + CONSTANT HERE
d1632 1
a1632 1
: H@@ HERE @@ ;
d1655 1
a1655 1
: ALLOT HERE +! ;
d1659 1
a1659 1
: ALLOT0 ( n -- ) H@@ OVER 0 FILL ALLOT ;
d1766 2
a1767 2
: , H@@ ! H@@ 2+ HERE ! ;
: C, H@@ C!+ HERE ! ;
d1817 1
a1817 1
: MOVE, ( a u -- ) H@@ OVER ALLOT SWAP MOVE ;
d1822 1
a1822 1
    H@@ CURRENT @@ - ,
d1824 1
a1824 1
    H@@ CURRENT ! ;
d1836 1
a1836 1
    - HERE !  ( w )
d1838 1
a1838 1
: EMPTY LIT" _sys" FIND IF DUP HERE ! CURRENT ! THEN ;
d1846 1
a1846 1
    CURRENT @@ 3 + HERE !
d1868 1
a1868 1
    H@@ 0x3c ( BLK(* ) RAM+ !
d1975 2
a1976 2
: DO COMPILE 2>R H@@ ; IMMEDIATE
: LOOP COMPILE (loop) H@@ - _bchk C, ; IMMEDIATE
d1990 1
a1990 1
    COMPILE (?br) H@@ 1 ALLOT ( br cell allot )
d1993 1
a1993 1
    DUP H@@ -^ _bchk SWAP ( a-H a ) C!
d1999 1
a1999 1
    H@@ 1- ( push a. 1- for allot offset )
d2002 2
a2003 2
    COMPILE (s) H@@ 0 C, ,"
    DUP H@@ -^ 1- ( a len ) SWAP C!
d2009 3
a2011 3
: BEGIN H@@ ; IMMEDIATE
: AGAIN COMPILE (br) H@@ - _bchk C, ; IMMEDIATE
: UNTIL COMPILE (?br) H@@ - _bchk C, ; IMMEDIATE
d2365 1
a2365 1
H@@ ORG !
d2375 1
a2375 1
H@@ 4 + XCURRENT ! ( make next CODE have 0 prev field )
@


1.16
log
@Multiple improvement in VE

1. Minimize screen refresh areas. On some machines, refreshing
   the whole screen is very time-consuming.
2. Fix regression where first IBUF or FBUF letter could never
   be erased by typing backspace.
3. Make "L" key stop at last non-WS char, making it much more
   useful.
@
text
@d6 1
a6 1
60-99 unused
d453 149
d711 1
a711 1
        DO I @@emit LOOP ;   
d1741 1
a1741 1
: KEY [ SYSVARS 0x51 + LITN ] C@@ ?DUP IF 0 KEY> 
@


1.15
log
@Add KEY> and fix PS leak in DUMP
@
text
@d466 3
a468 3
: _cpos BLK( + ;
: _lpos 64 * _cpos ;
: _pln ( lineno -- )
d559 6
a564 6
: contents
    16 0 DO
        large? IF 3 ELSE 0 THEN I 3 + AT-XY
        64 I * BLK( + ( lineaddr ) xoff @@ + DUP width + SWAP
        DO I @@emit LOOP LOOP
    large? IF 3 16 gutter THEN ;
d576 3
a578 4
    3 OVER AT-XY KEY DUP EMIT
    DUP SPC < IF 2DROP DROP EXIT THEN
    ( buf ln c ) 4 col- nspcs SWAP 4 SWAP AT-XY ( buf c )
    SWAP C!+ IN( _zbuf RDLN IN( SWAP 63 MOVE ;
d590 1
a590 1
: $I 'I' mode! IBUF 1 buftype _i bufs contents SPC mode! ;
d592 2
a593 3
: $Y Y bufs ;
: $E _E bufs contents ;
: $X acc@@ _X bufs contents ;
d596 3
a598 1
: $L EDPOS @@ 0x3f OR pos! ;
d625 1
a625 1
    THEN UNTIL SPC mode! contents ;
@


1.14
log
@Move AVR assembler to B30
@
text
@d1591 3
a1593 1
: KEY BEGIN KEY? UNTIL ;
d1598 1
a1608 1
( ----- 363 )
d1611 1
a1611 2
    DUP IF ( not EOL? good, inc and return )
        1 IN> +!
d1769 1
a1769 1
    0 DO _ LOOP ;
d1812 1
a1812 1
    0 0x50 RAM+ C! ( NL> )
@


1.13
log
@Make 8086 assembler more compact
Most of this space was freed by the simplification of the
modrm operations. The modrm scheme is now much simpler.
@
text
@d5 2
a6 2
020 8086 assembler            30-49 unused
050 AVR assembler             70-99 unused
d298 2
a299 5
( ----- 050 )
1 12 LOADR+
( ----- 051 )
VARIABLE ORG
VARIABLE L1 VARIABLE L2 VARIABLE L3 VARIABLE L4
d302 3
a304 2
( ----- 052 )
: _oor ." arg out of range: " .X SPC> ." PC: " PC .X NL> ABORT ;
d311 1
a311 1
( ----- 053 )
d322 1
a322 1
( ----- 054 )
d338 1
a338 1
( ----- 055 )
d352 1
a352 1
( ----- 056 )
d363 1
a363 1
( ----- 057 )
d377 1
a377 1
( ----- 058 )
d385 1
a385 1
( ----- 059 )
d397 1
a397 1
( ----- 060 )
d404 1
a404 1
( ----- 061 )
d420 1
a420 1
( ----- 062 )
d429 1
a429 1
( ----- 065 )
d446 1
a446 1
( ----- 066 )
@


1.12
log
@Make Z80 assembler more compact
This was done mostly by removing spurious whitespace, but also
by simplifying some OP words, more specifically with the
addition of the OPXY word.
@
text
@d4 3
a6 3
005 Z80 assembler             20-29 unused
030 8086 assembler            050 AVR assembler
70-99 unused
d17 2
a18 2
( ----- 005 )
( Z80 Assembler )
d21 2
d24 3
a31 2
: PC H@@ ORG @@ - BIN( @@ + ;
: <<3 3 LSHIFT ;    : <<4 4 LSHIFT ;
d180 1
a180 1
( ----- 030 )
d182 1
a182 5
1 13 LOADR+
( ----- 031 )
VARIABLE ORG
CREATE BIN( 0 , : BIN(+ BIN( @@ + ;
VARIABLE L1 VARIABLE L2 VARIABLE L3 VARIABLE L4
d190 2
a191 4
: <<3 3 LSHIFT ;
( ----- 032 )
: PC H@@ ORG @@ - BIN( @@ + ;
( ----- 033 )
d208 1
a208 1
( ----- 034 )
d219 1
a219 1
( ----- 035 )
d226 19
a244 5
( ----- 036 )
: OPm ( modrm op ) CREATE C, C, DOES> C@@+ C, C@@ OR C, ;
0 0xff OPm INC[w], 0 0xfe OPm INC[b],
0x8 0xff OPm DEC[w], 0x8 0xfe OPm DEC[b],
0x30 0xff OPm PUSH[w], 0 0x8f OPm POP[w],
a245 22
: OPm+ ( modrm op ) CREATE C, C, DOES>
    ( m off ) C@@+ C, C@@ ROT OR C, C, ;
0x40 0xff OPm+ INC[w]+, 0x40 0xfe OPm+ INC[b]+,
0x48 0xff OPm+ DEC[w]+, 0x48 0xfe OPm+ DEC[b]+,
0x70 0xff OPm+ PUSH[w]+, 0x40 0x8f OPm+ POP[w]+,
( ----- 037 )
: OPrm CREATE C, DOES> C@@ C, SWAP 3 LSHIFT OR C, ;
0x8a OPrm MOVr[],    0x8b OPrm MOVx[],
0x3a OPrm CMPr[],    0x3b OPrm CMPx[],

: OPmr CREATE C, DOES> C@@ C, 3 LSHIFT OR C, ;
0x88 OPmr MOV[]r,    0x89 OPmr MOV[]x,

: OPrm+ ( r m off ) CREATE C, DOES>
    C@@ C, ROT 3 LSHIFT ROT OR 0x40 OR C, C, ;
0x8a OPrm+ MOVr[]+,    0x8b OPrm+ MOVx[]+,
0x3a OPrm+ CMPr[]+,    0x3b OPrm+ CMPx[]+,

: OPm+r ( m off r ) CREATE C, DOES>
    C@@ C, 3 LSHIFT ROT OR 0x40 OR C, C, ;
0x88 OPm+r MOV[]+r,    0x89 OPm+r MOV[]+x,
( ----- 038 )
d251 1
a251 1
( ----- 040 )
d264 1
a264 1
( ----- 041 )
d281 1
a281 1
( ----- 042 )
d290 1
a290 1
( ----- 043 )
d2229 1
a2229 1
    DI DX MOVxx, AL [DI] MOVr[], AH AH XORrr, CBW,
d2239 1
a2239 1
    [BP] 0 INC[w]+, ( I++ )
d2241 1
a2241 1
    AX [BP] 0 MOVx[]+, AX [BP] -2 CMPx[]+,
d2255 1
a2255 1
    DI [DI] MOVx[], ( wordref )
d2259 1
a2259 1
AL [DI] MOVr[], DI INCx, ( PFA )
d2264 2
a2265 2
    DI PUSHx, DI INCx, DI INCx, DI [DI] MOVx[], THEN,
( alias, ialias, or const ) DI [DI] MOVx[], ( rd PFA )
d2268 1
a2268 1
    DI [DI] MOVx[], JMPs, lblexec @@ RPCs, THEN,
d2271 1
a2271 1
BP INCx, BP INCx, [BP] 0 DX MOV[]+x, ( pushRS )
d2273 1
a2273 1
DI [DI] MOVx[], JMPs, lblexec @@ RPCs,
d2295 1
a2295 1
    DX [BP] 0 MOVx[]+, BP DECx, BP DECx, ( popRS )
d2299 1
a2299 1
    DI DX MOVxx, DI [DI] MOVx[], DI PUSHx,
d2304 1
a2304 1
    AH AH XORrr, AL [DI] MOVr[], ( slen )
d2309 1
a2309 1
    BP INCx, BP INCx, [BP] 0 POP[w]+,
d2312 1
a2312 1
    [BP] 0 PUSH[w]+, BP DECx, BP DECx,
d2315 1
a2315 1
    [BP] 4 POP[w]+, [BP] 2 POP[w]+, BP 4 ADDxi,
d2318 1
a2318 1
    [BP] -2 PUSH[w]+, [BP] 0 PUSH[w]+, BP 4 SUBxi,
d2331 1
a2331 1
    DI SP MOVxx, AX [DI] 2 MOVx[]+, AX PUSHx, ;CODE
d2335 1
a2335 1
    DI SP ADDxx, DI [DI] MOVx[], DI PUSHx,
d2377 3
a2379 3
CODE ! 2 chkPS, DI POPx, AX POPx, [DI] AX MOV[]x, ;CODE
CODE @@ 1 chkPS, DI POPx, AX [DI] MOVx[], AX PUSHx, ;CODE
CODE C! 2 chkPS, DI POPx, AX POPx, [DI] AX MOV[]r, ;CODE
d2381 4
a2384 4
    DI POPx, AH AH XORrr, AL [DI] MOVr[], AX PUSHx, ;CODE
CODE I [BP] 0 PUSH[w]+, ;CODE
CODE I' [BP] -2 PUSH[w]+, ;CODE
CODE J [BP] -4 PUSH[w]+, ;CODE
d2390 2
a2391 2
    SI POPx, DI POPx, CH CH XORrr, CL [SI] MOVr[],
    CL [DI] CMPr[],
d2407 1
a2407 1
    CH CH XORrr, CL [SI] MOVr[], ( CX -> strlen )
d2411 1
a2411 1
        AL [DI] -1 MOVr[]+, 0x7f ANDALi, ( strlen )
d2420 1
a2420 1
    DI 3 SUBxi, AX [DI] MOVx[], ( prev ) AX AX ORxx,  ( cont. )
d2428 6
a2433 4
CODE 1+ 1 chkPS, DI SP MOVxx, [DI] INC[w], ;CODE
CODE 1- 1 chkPS, DI SP MOVxx, [DI] DEC[w], ;CODE
CODE 2+ 1 chkPS, DI SP MOVxx, [DI] INC[w], [DI] INC[w], ;CODE
CODE 2- 1 chkPS, DI SP MOVxx, [DI] DEC[w], [DI] DEC[w], ;CODE
@


1.11
log
@Make editor blocks more compact
@
text
@d4 3
a6 2
005 Z80 assembler             030 8086 assembler
050 AVR assembler             70-99 unused
d18 1
a18 14
( Z80 Assembler

006 Variables & consts
007 Utils                      008 OP1
010 OP1r                       012 OP1d
013 OP1rr                      015 OP2
016 OP2i                       017 OP2ri
018 OP2br                      019 OProt
020 OP2r                       021 OP2d
022 OP3di                      023 OP3i
024 Specials                   025 Flow
028 Macros )
1 23 LOADR+
( ----- 006 )
a26 1
( ----- 007 )
d29 2
d34 4
a37 5
: _ix+- 0xff AND 0xdd C, (HL) ;
: _iy+- 0xff AND 0xfd C, (HL) ;
: IX+ _ix+- ; : IX- 0 -^ _ix+- ;
: IY+ _iy+- ; : IY- 0 -^ _iy+- ;
( ----- 008 )
d49 1
a49 1
( ----- 009 )
d59 2
a60 10
( ----- 010 )
( r -- )
: OP1r
    CREATE C,
    DOES>
    C@@              ( r op )
    SWAP            ( op r )
    <<3             ( op r<<3 )
    OR C,
;
d62 1
a62 2
: INC(IXY+), INCr, C, ;
: DEC(IXY+), DECr, C, ;
d65 2
a66 4
( ----- 011 )
: OP1r0 ( r -- )
    CREATE C, DOES>
    C@@ ( r op ) OR C, ;
d71 3
a73 10
: CP(IXY+), CPr, C, ;
( ----- 012 )
: OP1d
    CREATE C,
    DOES>
    C@@              ( d op )
    SWAP            ( op d )
    <<4             ( op d<<4 )
    OR C,
;
d77 2
d80 14
a93 9
: ADDIXd, 0xdd C, ADDHLd, ;  : ADDIXIX, HL ADDIXd, ;
: ADDIYd, 0xfd C, ADDHLd, ;  : ADDIYIY, HL ADDIYd, ;
( ----- 013 )
: _1rr
    C@@              ( rd rr op )
    ROT             ( rr op rd )
    <<3             ( rr op rd<<3 )
    OR OR C,
;
d95 4
a98 14
( rd rr )
: OP1rr
    CREATE C,
    DOES>
    _1rr
;
0x40 OP1rr LDrr,
( ----- 014 )
( ixy+- HL rd )
: LDIXYr,
    ( dd/fd has already been spit )
    LDrr,           ( ixy+- )
    C,
;
d100 4
a103 55
( rd ixy+- HL )
: LDrIXY,
    ROT             ( ixy+- HL rd )
    SWAP            ( ixy+- rd HL )
    LDIXYr,
;
( ----- 015 )
: OP2 CREATE , DOES> @@ |M C, C, ;
0xeda1 OP2 CPI,                0xedb1 OP2 CPIR,
0xeda9 OP2 CPD,                0xedb9 OP2 CPDR,
0xed46 OP2 IM0,                0xed56 OP2 IM1,
0xed5e OP2 IM2,
0xeda0 OP2 LDI,                0xedb0 OP2 LDIR,
0xeda8 OP2 LDD,                0xedb8 OP2 LDDR,
0xed44 OP2 NEG,
0xed4d OP2 RETI,               0xed45 OP2 RETN,
( ----- 016 )
: OP2i ( i -- )
    CREATE C,
    DOES>
    C@@ C, C,
;
0xd3 OP2i OUTiA,
0xdb OP2i INAi,
0xc6 OP2i ADDi,
0xe6 OP2i ANDi,
0xf6 OP2i ORi,
0xd6 OP2i SUBi,
0xee OP2i XORi,
0xfe OP2i CPi,
( ----- 017 )
: OP2ri ( r i -- )
    CREATE C,
    DOES>
    C@@              ( r i op )
    ROT             ( i op r )
    <<3             ( i op r<<3 )
    OR C, C,
;
0x06 OP2ri LDri,
( ----- 018 )
( b r -- )
: OP2br
    CREATE C,
    DOES>
    0xcb C,
    C@@              ( b r op )
    ROT             ( r op b )
    <<3             ( r op b<<3 )
    OR OR C,
;
0xc0 OP2br SET,
0x80 OP2br RES,
0x40 OP2br BIT,
( ----- 019 )
d105 4
a108 14
: OProt ( r -- )
    CREATE C,
    DOES>
    0xcb C,
    C@@              ( r op )
    OR C,
;
0x10 OProt RL,
0x00 OProt RLC,
0x18 OProt RR,
0x08 OProt RRC,
0x20 OProt SLA,
0x38 OProt SRL,
( ----- 020 )
d111 8
a118 42
( r -- )
: OP2r
    CREATE ,
    DOES>
    @@ |M    ( r lsb msb )
    C,      ( r lsb )
    SWAP <<3 ( lsb r<<3 )
    OR C,
;
0xed41 OP2r OUT(C)r,
0xed40 OP2r INr(C),
( ----- 021 )
: OP2d ( d -- )
    CREATE C,
    DOES>
    0xed C,
    C@@ SWAP         ( op d )
    <<4             ( op d<< 4 )
    OR C,
;
0x4a OP2d ADCHLd,
0x42 OP2d SBCHLd,
( ----- 022 )
( d i -- )
: OP3di
    CREATE C,
    DOES>
    C@@              ( d n op )
    ROT             ( n op d )
    <<4             ( n op d<<4 )
    OR C, ,
;
0x01 OP3di LDdi,
( ----- 023 )
( i -- )
: OP3i
    CREATE C,
    DOES>
    C@@ C, ,
;
0xcd OP3i CALL,
0xc3 OP3i JP,
d121 1
a121 9
( ----- 024 )
: LDd(i), ( d i -- )
    0xed C,
    SWAP <<4 0x4b OR C, ,
;
: LD(i)d, ( i d -- )
    0xed C,
    <<4 0x43 OR C, ,
;
a122 1

d125 1
a125 1
( ----- 025 )
d138 1
a138 1
( ----- 026 )
d155 1
a155 1
( ----- 027 )
d164 1
a164 1
( ----- 028 )
@


1.10
log
@rsh: improve reliability

Make rupload check the integrity of sent data. Also, make
rsh end on CTRL+D instead of >0x80.
@
text
@d6 2
a7 2
100 Block editor              120 Visual Editor
150 Remote Shell
d604 1
a604 9
Block editor

This is an application to conveniently browse the contents of
the disk blocks and edit them. You can load it with "105 LOAD".

See doc/ed.txt
( ----- 105 )
1 7 LOADR+
( ----- 106 )
d610 2
a611 1
( ----- 107 )
d625 1
a625 1
( ----- 108 )
d638 1
a638 1
( ----- 109 )
d645 1
a645 1
( ----- 110 )
d656 1
a656 1
( ----- 111 )
d672 1
a672 1
( ----- 112 )
d685 3
a687 83
( ----- 120 )
Visual Editor

This editor, unlike the Block Editor (B100), is grid-based
instead of being command-based. It requires the AT-XY, COLS
and LINES words to be implemented. If you don't have those,
use the Block Editor.

It is loaded with "125 LOAD" and invoked with "VE". Note that
this also fully loads the Block Editor.

This editor uses 19 lines. The top line is the status line and
it's followed by 2 lines showing the contents of IBUF and
FBUF (see B100). There are then 16 contents lines. The contents
shown is that of the currently selected block.

                                                        (cont.)
( ----- 121 )
The status line displays the active block number, then the
"modifier" and then the cursor position. When the block is dir-
ty, an "*" is displayed next. At the right corner, a mode letter
can appear. 'R' for replace, 'I' for insert, 'F' for find.











                                                         (cont.)
( ----- 122 )
All keystrokes are directly interpreted by VE and have the
effect described below.

Pressing a 0-9 digit accumulates that digit into what is named
the "modifier". That modifier affects the behavior of many
keystrokes described below. The modifier starts at zero, but
most commands interpret a zero as a 1 so that they can have an
effect.

'G' selects the block specified by the modifier as the current
block. Any change made to the previously selected block is
saved beforehand.

'[' and ']' advances the selected block by "modifier". 't' opens
the previously opened block.
                                                        (cont.)
( ----- 123 )
'h' and 'l' move the cursor by "modifier" characters. 'j' and
'k', by lines. 'g' moves to "modifier" line.

'H' goes to the beginning of the line, 'L' to the end.

'w' moves forward by "modifier" words. 'b' moves backward.
'W' moves to end-of-word. 'B', backwards.

'I', 'F', 'Y', 'X' and 'E' invoke the corresponding command

'o' inserts a blank line after the cursor. 'O', before.

'D' deletes "modifier" lines at the cursor. The first of those
lines is copied to IBUF.
                                                        (cont.)
( ----- 124 )
'f' puts the contents of your previous cursor movement into
FBUF. If that movement was a forward movement, it brings the
cursor back where it was. This allows for an efficient combi-
nation of movements and 'E'. For example, if you want to delete
the next word, you type 'w', then 'f', then check your FBUF to
be sure, then press 'E'.

'R' goes into replace mode at current cursor position.
Following keystrokes replace current character and advance
cursor. Press return to return to normal mode.

'@@' re-reads current block even if it's dirty, thus undoing
recent changes.
( ----- 125 )
-20 LOAD+ ( B105, block editor )
d689 1
a689 1
( ----- 126 )
d706 1
a706 1
( ----- 127 )
d723 1
a723 1
( ----- 128 )
d736 1
a736 1
( ----- 129 )
d752 1
a752 1
( ----- 130 )
d765 1
a765 1
( ----- 131 )
d781 1
a781 1
( ----- 132 )
@


1.9
log
@Add "constant" word type

This give us two benefits: it makes access to HERE and
CURRENT, which are very often used, much faster, and it allows
the use of CONSTANT in cross-compiled code.

We can't hope to ever have a working DOES> in cross-compiled
code, but having CONSTANT removes a lot of friction by itself.
@
text
@d884 2
d887 1
a887 1
    KEY? IF DUP 0x80 < IF rsh> ELSE DROP EXIT THEN THEN
d892 1
d894 1
d897 2
a898 2
    ( sig: a u -- )
    ." : _ OVER + SWAP DO in I C! LOOP ; "
d902 2
a903 2
    ['] (emit) ['] EMIT **! _<< ;
: chk ( a u -- ) 0 ROT> OVER + SWAP DO I C@@ + LOOP .X ;
@


1.8
log
@xcomp: allow alias definition

It's going to be a "constant" alias if it's in ROM, but it's
still going to be faster than a word wrapper.
@
text
@a982 2
1 3 LOADR+
( ----- 263 )
d988 3
d1041 1
a1043 1

d1094 1
a1094 1
    SYSVARS 0x04 + LD(i)HL, ( RAM+04 == HERE )
d1119 12
a1130 8
    A ORr, IFZ, JP(HL), THEN,
    A DECr, ( compiled? ) IFNZ, ( no )
    3 CPi, IFZ, ( alias ) LDDE(HL), JR, lblexec BWR THEN,
    IFNC, ( ialias )
        LDDE(HL), EXDEHL, LDDE(HL), JR, lblexec BWR THEN,
    ( cell or does. push PFA ) HL PUSH,
    A DECr, JRZ, lblnext BWR ( cell )
    HL INCd, HL INCd, LDDE(HL), EXDEHL, ( does )
d1711 5
a1715 3
: RAM+ [ SYSVARS LITN ] + ; : BIN+ [ BIN( @@ LITN ] + ;
: HERE 0x04 RAM+ ; : ~C!ERR 0x41 RAM+ ;
: CURRENT 0x02 RAM+ ;
a1717 1
: C<* 0x0c RAM+  ;
d1826 2
a1827 2
: IN> 0x30 RAM+ ; ( current position in INBUF )
: IN( 0x60 RAM+ ; ( points to INBUF )
d1864 1
a1864 1
: _wb 0x0e RAM+ ;
d1934 1
a1934 1
: CONSTANT CREATE , DOES> @@ ;
d1945 1
a1945 1
: BLK> 0x38 RAM+ ;
d1947 1
a1947 1
: BLKDTY 0x3a RAM+ ;
d2018 1
d2021 2
a2022 2
    0x2e ( MEM<* ) RAM+ @@ C@@+ ( a+1 c )
    SWAP 0x2e RAM+ ! ( c ) ;
d2029 2
a2030 2
    C<* @@ >R 0x2e RAM+ ( MEM<* ) @@ >R
    BLK@@ BLK( 0x2e RAM+ ! ( Point to beginning of BLK )
d2033 1
a2033 1
    R> 0x2e RAM+ ! R> C<* !
d2043 1
a2043 1
    CURRENT @@ 0x2e RAM+ ! ( 2e == MEM<* )
d2490 15
a2504 14
    AL [DI] MOVr[], DI INCx, ( PFA )
    AL AL ORrr, IFZ, DI JMPr, THEN, ( native )
    AL DECr, IFNZ, ( not compiled )
        AL DECr, IFZ, ( cell )
            DI PUSHx, JMPs, lblnext @@ RPCs, THEN,
        AL DECr, IFZ, ( does )
            DI PUSHx, DI INCx, DI INCx, DI [DI] MOVx[], THEN,
        ( alias or ialias ) DI [DI] MOVx[],
        AL DECr, IFNZ, ( ialias ) DI [DI] MOVx[], THEN,
        JMPs, lblexec @@ RPCs,
    THEN, ( continue to compiled )
    BP INCx, BP INCx, [BP] 0 DX MOV[]+x, ( pushRS )
    DX DI MOVxx, DX INCx, DX INCx, ( --> IP )
    DI [DI] MOVx[], JMPs, lblexec @@ RPCs,
@


1.7
log
@rsh: add rupload command

Also, in VE, add "!" command handle cases where active blk
is -1.
@
text
@a989 1
: X:** (xentry) 5 C, , ;
d993 1
d1039 2
a1040 1
: (entry) (xentry) ; : CREATE XCREATE ; : :** X:** ;
@


1.6
log
@Rename (boot<) to MEM<

Because LOAD also uses it, boot< was a misnomer.
@
text
@d838 1
d875 1
d880 1
a880 1
( Remote Shell )
d882 2
a884 2
    rsh<? IF
        DUP 4 ( EOT ) = IF DROP EXIT THEN EMIT THEN
d886 14
a899 1
    AGAIN ;
@


1.5
log
@Remove CURRENT*

When I added it, I had grander indirection plans for CURRENT.
As we reach completion of the project and it turns out that
only xcomp use it, it seems wiser to remove that indirection
and resort to lower-tech CURRENT-swapping in xcomp.
@
text
@d1996 3
a1998 3
( Read from BOOT C< PTR and inc it. )
: (boot<)
    0x2e ( BOOT C< PTR ) RAM+ @@ C@@+ ( a+1 c )
d2006 1
a2006 1
    C<* @@ >R 0x2e RAM+ ( boot ptr ) @@ >R
d2008 1
a2008 1
    ['] (boot<) C<* !
d2020 1
a2020 1
    CURRENT @@ 0x2e RAM+ ! ( 2e == BOOT C< PTR )
d2023 1
a2023 1
    ['] (boot<) C<* !
@


1.4
log
@LOAD: avoid top-level BLK restore

When a LOAD called from RDLN< involves nested LOADs, don't
perform the last BLK@@ restore: it could be -1.
@
text
@d970 1
d972 2
a973 1
: XCON XCURRENT CURRENT* ! ; : XCOFF 0x02 RAM+ CURRENT* ! ;
d1692 1
a1692 1
: CURRENT* 0x51 RAM+ ; : CURRENT CURRENT* @@ ;
a2019 1
    0x02 RAM+ CURRENT* !
@


1.3
log
@Remove C<?

When I introduced it, it was the most straightforward way to
get the " ok" prompt to spit at proper moments, but with
subsequent refactorings, it became a needlessly complex
mechanism.
@
text
@d1920 1
a1920 1
( Current blk pointer in ( )
d2000 5
a2004 3
    BLK> @@ >R ( save restorable variables to RSP )
    C<* @@ >R
    0x2e RAM+ ( boot ptr ) @@ >R
d2006 1
a2006 1
    ['] (boot<) 0x0c RAM+ !
d2008 2
a2009 2
    R> 0x2e RAM+ !
    R> C<* ! R> BLK@@ ;
d2025 1
a2025 1
    LIT" Collapse OS" STYPE NL> (main) ;
@


1.2
log
@RDLN: don't spit NL>

When being called in VE, the NL> spit messed up the first line
of contents. Instead, we now spit the NL> in RDLN<.

Also, move RDLN and C< initialization, which was repeated in
both BOOT and QUIT, in (main). This deduplicates the words
and allow "IN"-type of words to be declared later.
@
text
@d1821 2
a1822 4
        RDLN NL>
    THEN ( c )
    ( update C<? flag )
    IN> @@ C@@ 0 > 0x06 RAM+ !  ( 06 == C<? ) ;
a1823 1
: C<? 0x06 RAM+ @@ ;
a1992 1
    C<? NOT IF SPC> LIT" ok" STYPE NL> THEN
d2002 1
a2002 1
    0x06 RAM+ ( C<? ) @@ >R 0x2e RAM+ ( boot ptr ) @@ >R
a2004 1
    1 0x06 RAM+ !  ( 06 == C<? )
d2006 1
a2006 1
    R> 0x2e RAM+ ! R> 0x06 RAM+ !
d2021 1
a2021 2
    ( boot< always has a char waiting. 06 == C<?* )
    1 0x06 RAM+ ! INTERPRET
@


1.1
log
@Initial revision
@
text
@a1692 3
: IN> 0x30 RAM+ ; ( current position in INBUF )
: IN( 0x60 RAM+ ; ( points to INBUF )
: IN$ 0 IN( DUP IN> ! ! ; ( flush input buffer )
d1694 1
a1694 1
: QUIT (resRS) 0 C<* ! IN$ LIT" (main)" FIND DROP EXECUTE ;
d1725 2
a1726 1
: NL> 0x50 RAM+ C@@ ?DUP IF EMIT ELSE 13 EMIT 10 EMIT THEN ;
a1798 1
: EOT? EOT = ;
d1801 4
a1804 2
( del is same as backspace )
: BS? DUP 0x7f = SWAP BS = OR ;
d1814 1
a1814 1
    DUP CR = SWAP EOT? OR UNTIL NL> IN( IN> ! ;
d1821 1
a1821 1
        RDLN
d2019 1
a2019 1
: (main) INTERPRET BYE ;
a2027 1
    0 C<* ! IN$
@
